## Javascript Core Challenges [Ref: ./JS_core_challenges.txt]

    1. Debounce Function 
    --> you constantly triggering an event eg: typing --> we want the event to execute only after d ms.
    Implement a debounce(fn, delay) utility to optimize performance-heavy operations like search input.

    2. Throttle Function 
    --> you constanly triggering an event eg: resizing/scroll -> we want the event to execute at an interval of d ms only.
    Implement a throttle(fn, delay) function for limiting event frequency (e.g., scroll, resize).

    3. Deep Clone And Deep Merge.
    Deeply clone an object, handling nested structures and edge cases.
    Deeply merge 2 nested objects, handle nested structure.

    4. Flatten Nested Array
    Recursively flatten:
    Input: [1, [2, [3, 4], 5]] → Output: [1, 2, 3, 4, 5]

    5. Implement once(fn)
    Run a function only once—return cached result on next calls.

    6. Custom bind, call, apply
    Polyfill and explain behavior in different contexts.

    7. Promise Polyfill / Promise.all Clone

    8. Currying a Function
    sum(1)(2)(3)() → 6

    9. Event Emitter
    Implement on, emit, off, once.

        on -> Adds callback to an event's callback..
        emit -> calls the registered callback with args.
        off -> Removes the sepecific callback
        once -> Register a callback that auto removes.

        const EventEmitter = require("events"); // Part of the event core module in node js.
        const emitter = new EventEmitter();

    10. Memoization Function
    Cache function calls with different inputs.




## React — Component & Hook Challenges [Ref: CodeSandbox/React-interview-practise-ts]

    11. Custom useDebounce Hook
    Reusable hook that debounces an input value.

    12. Build a Controlled Form with Validation
    With custom validation rules and multiple inputs.

    13. Modal with Portal
    Use ReactDOM.createPortal, and trap focus.

    14. Tabs/Accordion Component
    Accessible, keyboard-navigable, with animation.

    15. Toast Notification System  ---> [System Design Question]
    Dynamic rendering, dismissable, timeouts.

    16. Infinite Scroll List
    Load more content on scroll, optimized for performance.

    17. usePrevious, useToggle, useClickOutside
    Utility hooks for clean logic reuse.

    18. Dynamic Component Loader
    Render a component from a config map:
    const map = { input: InputComponent, button: Button };

    19. React Router
    usecase and machine coading practise.
    using React-router-dom For handling routes.
    NOTE:
        - Must wrap <App /> with <BrowserRouter> inside main.jsx
        - What is <Outlet> from react-router-dom ?
            - Let say you have defined Routes with some nested routes inside.
            - using Outlet will render the matching nested route's element there.
        - Types of Routes useCase:
            1. Default Landing page Route => Checks the Authentication and redirect to Home or SignIn page.
            eg: 
            const Layout = () => {
                //Runs the authenticated service...
                return isAuthenticated ? <Outlet /> : <Naviagte to="user-auth" replace />
            }

            Inside AppRouter.tsx :    
                <Routes>
                    <Route element={<Layout />}>
                        // all your application Routes...
                    <Route>
                    <Route path="user-auth" element={<Auth />} />
                </Routes>
            NOTE:
                - Above, The layout component will run authentication Logic and every app url re-direction ==> If authenticated then <Outlet /> i.e it will render the protected application routes. 
                => If not authenticated ==> It will naviagte to user-auth route for authentication.
            
            2. Routes that are nested [use Naviagte and Outlet and LinkNav for this]
                -> <NavLink to="path-name">Link-Name</NavLink> 
                -> used to navigate from within the application.
                
            3. Routes with params and queries => [useParams and useSearchParams hook provided by react-router-dom]
            4. Fallback Route => If no Route matches => fallback to the deafult screen [NOTE: write at the end with path="*" or directly add element <Route element={<NotFound />} />].

    eg: 
        <Route path="/dashboard" element={<DashboardLayout />}>
            <Route path="overview" element={<Overview />} />
            <Route path="settings" element={<Settings />} />
        </Route>

        Inside the component DashboardLayout: 
            const DashboardLayout = () => {
                return (
                    <div>
                        <h1>Dashboard Layout</h1>
                        <Outlet />
                    </div>
                );
            };
        NOTE: Now Outlet will render either /dashboard/overview or /dsahboard/settings.


Extra topics: [Ref: Roadsidecoder]
    1. Folder structure.
    2. Pagination
    3. Password generation
    4. breadcrumbs
    5. OTP login
    6. AutoSuggestion  ---> [System Design Question]






### Using Hooks Like: 

        1. Context API Hook.
            -- You need to create a contextAPI with React.createContext().
            -- Wrap your Parent Component with contextAPI.provider and pass the value.
            NOTE: Do the above in a seperate File, and upLift the state from Parent to here.
            -- Now all the children below that parent will have access to the value. Saves us from Prop drilling and unnecessary re-renders.
        
        2. Reducer Hook.
            -- Make more sense when you use it in Redux state.
            -- It take 2 params: 
                1. a callback with 2 params: state and action [action will have type and payload]
                2. the initial state.
            -- Helps us to manage Complex state updates based on conditions.

        3. Imperative Hook.
            -- Very interestion hook.
            -- In the child component you have ref that hold an Input or Aggrid Context. 
            -- You want to expose few custom methods to parent so that it can handle actions from outside.
            -- useImperative Hook provides a way you can expose your custom method from child to parent.
            NOTE: 
                1. In child a ref must be there that holds the context of a particular DOM element.
                2. Child component has to be of React.forwardRef type.
                3. In child component you have to decalre the useImperative hook to expose the methods to parents.
                4. From the parent, the ref that hold the context of this Child will have these exposed method.

        4. useId hook.
            -- Rarely used hook but good functionality.
            -- we can bind an Input and Label in HTML using name field from Input and HTMLFor field in label.
            -- We need to provide a name here for the above to work. ==> useId generates a Random Name for us to use.
            NOTE: 
                Never use useId generated ids in Key prop in looping logic.

        5. useTransition:
            -- use to efficiently handle functions that are expensive [takes lot of time to Execute] ==> slows the UI => bad user Experience .
            -- useTransition returns 2 things:
                1. isPending => will be ture, untill the expensive function done executing. ==> based on this show a loading indicator.
                2. startTransition => callback function that takes the expensive function.

        6. useDeferredValue:
            -- Similar to useTransition but it will show the older value untill new data is fetched.
            -- It takes a value and returns a deferredValue. 
                    const[query, setQuery] = useState('');
                eg: const deferredQuery = useDeferredValue(query);
            -- Here,
                1. Initially both query and deferredQuery will be same.
                2. the query will update immediatly as the input changes ==> but deferredQuery will be still old untill the new data is fetched.
                3. Once new data is fetched ==> It updates the ui and shows New data that is fetched.

            NOTE:
                - until we get the new data from the response with the updated val, useDeferredValue will keep the old value and result, once new value comes => It loads the same in UI.

        7. useActionState (React 19)
            -- Handle Form actions efficiently.
            -- eg: const [state, formAction, isPending] = useActionState(fn, initialState);
            -- useCase:
                1. pass the formAction from above in form's "action" attribute.
                2. fn --> This specify the action needs to be perform when the form is submitted.
                    -> it takes 2 params: previousStae and queryParms.
                    -> we can extract formData using name field. eg: queryParms.get("filed_name")                    
                3. If the it takes time ==> isPending can be used to show loading Indicator.

        8. useFormStatus (React 19)
        9. useOptimistic (React 19)
        10. Custom Hooks.
            -- Seperatation of Logic is implemented using Custom Hook.
            -- eg: 
                An API logic can be seperated out in form of a custom hook that can be return latest Value and a API state.






NOTE:
    Ideal Folder structure to Follow...
        under src...
            1. index.tsx => first File that holds the layout of the page.
            2. components => Folder => that holds the child components.
            3. types/index.ts ==> file that holds all types for this components.
            4. api/index.ts ==> Holds the fetch calls and API methods to backend.
            5. hooks/useCustomHooks.ts ==> file that handles a particular CRUD Logic like create or fetch or update Operation or any other custom hook.






## React Queries:   [*** IMP ***] 
    What ?
        - It is a data-fetching and caching library for React that 
            1. Manages remote data state.
            2. Caches API calls.
            3. Offer utils like refetch, retries, pagiantion etc...
    
    -- Basically,
        It handles fetching data automatically or manually, also provide caching of the data, handles loading and error state too.

    -- To use React queries:
        1. You must add @tanstack/react-queries in dependency.
        2. Then wrap the Parent Componet under QueryClientProvider and client as new QueryClient.
    
    -- example:
        const {data, isLoading, refresh, isError, error} = useQuery<T>({
            queryKey: ['uniqueKeyName'],
            queryFn: fetchAPI,
            stateTime: 5 * 60 * 1000, // 5 min caching.
            retry: 2,
            refreshOnWindowFocus: true,
            enabled: true,
        })
    -- Life Cycle:
        As the app loads ==> query checks in cache ==> If not make a call => fetch data and show.
    -- Params:
        1. queryKey => Under this name caching is done.
        2. queryFn => this is the api call that fetches data.
        3. staleTime => upto this time => data stay fresh.
        4. retry => If API fails, this max no o times it will try again.
        5. enabled --> a flag that decides if it should fetch data or not.

    -- Refresh the data that is fetched..
        queryClient.invalidateQueries(['queryKeys']);

    --usecases:
        1. Fetch data based on any state changes.   
            const [name, setName] = useState("");

            const { data, isLoading } = useQuery({
                queryKey: ['user', name], // key includes name to make it dynamic
                queryFn: () => fetchUserByName(name),
                enabled: !!name, // only runs when name is truthy
            });


        2. Fetch data on component loads.
            const { data, isLoading } = useQuery({
                queryKey: ['todos'],
                queryFn: fetchTodos,
            });


        3. Fetch data after update.
        const queryClient = useQueryClient();
        const addTodoMutation = useMutation({
            mutationFn: addTodoApi,
            onSuccess: () => {
                queryClient.invalidateQueries(['todos']); // triggers re-fetch
            },
        });


        
        4. Fetch data strictly based on a flag.
        const { data, refetch, isFetching } = useQuery({
            queryKey: ['report'],
            queryFn: fetchReport,
            enabled: false, // prevent the APi call to run on Mounting phase.
        });

        // On button click
        <button onClick={() => refetch()}>Get Report</button>

    -- Automatically Fetching data Vs Manual fetching data with React Query.
        1. when enable -> true.
            React Query will automatically fetch:
            ✅ On component mount
            🔁 When query becomes stale (e.g. after staleTime)
            🔄 When window/tab regains focus (unless disabled)
            🔁 On network reconnect
            ♻️ If invalidated via invalidateQueries

            NOTE: we dont need refetch() method at all.
        
            usecase:
                React Query auto-fetch on:
                    1.Mount
                    2.Tab focus
                    3.Reconnect
                    4.Stale data

        2. When enable -> false.
            React does nothing ==> It only fetch data when you we call refetch().
            usecase:
                If your data is optional, conditional, or user-triggered, go with manual fetching (enabled: false + refetch()).








### System Design-Oriented UI Coding

    19. Build a Lightweight Router
    Without React Router – handle dynamic routes, query params.

    20. Build a Reusable Component Library
    Design tokens, theming, and extensible components.

    21. Real-Time Chat UI
    With WebSocket integration and optimistic rendering.







#### Additional Topics:

🔸 1. Code Splitting & Lazy Loading
How to lazy load routes or components. --> React.lazy, Suspense, dynamic import().

Interview Q: “How would you optimize initial bundle size in a large app?”

🔸 2. Accessibility (a11y) Best Practices ---> aria-* attributes, focus management, keyboard navigation.

Interview Q: “Build an accessible dropdown.”
Or: “How do you make a modal keyboard-friendly?”

🔸 3. Error Boundaries
Class component with componentDidCatch.
Handling graceful UI degradation.

Interview Q: “How do you handle runtime errors in React?”

🔸 4. Testing (Unit + Integration)
Writing tests using Jest + Testing Library.
Testing hooks, user interactions, async behavior.

Interview Q: “How would you test a custom hook or form component?”

🔸 5. Security in Frontend
XSS, CSRF, sanitizing inputs, avoiding inline scripts.

Interview Q: “How do you prevent script injection in React?”

🔸 6. State Management Trade-offs
Local state vs Context vs Redux vs Zustand/Recoil.

Derived state problems, prop drilling, performance.

Interview Q: “When would you lift state vs use context?”

🔸 7. React Performance Optimization
Reconciliation process, render phases.

React.memo, useMemo, useCallback, lazy rendering.

Interview Q: “What causes unnecessary re-renders in React?”

🔸 8. Immutable Patterns & Structural Sharing
Handling large deeply nested objects immutably.

Interview Q: “Why is immutability important in React?”

🔸 9. Browser APIs
localStorage, sessionStorage, History API, Fetch, AbortController, BroadcastChannel.

Interview Q: “How do you cancel a fetch request in progress?”

🔸 10. Web Workers or Service Workers (Bonus)
Used in performance-heavy frontend logic or PWAs.