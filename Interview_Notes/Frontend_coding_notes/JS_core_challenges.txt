//Ref: Frontend_coding_concepts.txt

### JS Core Challenges code for Reference ###

1. Debouncing function:  -> trigger event only after d ms.
    NOTE:
        1. tailing Option: This is the default debounced method, where each trigger will be executed only after d delay. 
        2. Leading Option: This is like for the very first call => executes immediately, then next call onwards it will delay execution by d delay.

// use closure to store the timer instance...
const debounce = (cb, delay, options = {}) => {
    let timer;
    let lastArgs;
    const {leading = false, tailing = true} = options;
    return (...args) => {
        // keep track of the last passed args...
        lastArgs = args;
        
        //check do we need to call the function now => Leading is true and timer is not defined.
        const callNow = leading && !timer;  
        
        if(callNow) {
            cb(...args);
        }
        
        // If tailing -> we want to clear any already running timer...
        clearTimeout(timer);
        
        // your timer dealy...
        timer = setTimeout(()=> {
            //this runs only in case -> tailing and isCallNow is not true.
            if(tailing && !callNow) {
                cb(...args);
            }
        }, delay);
    }
}


// This cancels any timer that is still active..  [eg: cleanUp on unMounting of any component in React]
debounce.cancel = () => {
    clearTimeout(timer);
    timer = null;
}

// This cancels timer and executes the callback with the last passed args. [eg: before submitting a form, last typed searched Item executes immediately]
debounce.flush = () => {
    clearTimeout(timer);
    cb(...lastArgs);
    timer = null;
}


const log = () => console.log("Called!");
const debouncedLog = debounce(log, 500, {leading: true});

debouncedLog(); // called immediately
debouncedLog(); // cancels previous, resets timer
debouncedLog(); // cancels previous, resets timer
debouncedLog(); // cancels previous, resets timer
debouncedLog(); // only this call will fire after 500ms


### Followup questions:
1. Leading vs Trailing Execution
    Right now, your debounce fires only on trailing edge (after delay).
    Can you extend it to allow leading edge execution (run immediately on first call, then debounce others)?

2. Cancel & Flush
    Suppose you want to cancel any pending execution (like user canceled typing).
    Or flush immediately (force execution of last queued call).
    ðŸ‘‰ How would you design your debounce to support debouncedFn.cancel() and debouncedFn.flush()?

3. Practical Scenario

    Imagine using debounce in a React search bar (typing API calls).
    Why would debounce be better than throttle here?  debouce usecase [limits the no of executions] and throttle usecase is different [limits rate of executions]
    When would you prefer throttle instead? [Scroll events or resize events]


### NOTE: 
 1. Use debounce for â€œgrouping eventsâ€ (user stops typing).
 2. Use throttle for â€œrate limitingâ€ (scroll, resize, mouse move).


2. Throttle fucntion: -> trigger event at d ms interval.

//Implemented using a tracker for the start and end time...
const throttle = (cb, delay) => {
    let lastTime = 0;
    
    return (...args) => {
        const currTime = Date.now();
        
        //check the diff => If < delay i.e triggered too soon, > delay i.e exectute cb and update lastTime.
        if(currTime - lastTime < delay) {
            return; 
        }
        
        lastTime = currTime;
        cb(...args);
    }
}

const log = () => console.log("Called!");
const throttledLog = throttle(log, 1000);

throttledLog(); // executes immediately
throttledLog(); // ignored if called within 1s
throttledLog(); // executes only after 1s has passed



3. Deep Clone. --> JSON.prase + JSON.strigigy has some drawbacks for deep copy for functions, dates, undefined and Regrex.

// Recursion Approach
const customDeepClone = (val, keyVisited = new Map()) => {
    //1. Handle if val is not object/array/date/regex...
    if(val === null || typeof val !== "object")
        return val;
        
    //2. If val is already visited once..
    if(keyVisited.has(val)) 
        return keyVisited.get(val);
        
    let clone;
    
    // 3. Handle for date type.
    if(val instanceof Date) {
        clone = new Date(val);
    } else if (Array.isArray(val)) {
        // 4. Handle for array type.
        clone = [];
        keyVisited.set(val, clone);
        for(let item of val) {
            clone.push(customDeepClone(item, keyVisited));
        }
        
    } else if(val instanceof RegExp) {
        // 5. Handle for regex type. 
        clone = new RegExp(val.source, val.flags);
        
    } else {
        // 6. Handle for object type.
        clone = {};
        keyVisited.set(val, clone);
        for(let key in val) {
            if(val.hasOwnProperty(key)) {
                clone[key] = customDeepClone(val[key], keyVisited);
            }
        }
    }
    return clone;
}


//NOTE: here using a map saves us from circular refernce issue. eg: obj = {}; obj.self = obj;  --> with map the customDeepClone will be stuck in an infinite loop => causes stack overflow.
// -> visitedMap, remembers all the keys and if the same key comes again, we take is from the map, instead of creating a new clone [Avoid the recurrsion call too..]

const original = {
  name: "Sourav",
  meta: {
    age: 28,
    skills: ["React", "JS"],
  },
  test: undefined,
  fun: function () {
      console.log('Hii');
  }
};

const copy = customDeepClone(original);
console.log(original);
console.log(copy);
console.log(JSON.parse(JSON.stringify(original))); // With this, function, regexp, undefined will be lost. 




Deep Merge --> Merge nested object with Recursion.

const isObject = (obj) => {
    return obj && typeof obj === "object" && !Array.isArray(obj);
}

const customDeepMerge = (obj1, obj2) => {
    //edge case check...
    if(typeof obj1 !== "object" && typeof obj2 !== "object")
        return null;
    if(obj1 == null || typeof obj1 !== "object") 
        return obj2;
    if(obj2 == null || typeof obj2 !== "object")
        return obj1;
        
    let result = {};
    
    //mege all the keys and get a common distinct key list..
    const mergedKeys = new Set([...Object.keys(obj1), ...Object.keys(obj2)]);
    
    // we will loop throught the keys...
    for(let key of mergedKeys) {
        const val1 = obj1[key];
        const val2 = obj2[key];
        
        //case1: If both val1 and val2 are objects
        //case2: If both val1 and val2 are arrays.
        //case3: None of the above --> Overwrite with val2

        if(Array.isArray(val1) && Array.isArray(val2)) {
            result[key] = [...new Set([...val1,...val2])];
        } else if(isObject(val1) && isObject(val2)) {
            result[key] =  customDeepMerge(val1, val2);      
        } else {
            result[key] = val2 !== undefined ? val2 : val1; 
        }
    }
    
    return result;
};


const userProfile = {
  id: 1,
  name: 'Alex',
  details: {
    age: 30,
    city: 'New York'
  }
};

const userSettings = {
  id: 1,
  details: {
    theme: 'dark',
    notifications: true
  },
  preferences: {
    language: 'en'
  }
};

Output:
{
  "id": 1,
  "name": "Alex",
  "details": {
    "age": 30,
    "city": "New York",
    "theme": "dark",
    "notifications": true
  },
  "preferences": {
    "language": "en"
  }
}




4. Flat Array/Object ====> Nested Array or objects must be flatten...

const flatten = (items) => {
    
    if(!Array.isArray(items)) return [items];
    if(items.length === 0) return [];
        
    let result = [];
    
    for(let item of items) {
        if(Array.isArray(item)) {
            result.push(...flatten(item));
        } else {
            result.push(item);
        }
    }
    return result;
}


// iterative Approach: using stack. [if the poped ele is Array => spread it and add back to stack, If not an arr, push into res. =>> DO this till stack is empty]
const flattenIterative = (items) => {
  const stack = [...items];
  const result = [];

  while (stack.length) {
    const next = stack.pop();
    if (Array.isArray(next)) {
      stack.push(...next); // expand arrays
    } else {
      result.push(next);
    }
  }

  return result.reverse(); // because stack reverses order
};


console.log(flatten([1,[2, [3, 4], 5], 6])); //1, 2, 3, 4, 5, 6


// Flattern a Nested Object [System design Question] 

const nestedObj = {
  id: 1,
  name: "Alice",
  address: {
    city: "New York",
    zip: 10001,
    geo: {
      lat: 40.7128,
      lng: -74.0060
    }
  },
  hobbies: ["reading", "cycling"]
};


//Logic: keep track of parentKey and result in resurive call for keys that has nested object.
const flattenObject = (obj, parentKey = "", result = {}) => {
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      const newKey = parentKey ? `${parentKey}.${key}` : key;
      const value = obj[key];

      // If val is a obj, not null and not an arr...
      if (typeof value === "object" && value !== null && !Array.isArray(value)) {
        // recurse if value is a nested object
        flattenObject(value, newKey, result);
      } else {
        // assign primitive / array directly
        result[newKey] = value;
      }
    }
  }
  return result;
};



Output: 

{
  id: 1,
  name: "Alice",
  "address.city": "New York",
  "address.zip": 10001,
  "address.geo.lat": 40.7128,
  "address.geo.lng": -74.0060,
  hobbies: ["reading", "cycling"]
}



5. Custom call, apply and bind with context.

    let obj1 = {
        name: "sourav",
        age: 27
    }

    function describe(msg) {
        console.log(this);
        console.log(`Message from ${this.name} of age ${this.age}: ${msg}`);
    }

    1. Polyfill for call...


    Function.prototype.myCall = function(context = {}, ...args) {
        // myCall can be only called from a function..
        if(typeof this !== 'function') {
            throw new Error(this + "is not callable");
        }
        
        //which ever functionis is calling myCall --> add that inside context.
        context.fn = this;
        context.fn(...args);
    }

    describe.myCall(obj1, "using call function method");


    2. Polyfill for apply...

    Function.prototype.myApply = function(context = {}, args=[]) {
        // myApply can be only called from a function..
        if(typeof this !== 'function') {
            throw new Error(this + "is not callable");
        }
        // second param should be array in case of apply => else it should be type array.
        if(!Array.isArray(args)) {
            throw new Error("CreateListFromArrayLike called on non-object");
        }
        
        //which ever functionis is calling myCall --> add that inside context.
        context.fn = this;
        context.fn(...args);
    }

    describe.myApply(obj1, ["using call function method", "test"]);


    3. Polyfill for bind...

    Function.prototype.myBind = function(context = {}, ...args) {
        // myCall can be only called from a function..
        if(typeof this !== 'function') {
            throw new Error(this + "cannot be bound as it's not callable");
        }
        
        //which ever functionis is calling myCall --> add that inside context.
        context.fn = this;
        return (...args1) => {
            context.fn(...args,...args1);
        };
    }

    const newFun = describe.myBind(obj1, "test");
    newFun();


6. Promise polyfill, Promise.all clone. [*** IMP ***]


const myPromise = function (executor) {

    //4. a variable to store resolved or rejected from .then/.catch..
    let onResolve, onReject;
    let isFulfilled = false, 
    isRejected = false, 
    isCalled = false, 
    storeVal;
    
    //3. functions that runs from the executor --> passing resolve/reject value to local onResolve/onReject variable.
    function resolve(value) {
        isFulfilled = true;
        storeVal = value;
        
        // onResolve wont be a function in case of Sync.
        if(typeof onResolve === "function") {
            isCalled = true;
            onResolve(value);
        }
        
    }
    
    function reject(value) {
        isRejected = true;
        storedVal = value;
        
        if(typeof onReject === "function") {
            onReject(value);
        }
    }
    
    //1. adding a then/catch method on whoever calling this function.
    this.then = function(callback) {
        onResolve = callback;
        
        if(isFulfilled && !isCalled) {
            isCalled = true;
            onResolve(storeVal);
        }
        
        return this;
    }
    
    this.catch = function(callback) {
        onReject = callback;
        
        if(isRejected && !isCalled) {
            isCalled = true;
            onReject(storedVal);
        }
        return this;
    }
    
    //2. calling the executor with resolve/reject funtions.
    executor(resolve, reject);
}

//NOTE:
// In Async mode, first .then executes and then the promise resolves after some time. --> here, onResolve will be a function, since .then attach first.
// In Sync mode, First the promise resolves and .then() runs afterward. -> here, onRsolve will be undefined as .then attach later, resolves runs immediatly.

const expPromise = new myPromise((resolve, reject) => {
    
    //Async example..
    setTimeout(()=> {
        resolve("This Promise is from async call");
    }, 1000);
    
    //Sync example..
    // resolve("This Promise is a sync call");
});

expPromise
    .then((res)=> {
        console.log(res);
    })
    .catch((err) => {
        console.error(err);
    })


### Promise.resolve polyfill....
myPromise.resolve = (val) => {
    return new myPromise((resolve, reject) => resolve(val));
}  



#### Promise.all poylfill.... [***** VVIMP ****]

// Some functions that returns promise...
const fun1 = (msg) => {
    return new Promise((resolve, reject) => {
        setTimeout(() => resolve(msg), 2000);
    })
}
const fun2 = (msg) => {
    return new Promise((resolve, reject) => {
        setTimeout(() => resolve(msg), 1000);
    })
}
const fun3 = (msg) => {
    return new Promise((resolve, reject) => {
        setTimeout(() => resolve(msg), 3000);
    })
}

// Promise polyfill....
Promise.allPolyfill = (promises) => {
    return new Promise((resolve, reject) => {
        // Promise.all polyfill here...
        let result = [];
        
        if(!promises.length) {
            return resolve(result);
        }
        
        let pending = promises.length; // track if all promises resolved
        
        //iterate all of the promises and resolve them 1 by 1 ==> add into result array...
        promises.forEach((promiseItem, idx) => {
            Promise.resolve(promiseItem).then((res) => {
                result[idx] = res;
                pending--;
                
                 // If all the promises are resolved...
                if(pending === 0) {
                    resolve(result);
                }
            }, reject);
        })
    })
}


Promise.allPolyfill([
    fun1("This is Promise1"),
    fun2("This is Promise2"),
    fun3("This is Promise3"),
]).then((res) => {
    console.log(res);
}).catch(err => console.log(err));



### NOTE:
    1. Promise.all => rejects fast if any Promise rejects.
    2. Promise.allSettled => waits for all the promise to settle (fullfilled or rejected), returns array of {status, value/rejectReason}.
    3. Promise.race => resolve or reject with the first settled promise (success or error).  
    4. Promise.any =>  resolves with the first fullfilled promise, rejects if all reject.

### IMP => How would you handle huge arrays of Promises without flooding the system (like 10K API calls) ? 
    Sol:
        -> Implement concurrency-limited Promise.all, using a queue and only running N promises in parrallel.

// Logic -> Loop fills slots â†’ task finishes â†’ triggers runTask â†’ fills the freed slot â†’ repeat until all done.  [ wait Queue implementation ] TC: O(limit) at a time.

const delay = (ms, val) => {
  return () =>
    new Promise((resolve) => setTimeout(() => resolve(val), ms));  
};

const tasks = [
  delay(1000, "A"),
  delay(500, "B"),
  delay(300, "C"),
  delay(400, "D"),
  delay(200, "E"),
];

const promiseAllWithLimit = (taskList, limit) => {
    return new Promise((resolve, reject) => {
        const res = [];
        
        let i = 0;
        let completed = 0;
        let running = 0;
        
        function runTask() {
            
            // check if all tasks are completed ?
            if(completed == taskList.length) {
                return resolve(res);
            }
            
            // Loop runs for limit no of task at a time and i is bounded...
            while(running < limit && i < taskList.length) {
                const currIndex = i;
                const task = taskList[i];
                
                i++;
                running++;
                
                task()
                    .then((result) => {
                        res[currIndex] = result;
                        running--;
                        completed++;
                        
                        runTask(); //Triggers the next batch of tasks.
                    })
                    .catch(reject);
            }
        }
        
        runTask();
        
    });
}

promiseAllWithLimit(tasks, 2).then(console.log);
// Expected: ["A", "B", "C", "D", "E"] but tasks run max 2 at a time




7. Currying...

//Currying...
const sum = (val1) => {
    return (val2) => {
        return (val3) => {
            return () => {
                return val1*val2*val3;
            }
        }
    }
}

console.log(sum(1)(2)(3)());


// Recusrion + currying for a converting a normal function into Currying.
    --> collect all the args, then then execute the function...
 
function sum(a, b, c) {
  return a + b + c;
}

console.log(sum.length) // Prints the length of total arguments it is taking...

//Currying a bit matured example... REcursion + currying...
function curry(fn) {
    return function curried(...args) {
        if(args.length >= fn.length) {
            console.log('## Done collection all args', args);
            return fn.apply(this, args);  //calls the sum function here..
        } else {
            // collects all the arguments passed to curry till it is same as what sum or fun expects...
            return function(...nextArgs) {
                return curried.apply(this, [...args, ...nextArgs]);
            }
        }
    }
}

const curriedSum = curry(sum);

const ans = curriedSum(1)(2)(3);
console.log(ans);  // 6


8. Event Emitter...

class EventEmitter {
  constructor() {
    this.events = {};
  }

    // Adds callbacks into events obj with their respective event name...
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = [];
    }

    this.events[eventName].push(callback);
  }

    // find all callbacks from event name and call them one by one with passed args..
  emit(eventName, ...args) {
    const callbacks = this.events[eventName];
    if (callbacks) {
      callbacks.forEach(cb => cb(...args));
    }
  }

  // remove a particular callbacks...
  off(eventName, callback) {
    const callbacks = this.events[eventName];
    if (callbacks) {
      this.events[eventName] = callbacks.filter(cb => cb !== callback);
    }
  }

    // executes the callback and then removes it from the event..
  once(eventName, callback) {
    const wrapper = (...args) => {
      callback(...args);
      this.off(eventName, wrapper); // remove after first call
    };
    this.on(eventName, wrapper);
  }
}

const emitter = new EventEmitter();

function greet(name) {
  console.log(`Hello, ${name}`);
}

emitter.on("greet", greet);
emitter.emit("greet", "Sourav"); // Hello, Sourav

emitter.off("greet", greet);
emitter.emit("greet", "Sourav"); // (no output)

emitter.once("login", () => console.log("User logged in"));
emitter.emit("login"); // User logged in
emitter.emit("login"); // (no output)




9. Memorization

function slowAdd(a, b) {
  console.log("Computing...");
  return a + b;
}

// Memorization of params and result using cache map...
const memoize = (fn) => {
    let cache = new Map();
    return (...args) => {
        
        // stringify the incoming args and store as key...
        const key = JSON.stringify(args);
        
        // If cache already hold that --> returns from cahce...
        if(cache[key]) {
            console.log('From cache:');
            return cache[key];
        }
        
        // Call the function, usign apply, as args can be multiple..
        const res = fn.apply(this, args);
        cache[key] = res;
        return res;
    }
}

const memoizedAdd = memoize(slowAdd);

console.log(memoizedAdd(1, 2)); // "Computing...", returns 3
console.log(memoizedAdd(1, 2)); // returns 3 from cache (no "Computing...")














