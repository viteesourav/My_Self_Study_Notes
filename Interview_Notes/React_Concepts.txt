** Important React Concepts **

1. Core Concepts -> Fundamentals.
    1. JSX and Rendering Basics
        JSX syntax and expressions
        Rendering elements & components
        Babel and transpilation
    2. Components (Functional & Class)
        Functional vs Class components
        Props and Prop Drilling
        Component lifecycle (both types)
    3. State and setState
        State management in function vs class components
        Batching of state updates
        setState behavior (async vs sync)
        Functional updates
    4. Event Handling
        Synthetic events in React
        Binding and context in event handlers
    5. Conditional Rendering and Lists
        Rendering lists and keys
        Short-circuiting, ternary, and IIFE patterns
2. React Hooks 
    6. useState
        Initial state, lazy initialization
        Common patterns and pitfalls
    7. useEffect
        Dependency array
        Cleanup function
        Execution order (after paint)
        Common interview traps
    8. useRef
        DOM reference
        Mutable value storage without re-render
    9. useContext
        Creating and using Context
        Avoiding prop drilling
        Context performance pitfalls
    10. useMemo & useCallback
        Memoization and performance optimization
        Common misuse and proper use cases
    11. Custom Hooks
        Structure and design patterns
        Sharing logic across components
3. ADvance Topics:
    12. Reconciliation and Virtual DOM
        How React compares and updates DOM
        Keys in diffing algorithm
    13. Rendering Optimization
        Memoization (React.memo, useMemo)
        Avoiding unnecessary re-renders
        Profiling performance
    14. Error Boundaries
        Handling errors in class components
        Why no error boundaries in function components
    15. Controlled vs Uncontrolled Components
        Forms in React
        Refs vs State
    16. React Router (v6+)
        Routing, navigation, params, nested routes
        Route guarding and redirection
    17. Higher Order Components (HOC)
        What they are
        Use cases and patterns
    18. Render Props
        Pattern explanation
        Real use cases
5. State Management
    19. Redux (or other state managers like Zustand, Jotai)
        Redux core concepts (actions, reducers, store)
        Redux Toolkit basics
        React-Redux hooks
        Redux Thunk
    20. Context API vs Redux
        Use-case comparison
        Performance and scaling
    21. React Query / SWR
        Data fetching and caching
        Stale-while-revalidate pattern


### Other Important Topics:
    22. React Virtualization.
        - Doesnot render stuff that is not in view-port
        - Very useful concept for rendering large List.

    23. Websocket using React
        - websocket Protocal and Event Life-cycle.
        - Built a simple chat application.

    23. React Design Principles and Coding Structure Habits. [https://www.youtube.com/playlist?list=PLApy4UwQM3Updrw-4mOXTwgsWar9bqk6i]
        1. single responsible Component.
        2. Compound components.


### NextJs Concepts [TODO]



### List of all Events and Actions that Triggers Component Refresh with React. [** VIMP **]

    1. Intentional / Expected Re-render Triggers:
        | # | Cause                        | Explanation                                                                                    |
        | - | ---------------------------- | ---------------------------------------------------------------------------------------------- |
        | 1 | **Parent Re-renders**        | When a parent re-renders, all its children re-render **by default**, unless they’re memoized.  |
        | 2 | **Props Change**             | If child receives new props (different by reference or value), it re-renders.                  |
        | 3 | **Context Value Change**     | If a child subscribes to a context and the value changes, it re-renders.                       |
        | 4 | **State Change (in child)**  | A component always re-renders when its own `useState`/`useReducer` state updates.              |
        | 5 | **Force Update**             | Calling a function like `forceUpdate()` (via ref or lifecycle methods) will force a re-render. |
        | 6 | **Key Change**               | Changing a component's `key` (especially in lists) unmounts and re-creates it = re-render.     |
        | 7 | **React Router Path Change** | If the route matches a new component, it unmounts/remounts = new render.                       |


    2. Unintentional or Avoidable Re-render Triggers [** This effects performance **]:
        | # | Cause                                 | Explanation                                                                                                  | Solution                                 |
        | - | ------------------------------------- | ------------------------------------------------------------------------------------------------------------ | ---------------------------------------- |
        | 1 | **New Object/Array Props Every Time** | Functions or objects created inside parent on every render cause child to re-render even if logic unchanged. | `useCallback`, `useMemo`                 |
        | 2 | **Anonymous Functions in JSX**        | Inline lambdas cause new function reference each time.                                                       | Move to `useCallback` or stable variable |
        | 3 | **Not Using `React.memo`**            | Components re-render even when props didn’t change.                                                          | Wrap pure components with `React.memo()` |
        | 4 | **Context Not Split**                 | One large context shared by many components causes all of them to re-render unnecessarily.                   | Split context or use selectors           |
        | 5 | **State Mutation**                    | Mutating state objects (instead of creating new ones) causes React to miss re-render.                        | Always treat state as immutable          |
        | 6 | **Key Conflicts in Lists**            | Using array index or non-unique keys can lead to unpredictable behavior and re-renders.                      | Use stable, unique keys                  |


    3. React Feature and Pattern Triggers: 

        | # | Feature                    | Re-render Behavior                                                         |
        | - | -------------------------- | -------------------------------------------------------------------------- |
        | 1 | **Strict Mode (Dev only)** | Triggers **double render** on mount to detect side effects.                |
        | 2 | **Suspense/Lazy**          | Mounting async-loaded children triggers re-renders as content resolves.    |
        | 3 | **Concurrent Mode**        | May interrupt and re-run rendering work, especially with transitions.      |
        | 4 | **Portals**                | Rendering outside DOM hierarchy but tied to React tree — same rules apply. |

        | # | Pattern                             | Re-render Impact                                     |
        | - | ----------------------------------- | ---------------------------------------------------- |
        | 1 | **useEffect that updates state**    | Triggers re-render after mount or dependency change. |
        | 2 | **Fetching data and setting state** | Common cause of async-triggered re-renders.          |
        | 3 | **WebSocket/EventListener**         | Emits events → sets state → re-renders.              |
        | 4 | **Refs don’t trigger re-renders**   | ✅ safe to mutate without re-render.                 |


    4. Visualization:

        <Parent>
        ├── <ChildA> ← props/state/context/ref change? Yes → re-render.
        ├── <ChildB> ← anonymous functions as prop? Yes → re-render.
        ├── <ChildC> ← pure component but parent re-rendered? Depends.





NOTES:

## Core Concepts:
    -- JSX -> syntax extension to Javascript.
    -- JSX compiles to React.createElement() under the hood. => Babel [converts JSX to JS so that browser can understand]
    -- eg: 
        const element = <h1 className="greet"> Hi </hi>  ===> Bable Converts this to ===> const element = React.createElement("h1", {className: 'greet'}, "hi);
    -- functional Component => stateful (we have hooks), takes props and render JSX.
    -- Class Component => legacy way, implements life-cycle methods [componentDidMount, shouldComponentUpdate], takes props keyword => this.props.name [If name is passed as prop to component].
        - Class Component do extends React.Component to get access to Class Life-cycle methods like: render(), componentDidMount() etc.
        - uses this.state and this.setState to access the states.
        eg: 
            class Counter extends React.Component {
                state = { count: 0 };

                increment = () => this.setState({ count: this.state.count + 1 });

                render() {
                    return <button onClick={this.increment}>Count: {this.state.count}</button>;
                }
            }

    -- Props => read-only input to any Component.
        1. Prop drilling => prop is passed down from parent to children through intermediate children where it is not used.
          Problem => this causes unnecessary re-renders for the intermediate children.
          Solution => use context API or Redux [App level state].
    -- React Life cycle:
        
        1. Class component Life Cycle Methods:
            1. Mounting Phase  => constructor(), render(), componentDidMount()
            2. Update Phase  => shouldComponentUpdate(), componentDidUpdate()
            3. UnMounting Phase => componentWillUnMount()

        2. Function Component Life-Cycle Method with Hooks:
            1. Mounting Phase  => useEffect(()=>{}, [])  => Empty Dependency array in useEffect runs the content only when Component mounts.
            2. Updating Phase => useEffect(()=>{}, [state])  => If the state changes => useEffect Runs the the content and re-render the content.
            3. UnMounting Phase  => useEffect(()=>{fn() return () => {...} },[])  => return anonymous function from useEffect will run to Cleanup timers or Event listener to clean up when the component unMounts.

    NOTE:
        stale Closure problem with Hooks and Functional Component:
            - React functional component updates on every re-render => and If we have some logic written inside useEffect, useCallback => we must provide this method with the update state value.
            Problem :
                If we dont, these functions are executed only with the first state's value, as later on these functions are not aware that the state has changed. 
                i.e the closure [functional component function] for the above functions have expired => It is running with expired state value instead of latest one. 
            - solution:
                - how to fix it ? ==> pass the state as a dependency array to this methods.
                - This tells React to create a new function reference or run the function again with the latest value of state.
        - remember this:
            | Pattern                                                        | Why it's safe                          |
            | -------------------------------------------------------------- | -------------------------------------- |
            | `setState(prev => newValue)`                                   | Uses latest value from React           |
            | Declare functions inside `useEffect` with correct dependencies | Ensures closure always captures latest |
            | Memoize functions with `useCallback` and correct deps          | Avoids outdated references             |
    
    -- Batching of States:
        - React batches multiple state updates into 1 render ==> Optimises performance.
        - eg:   
                const handleClick = () => {
                    setCount(count + 1);
                    setName("New Name");
                };
            => Only 1 render is triggered where count and name both are updated.
    NOTE:
        -- From React 18 onwards, Multiple State Updates inside setTimeout, Promises are also batched.
        -- setState Doesnot immediatly updates the state => It rather schedule a re-render with the latest state value. => setState is not async, It deferred and batched for next render cycle.
    
    -- Functional Update:
        setState(count => count + 1);  //preferred way to update state if it depends on previous state.
    -- Synthetic Event:
        React wraps browser native events into SyntheticEvent Obj for cross-browser consistency and performance optimization.
            - eg: handleChange = (evt) => {console.log(evt.nativeEvent)} ==> this prints the native browser event.
            - SyntheticEvent mimics the native event, but with a consistent interface.
    -- Binding and 'this' Context in Event handlers:
        - In old class component you have 2 ways to bind events:
            1. use Arrow Method:
                const handleClick = () => console.log(this);  //this point to the class.
            2. use bind method:
                constructor() {
                    super();
                    this.handleClick = this.handleClick.bind(this);
                }  

                function handleClick() {
                    console.log(this);   // with the above bind, now this points to current class instance ==> without above bind, it will be undefined.
                }
    -- Functional Component `this` scope:
        No Need to worry, everything is properly scope here.
    -- Rendering Arrays:
        -> use .map().
        -> must use an unique Id for key attribute in the elemets. ==> helps React to identify which item chnaged during re-render.
        -> index as a key is acceptable only:
            1. If the list is static.
            2. we are adding, removing or updating element in the list.
    
    ## Why key prop needed ?
        -> React uses a Reconciliation algorithm (diffing) to decide wether to:
            1. reuse the existing DOM element.
            2. Destroy and re-create the DOM element.
        -> If key is not proper/uique ==> React updates are difficult to predict.


## React Hooks Important Notes:
    -- useState's Lazy initialization:
        const [expensiveValue, setExpensiveValue] = useState(() => computeHeavyValue());
        -> use this when you have to initialize state that involves some heavy computation.
        -> () => fn() make sure it runs only once, else it will run on every re-render.
        -> usecase: Initializing state is expensive (sorting, filtering, parsing, etc.)
    -- states with Object/Arrays:
        eg: const [from, setForm] = useState({name: "", email: ""});
        -> In class components, the state Object will get merge automatically.
        -> In Functional Component, the state has to merge manually i.e setForm(prev => {...prev, name: 'test'});
    -- useEffect, uses "shallow comparison" for tracking changes in dependencies array.
        -> avoid this:
            useEffect(()=>{...}, [obj])  // here obj will get new refernce on every re-render.
        -> follow this:
            const memoObj = useMemo(()=> obj, []);
            useEffect(()=>{...}, [memoObj]); //memoObj reference will not change unless the object is changed.
        -> when and why the cleanup function will run ?
            1. before Mounting  => to prevent memory leaks.
            2. before re-runnning th effect => to clean up outdated logic.
        -> Traps:
            1. missed Dependency.
            2. updating the state inside useEffect which is in dependency. ==> infinite loop
            eg: 
                useEffect(()=> {
                    setCount(prev => prev +1);
                },[count]);
    -- useRef: => returns a mutable ref Obj => {current: initialVal}
        -> 2 useCases:
            1. To Access Dom Elements.
            2. Storing mutable values that is preserved throughout the re-render and doesnot trigger re-render on updates.
    --  useContext:
        -> Provider:
           1. const ContextProvider = React.createContext(initialVal);  //defaultVal.
           2. Wrap the parent with the context Provider with the value.
                <ContextProvider.provider value="new-val">
                    {children}
                </ContextProvider>
            3. In the child where we need that state:
                const val = useContext(ContextProvider);
        -> If a parent has multiple children, and a prop is drill from parent to a child through intermediate children i.e prop drilling.
            => causes un-necessary re-renders.
            => useContext saves us from that.
        -> When context is updated => all children with useContext will be re-rendered. => To optimise memorize the context val.
    -- useMemo: memorize computed values.
       useCallback: memorize function instances.
       -> useMemo useCase:
            1. when doing expensive calculations.
            2. Prevent re-render for child due to new obj/arr/fun creation.
        -> useCallback useCase:
            1. when fn is passed to child as prop.
            2. It works only if the child is memorised, and useCallback wont generate a new reference on re-render. 
        -> Pitfall:
            1. No use of using useCallback alone, If the fucntion is not passed inside a memorized Child [React.memo where we force the child to shallow compare the props]
            2. If a function is used as dependency in useEffect, there also useCallback saves to runs the useEffect content on every re-render.
            3. If the function is event-driven only in the same file, then no need for useCallback.
            4. anonymous function for event handler for child component.
                <MemoizedComponent onClick={() => doSomething()} /> // always a new function, will re-render
                -> This re-reneders the Component on every re-render.
                -> fix is: add a useCallback for the click handler. -> as the func is going as a prop to child component.
    --  Custom Hook -> Encapsulate re-usable logic.
        -> Common Pattern of Custom hook:
            1. fetch Hook
                function useFetch(url) {
                    const [data, setData] = useState(null);
                    const [loading, setLoading] = useState(true);

                    useEffect(() => {
                        let ignore = false;

                        fetch(url)
                        .then(res => res.json())
                        .then(json => {
                            if (!ignore) setData(json);
                        })
                        .finally(() => setLoading(false));

                        return () => { ignore = true; };
                    }, [url]);

                    return { data, loading };
                }

            2. Local Storage Hook:
                function useLocalStorage(key, initialValue) {
                    const [value, setValue] = useState(() => }{
                        const json = localStorage.getItem(key);
                        return json ? JSON.parse(json) : initialValue;
                    );

                    useEffect(() => {
                        localStorage.setItem(key, JSON.stringify(value));
                    }, [key, value]);

                    return [value, setValue];
                }

        NOTE:
            1. Always define hooks at the top level -< Out of any loop or condition.
            2. prefix with use, Dont return JSX just logic.  

## React Advance concepts:
    -- VDOM -> Virtual DOM is a light weight in memory representation of the actual DOM.
    -- Reconciliation ==> uses to update the DOM when component's stat or porp changes.
        Process:
            1. React creates a new DOM tree.
            2. Diffs it against he previous tree.
            3. Figures out the min no. of updates to the actual DOM.
    -- Why use Key prop in List render:
        1. Track items across re-render.
        2. Avoid re-rendering of the whole list.
        3. Optimise insertion, deletion and re-rendering.
    NOTE: use index as key in list only if the list is static, Else go with some stable unique Id.
    -- Optimizing Re-renders:
        -> Problem: Frequent re-render impacts performance of the whole application ==> bad UI experience.
        -> Why re-renders ?
            1. If state changes.
            2. If prop changes.
            3. If parent re-render then all it's root nodes will re-render event if it's prop doesn't change.
        -> Solution:
           *1. React.memo() 
                => If parent re-renders and Prop doesnot change => React.memo prevents the child from re-rendering again.
                => use shallow Comparison.
            2. useMemo()
                => hook that saves costly operations and values that dependes upon state/props.
                => saves the value through re-renders.
            3. useCallback()
                => hook that saves the ref of a function through all re-renders.
                => If a function is passed to child component. When Parent re-render, a new refernce will be created. => even if the child is memorized still it will re-render.
                => useCallback deals with the above issue.
            4. Key usage in List.
                => Optimise rendering Items in a list type of data view.
           *5. Splitting Component: 
                => Break large component into smaller one => Only smaller one will re-render instead of the Whole component.
                => Improved performance.
            6. Lazy Loading:
                => React provides React.lazy to lazy load a non-critical Component.
                => While the componets loads => <Suspense> handles the fallback screen.
                
                    const Lazy Component = React.lazy(()=> import('./component/file-name'));
                    
                    <Suspense fallback={<div> Loading.. </div> }>
                        <LazyComponent ...{props} />
                    </Suspense>
    -- Where to monitor Performance ?
        1. React devTools Profiler.
            => highlights: which components are re-rendered unnecessarily.
            => Measure Performance.
    -- Error Boundaries: 
        -> Captures JS Errors in the rendering phase of their child component tree.
        -> Only applicable and implemented with Class Component => using the component Life-cycle event: ComponentDidCatch [as of React 18]
        eg:
            class ErrorBoundary extends React.Component {
                constructor(props) {
                    super(props);
                    this.state = {hasError: false};
                }

                // update the state ==> shows fallback UI
                static getDerivedStateFromError(error) {
                    return {hasError: true};
                }

                //Logs the Error...
                componentDidCatch(error, info) {
                    console.error('Error Caught:', error, info);
                }

                render() {
                    if(this.state.hasError) {
                        return <h2>Fallback Error Message: Something went Wrong !!</h2>
                    }
                }

                return this.props.children;
            }

        useCase:
            <ErrorBoundary>
                <Mycomponent />  --> catches Error if any....
            </ErrorBoundary>

        -> what Error Boundary catches ?
            1. Errors during Rendering.
            2. Life-cycle methods.
            3. React Hooks.
        -> What Error Boundary will miss ?
            1. Event Handlers -> use try/catch.
            2. Async errors -> setTimeout, fetch
            3. SSR issues.
        -> NOTE: Not possible with Functional Component using hooks yet.
        -> Optimised Suggestion:
            -> use one global Error Boundary at Parent Level of the Application.
            -> use smaller error boundary in high risk component, with logging.
    -- Controlled Component => react track the input changes using useState hook.
       UnControlled Compoennt => Input changes are tracked using ref to the input node. => usecae: for simple form and critical components.
    -- File input types are uncontrolled  => reason: For security reasons, File value cannot be set by js, they are accessed using ref.
    eg: 
        const handleUpload = () => {
            const files = fileRef.current.files[0];
            const fileMultiple = fileRef1.current.files;
            Array.from(fileMultiple).forEach(file => {
                console.log(file.name);
            })
        }

        <input type="file" ref={fileRef} />
        <input type="file" ref={fileRef1} multiple />
    NOTE: Why not useState ?
        -> Browsers don’t allow scripts to set file paths, as that would pose a huge security risk (apps could upload local files without permission).
            That’s why file inputs are read-only from JS, and React recommends you treat them as uncontrolled inputs.
    -- ref usecases:   
        1. want to access the DOM directly.
        2. Performance oriented for reducing re-renders in component.
    -- React Router:
        -> Standard way for Routing in React Application.
        -> Core Concepts:
            1. BrowserRouter   => Wraps around the App component, enable Routing with HTML5 history API.
            2. Routes          => Holds all Route components.
            3. Route           => Defines url path and Element to render.
            4. Link/NavLink    => Naviagtes to a page without page reload.
                eg: <NavLink to="/home"> HOME </NavLink>

            5. useNaviagte     => Programmatically naviagte.
                const naviagte = useNaviagte();
                navigate('/home');
                naviagte(-1); //go back
                    OR
                <Route path="/" element={<Naviagte to="/login" replace />}>
                NOTE:
                    replace keyword will remove the entires from the url naviagte stack.
            6. useParams       => hook to extract path param from url.
            7. useLocation     => access current URL Info.
            8. Outlet          => Placehold for nested Routes.

        -> eg for protective Routes/Routes Guarding:
            const Layout = () => {
                const isAuth = isAuthenticated(); //the service to verify Authentication...
                return isAuth ? <Outlet/> : <Route path='/user-Auth' element={<Naviate to='/user-Auth' }
            };

            <Routes>
                <Route element={<Layout />}>
                    <Route path='/' element={<Naviagte to='/home' replace>} />
                    <Route path='/dashboard' element={<Dashboard />} />
                </Route>
            </Routes>

            -> Above code:
                1. As the Route starts => Layout is called by default for every re-direction.
                2. If the auth is success => <Outlet /> will render the nested route under the current Route url.
                3. If auth fails ==> It will re-direct to user-Auth and also clears out the navigation history [using replace keyword in <Naviagte>]
    -- HOC:
        -> Takes a component as input and return a new component with updated state or props.
        -> structure of HOC:
            const hocName = (WrappedComponent) => {
                return ({isLoading, ...props}) => {
                    // 1.Above If you want child to expect additional prop -> you can define like isLoading.
                    // 2.props refer to the actual props the child is expecting...

                    // 3.Here you can use all react hooks, and logic..

                    return isLaoding ? 
                      <div>Loading....</div>
                        : <WrappedComponent {...props} />;  
                };
            }
        -> useCase:
            1. Authentication/Role guards.
            2. Analytics Logging.
            3. Theme injection.
            4. Error tracking.
            5. Feature flags
        -> Hooks used for Logic seperation and returns data/logic  =>   HOC is good for UI seperation, returns a component.
    -- Render Props:
        -> A pattern of sharing logic between components by passing a function as prop that returns React Elements. ==> Legacy Way
        -> An Alteranative to HOC => share logic between components.
        -> Basically function is passed as a prop to the component.
        eg: 
            const DataProvider = ({ fetchUrl, children }) => {
                const [data, setData] = useState(null);

                useEffect(() => {
                    fetch(fetchUrl).then((res) => res.json()).then(setData);
                }, [fetchUrl]);

                return children(data);
            };

            // Usage:
            <DataProvider
                fetchUrl="/api/user"
            >
                {(user) => (user ? <UserCard {...user} /> : <p>Loading...</p>)}
            </DataProvider>
        NOTE: here render is passed as function that handles the UI JSX to show i.e either UserCard component or Loading...
        


## React State Management:
          

  
 

