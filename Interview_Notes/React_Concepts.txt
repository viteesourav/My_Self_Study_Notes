** Important React Concepts **

1. Core Concepts -> Fundamentals.
    1. JSX and Rendering Basics
        JSX syntax and expressions
        Rendering elements & components
        Babel and transpilation
    2. Components (Functional & Class)
        Functional vs Class components
        Props and Prop Drilling
        Component lifecycle (both types)
    3. State and setState
        State management in function vs class components
        Batching of state updates
        setState behavior (async vs sync)
        Functional updates
    4. Event Handling
        Synthetic events in React
        Binding and context in event handlers
    5. Conditional Rendering and Lists
        Rendering lists and keys
        Short-circuiting, ternary, and IIFE patterns
2. React Hooks 
    6. useState
        Initial state, lazy initialization
        Common patterns and pitfalls
    7. useEffect
        Dependency array
        Cleanup function
        Execution order (after paint)
        Common interview traps
    8. useRef
        DOM reference
        Mutable value storage without re-render
    9. useContext
        Creating and using Context
        Avoiding prop drilling
        Context performance pitfalls
    10. useMemo & useCallback
        Memoization and performance optimization
        Common misuse and proper use cases
    11. Custom Hooks
        Structure and design patterns
        Sharing logic across components
3. ADvance Topics:
    12. Reconciliation and Virtual DOM
        How React compares and updates DOM
        Keys in diffing algorithm
    13. Rendering Optimization
        Memoization (React.memo, useMemo)
        Avoiding unnecessary re-renders
        Profiling performance
    14. Error Boundaries
        Handling errors in class components
        Why no error boundaries in function components
    15. Controlled vs Uncontrolled Components
        Forms in React
        Refs vs State
    16. React Router (v6+)
        Routing, navigation, params, nested routes
        Route guarding and redirection
    17. Higher Order Components (HOC)
        What they are
        Use cases and patterns
    18. Render Props
        Pattern explanation
        Real use cases
5. State Management
    19. Redux (or other state managers like Zustand, Jotai)
        Redux core concepts (actions, reducers, store)
        Redux Toolkit basics
        React-Redux hooks
        Redux Thunk
    20. Context API vs Redux
        Use-case comparison
        Performance and scaling
    21. React Query / SWR
        Data fetching and caching
        Stale-while-revalidate pattern


### Other Important Topics:
    22. React Virtualization.
        - Doesnot render stuff that is not in view-port
        - Very useful concept for rendering large List.

    23. Websocket using React
        - websocket Protocal and Event Life-cycle.
        - Built a simple chat application.

    23. React Design Principles and Coding Structure Habits. [https://www.youtube.com/playlist?list=PLApy4UwQM3Updrw-4mOXTwgsWar9bqk6i]
        1. single responsible Component.
        2. Compound components. etc.


### NextJs Concepts [TODO]
    -> SSR and CSR and SPR ==> TODO.



### List of all Events and Actions that Triggers Component Refresh with React. [** VIMP **]

    1. Intentional / Expected Re-render Triggers:
        | # | Cause                        | Explanation                                                                                    |
        | - | ---------------------------- | ---------------------------------------------------------------------------------------------- |
        | 1 | **Parent Re-renders**        | When a parent re-renders, all its children re-render **by default**, unless they’re memoized.  |
        | 2 | **Props Change**             | If child receives new props (different by reference or value), it re-renders.                  |
        | 3 | **Context Value Change**     | If a child subscribes to a context and the value changes, it re-renders.                       |
        | 4 | **State Change (in child)**  | A component always re-renders when its own `useState`/`useReducer` state updates.              |
        | 5 | **Force Update**             | Calling a function like `forceUpdate()` (via ref or lifecycle methods) will force a re-render. |
        | 6 | **Key Change**               | Changing a component's `key` (especially in lists) unmounts and re-creates it = re-render.     |
        | 7 | **React Router Path Change** | If the route matches a new component, it unmounts/remounts = new render.                       |


    2. Unintentional or Avoidable Re-render Triggers [** This effects performance **]:
        | # | Cause                                 | Explanation                                                                                                  | Solution                                 |
        | - | ------------------------------------- | ------------------------------------------------------------------------------------------------------------ | ---------------------------------------- |
        | 1 | **New Object/Array Props Every Time** | Functions or objects created inside parent on every render cause child to re-render even if logic unchanged. | `useCallback`, `useMemo`                 |
        | 2 | **Anonymous Functions in JSX**        | Inline lambdas cause new function reference each time.                                                       | Move to `useCallback` or stable variable |
        | 3 | **Not Using `React.memo`**            | Components re-render even when props didn’t change.                                                          | Wrap pure components with `React.memo()` |
        | 4 | **Context Not Split**                 | One large context shared by many components causes all of them to re-render unnecessarily.                   | Split context or use selectors           |
        | 5 | **State Mutation**                    | Mutating state objects (instead of creating new ones) causes React to miss re-render.                        | Always treat state as immutable          |
        | 6 | **Key Conflicts in Lists**            | Using array index or non-unique keys can lead to unpredictable behavior and re-renders.                      | Use stable, unique keys                  |


    3. React Feature and Pattern Triggers: 

        | # | Feature                    | Re-render Behavior                                                         |
        | - | -------------------------- | -------------------------------------------------------------------------- |
        | 1 | **Strict Mode (Dev only)** | Triggers **double render** on mount to detect side effects.                |
        | 2 | **Suspense/Lazy**          | Mounting async-loaded children triggers re-renders as content resolves.    |
        | 3 | **Concurrent Mode**        | May interrupt and re-run rendering work, especially with transitions.      |
        | 4 | **Portals**                | Rendering outside DOM hierarchy but tied to React tree — same rules apply. |

        | # | Pattern                             | Re-render Impact                                     |
        | - | ----------------------------------- | ---------------------------------------------------- |
        | 1 | **useEffect that updates state**    | Triggers re-render after mount or dependency change. |
        | 2 | **Fetching data and setting state** | Common cause of async-triggered re-renders.          |
        | 3 | **WebSocket/EventListener**         | Emits events → sets state → re-renders.              |
        | 4 | **Refs don’t trigger re-renders**   | ✅ safe to mutate without re-render.                 |


    4. Visualization:

        <Parent>
        ├── <ChildA> ← props/state/context/ref change? Yes → re-render.
        ├── <ChildB> ← anonymous functions as prop? Yes → re-render.
        ├── <ChildC> ← pure component but parent re-rendered? Depends.



## Core Concepts:
    -- JSX -> syntax extension to Javascript.
    -- JSX compiles to React.createElement() under the hood. => Babel [converts JSX to JS so that browser can understand]
    -- eg: 
        const element = <h1 className="greet"> Hi </hi>  ===> Bable Converts this to ===> const element = React.createElement("h1", {className: 'greet'}, "hi);
    -- functional Component => stateful (we have hooks), takes props and render JSX.
    -- Class Component => legacy way, implements life-cycle methods [componentDidMount, shouldComponentUpdate], takes props keyword => this.props.name [If name is passed as prop to component].
        - Class Component do extends React.Component to get access to Class Life-cycle methods like: render(), componentDidMount() etc.
        - uses this.state and this.setState to access the states.
        eg: 
            class Counter extends React.Component {
                state = { count: 0 };

                increment = () => this.setState({ count: this.state.count + 1 });

                render() {
                    return <button onClick={this.increment}>Count: {this.state.count}</button>;
                }
            }

    -- Props => read-only input to any Component.
        1. Prop drilling => prop is passed down from parent to children through intermediate children where it is not used.
          Problem => this causes unnecessary re-renders for the intermediate children.
          Solution => use context API or Redux [App level state].
    -- React Life cycle:
        
        1. Class component Life Cycle Methods:
            1. Mounting Phase  => constructor(), render(), componentDidMount()
            2. Update Phase  => shouldComponentUpdate(), componentDidUpdate()
            3. UnMounting Phase => componentWillUnMount()

        2. Function Component Life-Cycle Method with Hooks:
            1. Mounting Phase  => useEffect(()=>{}, [])  => Empty Dependency array in useEffect runs the content only when Component mounts.
            2. Updating Phase => useEffect(()=>{}, [state])  => If the state changes => useEffect Runs the the content and re-render the content.
            3. UnMounting Phase  => useEffect(()=>{fn() return () => {...} },[])  => return anonymous function from useEffect will run to Cleanup timers or Event listener to clean up when the component unMounts.

    NOTE:
        stale Closure problem with Hooks and Functional Component:
            - React functional component updates on every re-render => and If we have some logic written inside useEffect, useCallback => we must provide this method with the update state value.
            Problem :
                If we dont, these functions are executed only with the first state's value, as later on these functions are not aware that the state has changed. 
                i.e the closure [functional component function] for the above functions have expired => It is running with expired state value instead of latest one. 
            - solution:
                - how to fix it ? ==> pass the state as a dependency array to this methods.
                - This tells React to create a new function reference or run the function again with the latest value of state.
        - remember this:
            | Pattern                                                        | Why it's safe                          |
            | -------------------------------------------------------------- | -------------------------------------- |
            | `setState(prev => newValue)`                                   | Uses latest value from React           |
            | Declare functions inside `useEffect` with correct dependencies | Ensures closure always captures latest |
            | Memoize functions with `useCallback` and correct deps          | Avoids outdated references             |
    
    -- Batching of States:
        - React batches multiple state updates into 1 render ==> Optimises performance.
        - eg:   
                const handleClick = () => {
                    setCount(count + 1);
                    setName("New Name");
                };
            => Only 1 render is triggered where count and name both are updated.
    NOTE:
        -- From React 18 onwards, Multiple State Updates inside setTimeout, Promises are also batched.
        -- setState Doesnot immediatly updates the state => It rather schedule a re-render with the latest state value. => setState is not async, It deferred and batched for next render cycle.
    
    -- Functional Update:
        setState(count => count + 1);  //preferred way to update state if it depends on previous state.
    -- Synthetic Event:
        React wraps browser native events into SyntheticEvent Obj for cross-browser consistency and performance optimization.
            - eg: handleChange = (evt) => {console.log(evt.nativeEvent)} ==> this prints the native browser event.
            - SyntheticEvent mimics the native event, but with a consistent interface.
    -- Binding and 'this' Context in Event handlers:
        - In old class component you have 2 ways to bind events:
            1. use Arrow Method:
                const handleClick = () => console.log(this);  //this point to the class.
            2. use bind method:
                constructor() {
                    super();
                    this.handleClick = this.handleClick.bind(this);
                }  

                function handleClick() {
                    console.log(this);   // with the above bind, now this points to current class instance ==> without above bind, it will be undefined.
                }
    -- Functional Component `this` scope:
        No Need to worry, everything is properly scope here.
    -- Rendering Arrays:
        -> use .map().
        -> must use an unique Id for key attribute in the elemets. ==> helps React to identify which item chnaged during re-render.
        -> index as a key is acceptable only:
            1. If the list is static.
            2. we are adding, removing or updating element in the list.
    
    ## Why key prop needed ?
        -> React uses a Reconciliation algorithm (diffing) to decide wether to:
            1. reuse the existing DOM element.
            2. Destroy and re-create the DOM element.
        -> If key is not proper/uique ==> React updates are difficult to predict.


## React Hooks Important Notes:
    -- useState's Lazy initialization:
        const [expensiveValue, setExpensiveValue] = useState(() => computeHeavyValue());
        -> use this when you have to initialize state that involves some heavy computation.
        -> () => fn() make sure it runs only once, else it will run on every re-render.
        -> usecase: Initializing state is expensive (sorting, filtering, parsing, etc.)
    -- states with Object/Arrays:
        eg: const [from, setForm] = useState({name: "", email: ""});
        -> In class components, the state Object will get merge automatically.
        -> In Functional Component, the state has to merge manually i.e setForm(prev => {...prev, name: 'test'});
    NOTE:
        -> Is useState synchronous or asynchronous ?
            -- "useState updates are asynchronous in nature — the state doesn’t change immediately. 
            -- Instead, React batches multiple updates and re-renders later. 
            -- But the setState call itself is synchronous — it schedules the update, React applies it asynchronously." 
    -- useEffect, uses "shallow comparison" for tracking changes in dependencies array.
        -> avoid this:
            useEffect(()=>{...}, [obj])  // here obj will get new refernce on every re-render.
        -> follow this:
            const memoObj = useMemo(()=> obj, []);
            useEffect(()=>{...}, [memoObj]); //memoObj reference will not change unless the object is changed.
        -> when and why the cleanup function will run ?
            1. before Mounting  => to prevent memory leaks.
            2. before re-runnning th effect => to clean up outdated logic.
        -> Traps:
            1. missed Dependency.
            2. updating the state inside useEffect which is in dependency. ==> infinite loop
            eg: 
                useEffect(()=> {
                    setCount(prev => prev +1);
                },[count]);
    -- useRef: => returns a mutable ref Obj => {current: initialVal}
        -> 2 useCases:
            1. To Access Dom Elements.
            2. Storing mutable values that is preserved throughout the re-render and doesnot trigger re-render on updates.
    --  useContext:
        -> Provider:
           1. const ContextProvider = React.createContext(initialVal);  //defaultVal.
           2. Wrap the parent with the context Provider with the value.
                <ContextProvider.provider value="new-val">
                    {children}
                </ContextProvider>
            3. In the child where we need that state:
                const val = useContext(ContextProvider);
        -> If a parent has multiple children, and a prop is drill from parent to a child through intermediate children i.e prop drilling.
            => causes un-necessary re-renders.
            => useContext saves us from that.
        -> When context is updated => all children with useContext will be re-rendered. => To optimise memorize the context val.
    -- useMemo: memorize computed values.
       useCallback: memorize function instances.
       -> useMemo useCase:
            1. when doing expensive calculations.
            2. Prevent re-render for child due to new obj/arr/fun creation.
        -> useCallback useCase:
            1. when fn is passed to child as prop.
            2. It works only if the child is memorised, and useCallback wont generate a new reference on re-render. 
        -> Pitfall:
            1. No use of using useCallback alone, If the fucntion is not passed inside a memorized Child [React.memo where we force the child to shallow compare the props]
            2. If a function is used as dependency in useEffect, there also useCallback saves to runs the useEffect content on every re-render.
            3. If the function is event-driven only in the same file, then no need for useCallback.
            4. anonymous function for event handler for child component.
                <MemoizedComponent onClick={() => doSomething()} /> // always a new function, will re-render
                -> This re-reneders the Component on every re-render.
                -> fix is: add a useCallback for the click handler. -> as the func is going as a prop to child component.
    --  Custom Hook -> Encapsulate re-usable logic.
        -> Common Pattern of Custom hook:
            1. fetch Hook
                function useFetch(url) {
                    const [data, setData] = useState(null);
                    const [loading, setLoading] = useState(true);

                    useEffect(() => {
                        let ignore = false;

                        fetch(url)
                        .then(res => res.json())
                        .then(json => {
                            if (!ignore) setData(json);
                        })
                        .finally(() => setLoading(false));

                        return () => { ignore = true; };
                    }, [url]);

                    return { data, loading };
                }

            2. Local Storage Hook:
                function useLocalStorage(key, initialValue) {
                    const [value, setValue] = useState(() => }{
                        const json = localStorage.getItem(key);
                        return json ? JSON.parse(json) : initialValue;
                    );

                    useEffect(() => {
                        localStorage.setItem(key, JSON.stringify(value));
                    }, [key, value]);

                    return [value, setValue];
                }

        NOTE:
            1. Always define hooks at the top level -< Out of any loop or condition.
            2. prefix with use, Dont return JSX just logic.  


## React Advance concepts:
    -- VDOM -> Virtual DOM is a light weight in memory representation of the actual DOM.
    -- Reconciliation ==> uses to update the DOM when component's stat or porp changes.
        Process:
            1. React creates a new DOM tree.
            2. Diffs it against he previous tree.
            3. Figures out the min no. of updates to the actual DOM.
    -- Why use Key prop in List render:
        1. Track items across re-render.
        2. Avoid re-rendering of the whole list.
        3. Optimise insertion, deletion and re-rendering.
    NOTE: use index as key in list only if the list is static, Else go with some stable unique Id.
    -- Optimizing Re-renders:
        -> Problem: Frequent re-render impacts performance of the whole application ==> bad UI experience.
        -> Why re-renders ?
            1. If state changes.
            2. If prop changes.
            3. If parent re-render then all it's root nodes will re-render event if it's prop doesn't change.
        -> Solution:
           *1. React.memo() 
                => If parent re-renders and Prop doesnot change => React.memo prevents the child from re-rendering again.
                => use shallow Comparison.
            2. useMemo()
                => hook that saves costly operations and values that dependes upon state/props.
                => saves the value through re-renders.
            3. useCallback()
                => hook that saves the ref of a function through all re-renders.
                => If a function is passed to child component. When Parent re-render, a new refernce will be created. => even if the child is memorized still it will re-render.
                => useCallback deals with the above issue.
            4. Key usage in List.
                => Optimise rendering Items in a list type of data view.
           *5. Splitting Component: 
                => Break large component into smaller one => Only smaller one will re-render instead of the Whole component.
                => Improved performance.
            6. Lazy Loading:
                => React provides React.lazy to lazy load a non-critical Component.
                => While the componets loads => <Suspense> handles the fallback screen.
                
                    const Lazy Component = React.lazy(()=> import('./component/file-name'));
                    
                    <Suspense fallback={<div> Loading.. </div> }>
                        <LazyComponent ...{props} />
                    </Suspense>
    -- Where to monitor Performance ?
        1. React devTools Profiler.
            => highlights: which components are re-rendered unnecessarily.
            => Measure Performance.
    -- Error Boundaries: 
        -> Captures JS Errors in the rendering phase of their child component tree.
        -> Only applicable and implemented with Class Component => using the component Life-cycle event: ComponentDidCatch [as of React 18]
        eg:
            class ErrorBoundary extends React.Component {
                constructor(props) {
                    super(props);
                    this.state = {hasError: false};
                }

                // update the state ==> shows fallback UI
                static getDerivedStateFromError(error) {
                    return {hasError: true};
                }

                //Logs the Error...
                componentDidCatch(error, info) {
                    console.error('Error Caught:', error, info);
                }

                render() {
                    if(this.state.hasError) {
                        return <h2>Fallback Error Message: Something went Wrong !!</h2>
                    }
                }

                return this.props.children;
            }

        useCase:
            <ErrorBoundary>
                <Mycomponent />  --> catches Error if any....
            </ErrorBoundary>

        -> what Error Boundary catches ?
            1. Errors during Rendering.
            2. Life-cycle methods.
            3. React Hooks.
        -> What Error Boundary will miss ?
            1. Event Handlers -> use try/catch.
            2. Async errors -> setTimeout, fetch
            3. SSR issues.
        -> NOTE: Not possible with Functional Component using hooks yet.
        -> Optimised Suggestion:
            -> use one global Error Boundary at Parent Level of the Application.
            -> use smaller error boundary in high risk component, with logging.
    -- Controlled Component => react track the input changes using useState hook.
       UnControlled Compoennt => Input changes are tracked using ref to the input node. => usecae: for simple form and critical components.
    -- File input types are uncontrolled  => reason: For security reasons, File value cannot be set by js, they are accessed using ref.
    eg: 
        const handleUpload = () => {
            const files = fileRef.current.files[0];
            const fileMultiple = fileRef1.current.files;
            Array.from(fileMultiple).forEach(file => {
                console.log(file.name);
            })
        }

        <input type="file" ref={fileRef} />
        <input type="file" ref={fileRef1} multiple />
    NOTE: Why not useState ?
        -> Browsers don’t allow scripts to set file paths, as that would pose a huge security risk (apps could upload local files without permission).
            That’s why file inputs are read-only from JS, and React recommends you treat them as uncontrolled inputs.
    -- ref usecases:   
        1. want to access the DOM directly.
        2. Performance oriented for reducing re-renders in component.
    
    -- React Router:
        -> Standard way for Routing in React Application.
        -> Core Concepts:
            1. BrowserRouter   => Wraps around the App component, enable Routing with HTML5 history API.
            2. Routes          => Holds all Route components.
            3. Route           => Defines url path and Element to render.
            4. Link/NavLink    => Naviagtes to a page without page reload.
                eg: <NavLink to="/home"> HOME </NavLink>

            5. useNaviagte     => Programmatically naviagte.
                const naviagte = useNaviagte();
                navigate('/home');
                naviagte(-1); //go back
                    OR
                <Route path="/" element={<Naviagte to="/login" replace />}>
                NOTE:
                    replace keyword will remove the entires from the url naviagte stack.
            6. useParams       => hook to extract path param from url.  [** dynamic Routing **]
            7. useLocation     => access current URL Info.
            8. Outlet          => Placehold for nested Routes.

        -> using Routes Like:  <Route path="/user/:id" element={<User />} />  ==> Called Dynamic Routing [to access the path param use useParams hook.]
        -> eg for protective Routes/Routes Guarding:
            const Layout = () => {
                const isAuth = isAuthenticated(); //the service to verify Authentication...
                return isAuth ? <Outlet/> : <Route path='/user-Auth' element={<Naviate to='/user-Auth' }
            };

            <Routes>
                <Route element={<Layout />}>
                    <Route path='/' element={<Naviagte to='/home' replace>} />
                    <Route path='/dashboard' element={<Dashboard />} />
                </Route>
            </Routes>

            -> Above code:
                1. As the Route starts => Layout is called by default for every re-direction.
                2. If the auth is success => <Outlet /> will render the nested route under the current Route url.
                3. If auth fails ==> It will re-direct to user-Auth and also clears out the navigation history [using replace keyword in <Naviagte>]

        [Important NOTE]
            -> Problem: If we use react-router-dom to manage routes => In production [either render.vercel], If you at a page and you try reloading it => Gives 404 Error.
            -> Why ?
                -> React is a Single Page Application [SPA], ==> Their is only 1 HTML File [index.html] that is served to backend.
                -> In first render => index.html file paints the screen => then react-router-dom takes over and handles all the Navigation.
                -> When reload page => The browser trys to fetch content for that route => But server doesn't know what page to sent => Thus it shows 404. 
            -> Why not in local ?
                -> In local, vite's dev server by default serves the index.html by default. 
                -> In prod the above magic is gone.
            -> Solution:
                -> It's a issue from the Front-end side ==> Since React Serves the whole content on a single page i.e index.html [SPA]
                -> In render => Add a rewrite for the route /* => index.html [For any unknown routes it will fallback to index.html] -> once index.html comes, router-dom will take care of the navogation.
                -> In vercel => You need to add a vercel.json config file to handle SPA
                    {
                        "rewrites": [
                            { "source": "/(.*)", "destination": "/index.html" }
                        ]
                    }

    -- HOC:
        -> Takes a component as input and return a new component with updated state or props.
        -> structure of HOC:
            const hocName = (WrappedComponent) => {
                return ({isLoading, ...props}) => {
                    // 1.Above If you want child to expect additional prop -> you can define like isLoading.
                    // 2.props refer to the actual props the child is expecting...

                    // 3.Here you can use all react hooks, and logic..

                    return isLaoding ? 
                      <div>Loading....</div>
                        : <WrappedComponent {...props} />;  
                };
            }
        -> useCase:
            1. Authentication/Role guards.
            2. Analytics Logging.
            3. Theme injection.
            4. Error tracking.
            5. Feature flags
        -> Hooks used for Logic seperation and returns data/logic  =>   HOC is good for UI seperation, returns a component.
    -- Render Props:
        -> A pattern of sharing logic between components by passing a function as prop that returns React Elements. ==> Legacy Way
        -> An Alteranative to HOC => share logic between components.
        -> Basically function is passed as a prop to the component.
        eg: 
            const DataProvider = ({ fetchUrl, children }) => {
                const [data, setData] = useState(null);

                useEffect(() => {
                    fetch(fetchUrl).then((res) => res.json()).then(setData);
                }, [fetchUrl]);

                return children(data);
            };

            // Usage:
            <DataProvider
                fetchUrl="/api/user"
            >
                {(user) => (user ? <UserCard {...user} /> : <p>Loading...</p>)}
            </DataProvider>
        NOTE: here render is passed as function that handles the UI JSX to show i.e either UserCard component or Loading...


## Additional Topics:
    -- React Virtualization [react-window]
        -> Rendering optimization tech where only the elements visible in the viewport are rendered to the DOM, instead of rendering the entire dataset at once.
        -> Problem: Why we need Visualization ?
            -- Thousands of elements to render ==> slow dom creation. [Poor Performance]
            -- Reconciliation is faster, But DOM is the bottleneck ===> Reconciliation solves it.
        -> library: react-window
            eg: 
                import React from "react";
                import { FixedSizeList as List } from "react-window";

                const Row = ({ index, style }) => (
                    <div style={style}>Row #{index}</div>
                );

                export default function App() {
                    return (
                        <List
                            height={400}     // height of the container
                            itemCount={1000} // total items
                            itemSize={35}    // fixed height of each row
                            width={300}
                        >
                            {Row}
                        </List>
                    );
                }
        -> NOTE: 
            => Above react-window's List takes a function props [Row] that takes index and style. 
            => we dont need to create Row Component here, react-windows takes care of this.
        -> Possible ways to render Large data-sets and Differnce between them.
            -- there are 3 options:
                1. Virtualization:
                    - All items exists in memory but only visible ones [viewport] are rendered.
                2. Pagination:
                    - Data is split into pages => only one page is loaded at a time.
                3. Infinite-scroll:
                    - Loads more data as the user scrolls down => new data is added to the old data i.e the data grows with time. => might take a performance hit.
        -> Performance pitfalls:
            1. if row height is dynamic => Recalculations become expensive.
            2. impropper Buffer size => might cause flikering or performance hit.
    
    --  Websocket with React.
        -> Communication channel over a single TCP [Transfer connection Protocal] connection between the client and server.
        -> Unlink HTTP [Hyper-text Transfer protocal], websocket allows real-time, bi-directional Communication.
        -> protocal: ws:// or wss:// [secured over TLS - transport layer security] 
        -> lifecycle => open => Message => Error => Close.
        -> APIs:
            1. new WebSocket(url) ==> creates a new connection.  [Natively available in browser API]
            2. socket.send(data)  ==> Sends data to server.
            3. socket.close()     ==> close the connection.
            4. socker.readyState  ==> Connection state (
                0 -> Connecting
                1 -> Open
                2 -> Closing
                3 -> Closed
            )
            5. onopen, onclose, onMessage, onerror  ==> Events that is used to manage the connection. 
        -> HTTP vs TCP:
            -> HTTP is uni-directionak and stateless, The client reqs and the server responds.
            -> TCP -> bi-directional, real-time communication -> maintain persistent connection.
        -> pitfall:
            1. no auth/authorization out of the box.
            2. no REST like semantics.
            3. no built-in reconnection logic 
        -> Socket.IO => A library built on-top of websockets that adds fallbacks, reconnection, multiplexing and namespaces.


## React State Management:
    -- Redux ==> helps manage state in a centralized store, especially used for large application where we have deep nested components.
    -- Elements:
        1. Actions
            -> Plane JS Objects that descibe an event.
            -> must include 'type' property.
            -> may include payload to carry extra info for updating the state.
        2. Reducers:
            -> Are Pure functions. [no side effects like api calls, always have same output with the same input] => Ensures State updates are predicatable and testable.
            -> must include => state[initial], action and return new state.
            NOTE: existing state cannot be mutated here ===> must return a new state.
        3. Store:
            -> store is created with the reducer defined.
            -> configureStore with Redux Toolkit ==> creates a store.
        4. Middlewares:
            -> Intercepts actions before they reach reducers.
            -> usecase:
                1. Async logic [Redux Thunk]
                2. Logging actions.
                3. Authentication/redirects.
    eg: 
        1. reducer:
            const counterReducer = (state = {count: 0}, action) => {
                const {type} = action;
                switch(type) {
                    case 'Increment':
                        return {count: state.count +1 };
                    default:
                        return state;
                }
            }
            NOTE: reducer based on action's type property [action must have type] ==> returns the updated state.
        2. create a store:
            const counterStore = createStore(counterReducer);   // takes createStore from react-redux.
        3. wrap APP with Provider [from react-redux] and store.
            <Provider store={counterStore}>
                <App />
            </Provider>
        4. use useDispatch() and useSelector() to access the store state.
            const dispatch = useDispatch();
            const count = useSelector(state => state.count);  //Picks the count from the redux state.

            onClick ={() => dispatch({type: 'Increment})};   //calling the dispatch to send action.
    NOTE:
        1. Multiple reducers can be combined into a single root reducer with ===> combineReducers.  [Build into Redux]
        eg: 
            import { combineReducers } from 'redux';

            const userReducer = (state = {}, action) => { /* ... */ };
            const postsReducer = (state = [], action) => { /* ... */ };

            const rootReducer = combineReducers({
            user: userReducer,
            posts: postsReducer,
            });

            // state shape: { user: ..., posts: ... }

        2. reduceReducer => utility included with @reduxjs/toolkit. => To chain multiple reducers together so they can process the same state. [From the external library support]
        eg: 
            import reduceReducers from 'reduce-reducers';

            const baseReducer = (state = {}, action) => { /* ... */ };
            const extraReducer = (state, action) => { /* ... */ };

            const combinedReducer = reduceReducers(baseReducer, extraReducer);
        NOTE: all reducers in reduceReducers receive the same state and action and state flows through them one by one.
    
    -- Redux ToolKit [RTK]:
        -> Prob with Redux ==> had to create actionTypes, action creators and reducers manually.
        -> sol: RTK reduces boilerplate code, auto-gen actions.
        -> Working logic:
            1. Create store.
                import { configureStore } from '@reduxjs/toolkit';
                import counterReducer from './counterSlice';

                const store = configureStore({
                    reducer: {
                        counter: counterReducer,
                    },
                });

            2. CreateSlice. ==> Generates the reducers and actions automatically.
                import { createSlice } from '@reduxjs/toolkit';

                const counterSlice = createSlice({
                    name: 'counter',
                    initialState: { value: 0 },
                    reducers: {
                        increment: (state) => {
                            state.value += 1; // ✅ Immer under the hood - allows "mutating" [we can directly update state here, it will take care of immutability under the hood.]
                        },
                        decrement: (state) => {
                            state.value -= 1;
                        },
                    },
                });

                export const { increment, decrement } = counterSlice.actions;   //createSlice -> automatically creates actions.
                export default counterSlice.reducer;                            //createSlice -> automatically creates reducers.

            NOTE: Immer is used above that allows us to mutate the state directly i.e state.value += 1 ==> under the hood it takes care of the immutability.    

            3. create AsyncThunk:  ==> handles aasync actions like fetching data...
                import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';

                // Async thunk
                export const fetchUser = createAsyncThunk('user/fetchUser', async (userId) => {
                    const res = await fetch(`/api/user/${userId}`);
                    return res.json();
                });

                const userSlice = createSlice({
                    name: 'user',
                    initialState: { data: null, status: 'idle', error: null },
                    reducers: {},
                    extraReducers: (builder) => {
                        builder
                            .addCase(fetchUser.pending, (state) => {
                                state.status = 'loading';
                            })
                            .addCase(fetchUser.fulfilled, (state, action) => {
                                state.status = 'succeeded';
                                state.data = action.payload;
                            })
                            .addCase(fetchUser.rejected, (state, action) => {
                                state.status = 'failed';
                                state.error = action.error.message;
                            });
                    },
                });
            NOTE: 
                1. Here we are making an API call ==> We are adding cases on the API fetch status inside extraReducers.
                2. How to call thunk actions with dispatch:
                    const dispatch = useDispatch();
                    onClick={() => dispatch(fetchUser(id))}  ==> Triggers Async Thunk actions. => Once it fulfilled, state is updated.
                3. useSelector ==>
                    1. Triggers re-render if the value changes [shallow comparision]
                    2. Advice to be very specific on Selection of state items with useSelector.
                        eg: 
                            const user = useSelector(state => state.user);           //re-render whenever the whole user obj changes ==> unnecessary re-renders here.
                            const userName = useSelector(state => state.user.name);  //re-render when the name changes.
        -> ContextAPI vs Redux:
            1. used for a Performance optimization of small DOM Tree, REdux is for a Prod level Application.
            2. Context API is pretty simple with createContext, Provider, useContext, Redux has some boilerplate code [simplified with RTX]
            3. Context API solves Prop drilling issue, Redux Provides a centeralized state.
            4. Doesn't inheritly supports async logic, RTX has createAsyncThunk ==> handles async Logic.

        -> ContextAPI pitfalls:
            1. Any child component which is using the Context will be re-rendered when the contextVal updates.
                -> Sol: memorise the context value.
        ->  Redux advantage on the above issue:
            -> we have useSelector that takes out a very specific state's value instead of the whole object ==> prevents unnecessary re-renders.
        -> useCase:
            -> ContextAPI if data is rarely updated,  Redux if data is updated frequently or have async calls.
            -> Context API dont have middleware or dev tool support, Redux have middleware support.
    -- React Query/SWR:
        -> Why go ahead with useQuery rather than useEffect + useState ?
            1. Caching.
            2. Retry on failure.
            3. Refresh on window focus.
            4. Reduce the manual work on handling API status and error State.
        -> SWR 
            -> Provided by vercel ==> Handles API calls specifically with Next.js => includes caching, Auto-refresh.
            eg: 
                import useSWR from 'swr'

                const fetcher = url => fetch(url).then(res => res.json())
                const { data, error, isLoading } = useSWR('/api/user', fetcher)
            -> preferred for simple use-case ot smaller apps.

    
## React Design Patterns: 
    1. Single Responsibility Principle.
        -- Each Component must be designed to hanldes one thing. eg: Either fetch data and maintain the state or Based on props just render the UI.
        --  example -> HomePage  ==> PostFeed ==> PostCard.
        -- HomePage Comp:
            - handles rendering the homePage and it's components.
            - Manage Posts State and fetching the data.  => Pass it down to PostFeed Component.
        -- PostFeed Comp:
            - hanldes rendering the PostFeed UI. => take a list of Posts and render each PostCard Comp.
            - Pass Post Details => PostCard Comp.
        -- PostCard Comp:
            - It's Just a Pure Component. => No fetching or side-effect.
            - Renders Each Posts.
    
    2. Page Components, Feature Components and UI Components:
        -- Feature Component:
            - This component handles some actions, includes side-effects like API calls and handling states i.e include the functionality Logic.
            - eg: SignInForm Comp.
                -- It is responsible for validating the form inputs.
                -- Then handle POST API on Form Submit.  
                -- Includes Functionality and Logic.
        -- UI Component:
            - Simply renders the UI => Include no side-effect or state.
            - Receives Data from Props => Only handles rendering the UI.
        -- Page Component:
            - Handles Multiple Side-effects like API calls for different elements not just signIn.
            - diff between Feature and Page component:
                -- Feature component handles side-effects related to particular feature.
                -- Page components handles multiple side-effects that is required in that Page not just a particular feature.
    
    3. Compound Components:
        -- Provide Flexibility on the design of a Particular component.
        -- uses Context API in Implementation.
        -- We can dynamically break component's part into smaller module and use them as per our requirement.
        eg: 
            <ParentComp>
                </ParentComp.Child1>
                </ParentComp.Child2>
                </ParentComp.Child3>
            </ParentComp>
        Here, I have the Flexibility to choose what child to render under ParentComponent.
        NOTE: the Child Component cannot be used Outside ParentComp as they uses the Context's Value from Parent that binds them to Parent.
    
    4. Extracting Codes to Hooks 
        -- move codes including API calls with useEffect and States  ===> their own custom hooks.  [It abstracts all the Functionality and useEffects]
        -- Makes the code structure modular and clean.




## Extra Important Notes:
    -- 



 

