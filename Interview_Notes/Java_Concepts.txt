** Interview preparation For Core Java Devs ***

1. Core Java.
    1. OOP => Encapsulation, Inheritance, Polymorphism.
    2. JavaBaisc => DataTypes, Variables, Loops, Arrays, TypeCasting.
    
    3. Object Class & Wrapper Class => equals(), hashcode(), toString(), AutoBoxing/Unboxing.
    4. Java Memory Management => Stack vs Heap, Garbage Collection, Finalize, System.get().
    5. Exception Handling => Checked vs UnChecked, try-catch-Finally, Custom Excpetion.
    6. Collection FrameWork => List, Set, Map, Queue, Iterator, Comparables vs Comparator.
    7. Multi-Threading & Concurrancy => Thread class, Runnable, Synchronization, ExecutorService
    8. Immutable Objects & String Pool => String, StringBuilder, StringBuffer, Interning
    9. Access Modifiers & Keywords =>	static, final, this, super, transient, volatile
    10. Interfaces & Abstract Classes =>	default, static methods in interfaces, multiple inheritance
    11. Inner Classes =>	Static, Non-static, Anonymous, Lambda context
    12. Enum, Annotations, Reflection =>	Real use cases, runtime inspection
    13. Design Principles & Patterns	=> SOLID, Factory, Singleton, Builder (intro for now)
    14. Best Practices & Common Pitfalls => Null handling, equals/hashCode contracts, immutability
			
		
	
2. Java 8
    1. Lambdas
    2. Stream
    3. function Interfaces.
    4. Optional
    5. Method References.
    
3. Springboot.
    1. Annotations.
    2. Dependency Injection.
    3. Rest APIs.
    4. Spring Data JPA.
    5. Profiles.
		
		

### Java Core:

-> OOPS:
    1. Encapsulation => Class [bundling data + method] => use Private variable, getters and setters to access it.
    2. Inheritance => Code sharing => use "extend" to access other class and their methods eg: single, Multilevel, Hierarchical [Supports Multiple Inheritance only with interfaces => avoid ambiguity]
    3. Polymorphism =>
        1. Static  => Method Overloading. => same fun name but different return type and params type.
        2. Dynamic => Method Overriding. => In Inheritance => you override the method that you inherite.
    -> Static Method belong to class, not to it's Object. ==> You cannot Override it.
    4. Abstraction.
        -> hide complex implementaion and show only needed details.
        -> supports: Abstract class & Inheritance.
    eg:
        1. Abstract Class Implementation:   [A template for vehicle => all vehicle has engine, each defined how it starts. => ** code sharing **]
            abstract class Vehicle {
                int speed;

                // Constructor
                Vehicle(int speed) {
                    this.speed = speed;
                }

                // Concrete method
                void applyBrakes() {
                    System.out.println("Brakes applied at speed: " + speed);
                }

                // Abstract method
                abstract void start();
            }
            
            
            class Car extends Vehicle {

                Car(int speed) {
                    super(speed);
                }

                @Override
                void start() {
                    System.out.println("Car started with speed: " + speed);
                }
            }


        2. Interface Implementation:  ["Rechargeable" => Any vehicle using this, Must define how it charge. We dont care how. => **featuers whoever using, must define it**]
        
            interface ElectricVehicle {
                int getBatteryLevel(); // abstract method by default
                void charge();

                // default method from Java 8
                default void showBatteryStatus() {
                    System.out.println("Showing battery status...");
                }

                // static method from Java 8
                static void plugInfo() {
                    System.out.println("Use Type-C charging port.");
                }
            }
            
            class ElectricScooter implements ElectricVehicle {
                private int battery = 80;

                public int getBatteryLevel() {
                    return battery;
                }

                public void charge() {
                    battery = 100;
                    System.out.println("Scooter charged to " + battery + "%");
                }
            }				
        
    -> When to use which one ? [** NOTE **]
        1. want to share code => use abstract class, interface with default [Java 8 onwards]
        2. you need state or construtor => use abstract class.
-> 	commonly used DataTypes => byte, int, long, float [float fb = 10.5f], double[double d = 10.4], char, boolean.
    -> Type Conversion & casting.
        int a = 10;
        double d = a; // allowed.

        double d = 10.5;
        int a = (int) d; // manually casted.
    -> Arrays: 
        -> Arrays are Objects in Java. ==> Stored in heap => get length as arr.length [length is a property of Array Object]
        -> define:
            int[] arr = new int[5];
            int[] arr = {1, 2, 3, 4};
    -> Strings:
        -> Immutable in Java => Once define cannot update it. [thread safe, slowest performance]
        eg: 
            String a = "Hi";
            a.concat(" Thanks");
            sysout(a);  // Prints "Hi" => the same variable cannot be updated.

        -> StringBuilder => Mutable, not thread-safe, faster Performance.
        -> StringBuffer => Mutable, thread-safe, medium Perfromance. [** Preferred **]
    -> == vs .equals()
        -> == : Checkes reference equality.
        -> equals => Checkes for value equality.
    -> main() 
        -> main method can be overloaded => JVM only calls main with args => String[] args.
NOTE:
    -> Java is strictly pass-by-value.
    -> For Objects => reference value is passed by value ==> Any change with the params inside the function won't effect the original val of params.  ==> return the updated value from the function.
-> 


    






#### Java Interview Notes:
## Java Interview Notes:
	1. Constructors.
		-> Initialize the Object for any class with default values or custom values using parameterized constructors.
		-> Always called when the object is initialized for a class.
            -> If any constructor is defined, compiler won't create default one.
            -> Can call one constructor from another using "this()" 
		-> In Inheritance, the flow is from parent first and then child consutructors are invoked.
            -> Every child's class Constructor implicitly calls super() -> parent's default constructor by default.
            -> Java ensures Object is fully constructed from top (Parent) to bottom (child).
            -> If Parent has only parameterized constructor, Child must call it explicitly.
        -> Super() keyword is used to call the Parent's constructor -> Must be first line.
        -> If class has any final variable -> Constructor must set the value during object creation.
            -> NOTE: If the variable is static final => variable belongs to the class directly can have constant value across all Objects for the class.
		
	2. Aggregation in Java
		-> Any class that have Entity Reference. 
		-> Represents a relationship.
		-> Basically, using another class reference Object inside a class.
		   -> Employee Obj has details like name, id, age etc, along with that it also has Object name Address -> [a seperate class which has details includes city, state, country]
        -> Weak Association i.e Child class can exists without Parent Class [Address can be used as an independent class without employee class]
    
    2.1 Composition in Java
        -> Relationship between Classes where the child lifecycle is strongly bounded with Parent class. [Strong Association]
        -> useCase: Car -> Engine or Human -> Heart  [here the one cannot exist with it's child]
        eg: 
            class Engine {
                void start() {
                    sysout("Start the Engine");
                }
            }

            class Car {
                private Engine engine;   //strongly coupled..

                public Car() {
                    this.engine = new Engine();   //consturctor we have initialize the engine.
                }

                public void start() {
                    this.engine.start();  // calling the method from Enginee class -> Has to be here othewise no point of car.
                    sysout("Car is moving");  
                }

            }
	
	3. Inheritances.
		-> Properties of parents can be reused in by the child class. [Code Reuseablity]
		-> Types: 
			1. single-level -> A->B
			2. Hierarchical  -> A->B, A->C.
			3. Multi-level -> A->B->C
			4. Multiple.  [A,B -> C  => Not supported for normal class in Java -> can cause method ambiguity in child class]
                -> Can be acheived using Interfaces
	
	4. Data Structures:
		1. Arrays
			-> Sorting program in Java.
			  1. Go with standard int[] arr = {}, Arrays.sort() // sorts in O(n logn).
			  2. use List<Integer> nums = Arrays.asList(...) => buuble sort Logic O(n^2).
					-> Shorter tech: use Collections.sort().
					-> Write logic for bubble sort. 
		NOTE: 
			- primitive dataType like int[] arr = {1, 2, 4} -> has .length, and can access elements like arr[5];   //O(1)
			- Non-primitive dataType like List<Integer> arr = Arrays.asList(....)  --> Here to access the element .get(index) //O(1), .size() for length.
            - For LinkedList<Integer> => Random access is not possible i.e O(N)
			
	5. Encapsulation & Abstraction [Explain via code]
		1. Encapsulation
			-> Wrapping up of data + methods in a single unit (i.e class), restrict direct access using, exposed using getter and setters.
			-> Define:
				1. Class.
				2. private data members.
				3. Constructors.
				4. getters with proper return type.
				5. setters with proper void as return type.
				
		2. Abstraction 
			-> Data Hiding, hide details and expose only essential features -> using abstract classes and interfaces.
			-> Define:
				1. interface class
					-> field will be public static final (constants)
					-> Methods are implicitly public.
					-> No constructors allowed.
					-> Java 8 Enhancements:
						1. default:
							-> methods can be defined with: default void method_name() {...};
							-> This methods can be acessed by the child class directly.
                            -> default methods in an interface can be overridden -> No Issues.
						2. static:
							-> static void method_name() {...};
							-> belongs to the interface, not to an instance of the implenting class.
							-> can be called with the interface_name.method_name() in Main class directly.
				2. Child classes implementing the interfaces 
					-> Methods must be public. By default access scope is package-private [accessible in the same package]
					-> use @Override annotation to override the implementing methods.
                    -> In case of conflict while override methods in case of multiple implementation of interfaces i.e 
                        class A implements B, c {...}
                        -> This will cause ambiguity, as it is not sure which interface method we are overriding. 
                        -> If interfaces have default methods -> You can call specific interface's method using interface_name.super.method_name() [call's show method from B interface]
			Alternative:
				-> using Abstract classes.
					1. Define abstract class {}.
					2. Define the Abstract method with public abstract void method_name();
					3. Define the Concrete method: public void method_name() {....};
				NOTE:
					-> Can have constructors too.. [** IMP **]
				-> Child Classes will extend the abstract class.
					-> use @Override to overwrite the abstract methods.
					-> can directly access the concrete class.

    NOTES:
		1. Why do we still need Abstract classes when we already have default with Interfaces in Java 8 onwards.
			1. Fields in Abstract class can be (public/private/protected), In Interface it can only be public static final i.e constant.
			2. Constructors are there with Abstract class. Interface has nothing.
			3. methods can be (public/private/protected) with Abstract class, In Interfaces, methods are implicitly public.
			4. useCase:
				Interfaces can be very generic -> there not necessary we have a strong bind with the child class. i.e interface vehicle -> class Car [Both have same functionality]
				Abstract classes are more strongly binded with the child class -> abstract class Vehicle -> Car [More similarities]
			5. Multiple Inheritance:
				Abstract classes -> class Child extends A, B {...}
					-> this is wrong, As it will create ambiguity/Confusion as in which method we are overriding !
					-> Not allowed in abstract classes.
				Interfaces: class Child implements A, B {...}
					-> this is allowed, as it doesnot hold any state and method conflict can be resolved.
					-> Conflict method_name case:
						-> Assumed, in both the interfaces we used default void method_name() {...} i.e same method name but different implementation
						-> Resolution in child class: 
							@override
							public void method_name() {
								A.super.method_name();   // This specify which interface's method we are calling 
							}
		2. Difference between "static final" and "final":
			-> public static final int constVal = 56;
				-> This belongs to the class not to the instance.
				-> Can be accessed with the class name directly.
				-> Value is shared across all instance.
			
			-> public final int constVal;
				-> belongs to the instance not to the class.
				-> It's value must be set using a parameterized constructor.
				-> Each Instance can have, it's own copy of constant value.
        3. Function Interfaces:
            -> interface with only single abstract method.
            -> example: 
                1. Runnable interface [method run()]
                2. Callable interface [method call()]
                3. Comparator interface [method compare()]
            -> Advantages: 
                -> before Java 8, we need to create an Anonymous class to override the method of the interface.
                    eg: Sort the list of strings, based on their length: [old ways]
                        Collections.sort(list, new Comaparator<String>() {
                            @Override
                            public int compare(String a, String b) {
                                return a.length() - b.length();
                            }
                        });
                -> with Function interface we can directly access the method using lambda expressions. [Since we know only 1 method is there anyways]
                    eg: eg: Sort the list of strings, based on their length: [new ways]
                        Collections.sort(list, (a, b) -> a.length() - b.length());   [Here comparator is a functional Interface]
        4. How can we create Immutable class ?
            -> A class whose fields cannot be changed after the Object is created.
                eg: String, Integer, LocalDate are immutable class.
            -> Defination: 
                1. declare the class as final.   eg: final class Config {...};
                2. declare the fields are private and final:  eg: private final String variable_name;  [set value using constructor]
                3. declare the get_methods alone.
            -> Advantages of Immutable objects:
                1. Complete Thread Safety [As fields value never changes]  usecase: shared configurations, constants, caching.
                2. Keys in hashMap/Hashset => need to have a fixed hashcode() for a particular key. eg: Strings as keys in HashMap, hashCode for the key never changes.
                3. Caching => JVM uses String pool to cache immutable String value -> Saves Memory
        5. Exception Handling with Java
            -> Checked [handled using try-catch block] and unChecked Exceptions [Runtime Exceptions, handled using "throws" keyword]
            -> eg:
                1. checked Exception [try-catch, Compile time]  --> extended from Exception Class.
                    1. IOException
                    2. SQLException
                    3. ClassNotFoundException
                2. unChecked Exception [throws, throw - run time exception] -> exctended form RuntimeException Class.
                    1. ArrayIndexOutOfBoundException
                    2. NullPointerException
                    3. ArithmeticException
            -> Notes:
                1. Multiple catch blocks are possible but the order also matters. [Catch specific exceptions first and then at the end "Exception e" i.e generic one]
                2. Finally block will always executes, except if we have used "System.exit(0)".
                3. throw vs throws
                    -> throw: used "inside the method" to explictly throw execeptions.
                    -> throws: used in the "method signature" to declare exceptions that can be thrown.
                eg: 
                    void readFile() throws IOException {
                        throw new IOException("file is missing");
                    }
                4. Custom Exceptions:
                    -> we can create out own custom exception by extending the Exception class. 
                        -> it's Constructor can be called using super(msg).
        6. What is Maven ? How we use it in Application ?
            -> A build automation and project management tool.
            -> uses POM file -> manages Project dependencies, plugins, build configs. [ maven has centralised repo for all dependency Jars]
            -> Handle build life cycle => [complie -> test -> package -> install -> deploy]
            -> Difference between Maven install vs maven package
                -> maven install -> install dependency jars into local repo [.m2 folder]
                -> maven package -> create Jar/War file inside target dir of the project.
                -> maven clean  => clens the target dir from previous builds.
                -> maven compile => compile the source code.

	

	6.  Collections in Java
		-> Baically taking about Data structure supports in Java: List, Set, Map, PriorityQueue, Comparables vs Comparator
		-> Comparable Vs comparators:
			1.Comparable
				-> It is defined inside the class.
				-> method overridden: compareTo(T obj);
				-> Only 1 natural order allowed inside the class.
				-> uses Java.lang
				-> used in: Collections.sort();
				-> eg: 
					class Person implements Comparable<Person> {
						String name;
						int age;

						@Override
						public int compareTo(Person other) {
							return this.age - other.age; // natural order = by age
						}
					}
					Collections.sort(list); // uses compareTo(), list => contains list of Person objs...

			2. Comparators
				-> It is defined outside the class.
				-> Method used: compareTo(T obj1, T obj2);
				-> can be used for multiple custom ordering.
				-> uses Java.util
				-> used in: Collections.sort(list, comp)
				-> eg:
					// By name
					Collections.sort(list, (a, b) -> a.name.compareTo(b.name));   // list => Contains list of person objs..

					// By descending age
					Collections.sort(list, (a, b) -> b.age - a.age);

		-> Notes:
			1. Null values with Linear data structurs: 
				-> List, LinkedList, => allows null inside them.
				-> HashSet -> allows only 1 null.
				-> TreeSet -> Doesnot allow null atall, as it needs compareTo to sort.
                -> For primitive type array i.e int[] arr => It will not take null value [compile error]
			2. Difference between ArrayList & LinkedList ?
				1. ArrayList:
					-> Internally uses dynamic array.
					-> ArrayList class can act as List only.
					-> implements randomAccess interface. i.e Retrival is faster with ArrayList. O(1)
					-> insertion in the middle or Random places is slower.
                    -> Binary Search is faster in case of ArrayList -> O(log n)
					
				2. LinkedList:
					-> Internally uses doubly Linked List.
					-> LinkedList class can act as List and queue. [implements List and dequeue Interfaces]
					-> No implementation of randomAccess Interface i.e Retrival takes O(n) time. => slower.
					-> Insertion/Deletion in the middle or random places is faster with LinkedList. O(1).
			3. No Random Access in case of String Manupulation.
				-> Reverse a string directly is not possible as Strings are immutable in Java.
				-> First convert the string in charArray. -> Perfrom operations.
				-> Then convert charArray into String using new String(charArray).
				-> Alternativly use -> StringBuffer, can use append() to add chars/strings into existing str. Bonus: It also have .reverse() to reverse the whole str.
			4. Super Keyword in Java.
				1. call the constructor of the immediate parent class. 
				2. In case of Overriden method => super.method_name(); --> Calls the parent class method. [access original logic]
			5. .equals() Vs == in Java
				-> ArrayList or int[] list => compares list items element by element.
				-> String's content we can compare i.e str1.equals(str2).
				-> "==" -> compares memory refeneces, comapre values directly for primitive data types.
				-> .equals() => Defined in Object Class, overriden by String, Integer, ArrayList classes to comapre Content.
				NOTE:
					1. String str = new String("name") -> Heap + pool
						-> This always creates new object in the heap.
					2. String str = "name";
					   String str2 = "name";
					   -> "name" will go inside the string pool and it's reference will be reused.
					   -> str == str2 [same reference, true]
					3. String str = new String("name");  [** Important **]
					   String str2 = "name";
					   -> str == str2 [One is in heap, other one is in pool i.e false]
					   -> str.equals(str2) [true, as the content is same]
			6. How do you compare 2 object's content not their Refrences
                -> We must override the "equals()" from the object class inside the class's body.
                -> For using the Object of the class inside hashed-based collection like HashMap or Hashset -> we must override "hashcode()" also. [IMP]
                eg: 
                    class Employee {
                        private int empId;
                        private String name;

                        public Employee(int id, String name) {
                            this.empId = id;
                            this.name = name;
                        } 

                        //Override the equals method to comapre instances of this class..
                        @Override
                        public boolean equals(Object obj) {
                            if(this == obj)  return true;  //If the same instance is used.

                            Employee emp = (Employee) obj;
                            return this.id == emp.id && Object.equals(this.name, emp.id);
                        }

                        //For using Employee instance as a key in Hashed-based containers...
                        @Override
                        public int hashcode() {
                            return Object.hash(id, name);   //using name + id field to create unique hashvalue for each instance of this class.
                        }
                    }
                ***NOTE:
                    -> "==" this compares the refernce in the memory, Not the content.
                    -> equals() method from Object class must be overriden to compare the content of an instance of any class.
                    -> usecase and example:
                        String class's .equals() already is overriden => thus it compare ths content.
                        Integer class's .equals() is also already overriden => this is comapares the value ! not the reference.
                    -> Dont Forget to override the hashcode method from Object class too -> If this instance will be used as key in Hashed based DS -> specify fiels used to generate unique hash.
            7.  TreeMap Over HashMap ?
				1. HashMap:
                    -> HashMap stores elements in non-structured way [due to Hashing].
                    -> Operations are faster i.e get/remove/update all are O(1).
                    -> Allows 1 null value as key.
                    -> Internal Implementation: Hashtable + LinkedList/Bucket (hashing)
                    -> usecase: faster lookup, insertion/deletion.
                    eg:
                        Map<Integer, String> map = new HashMap<>();
                        map.put(56, "testing");
				2. TreeMap:
                    -> TreeMap stores elements in a stored in a ordered manner, based on either natural Ordering or Custom comparator.
                    -> Operations are slower i.e get/remove.update all are O(log n) -> as order updates after each action in red-black tree.
                    -> No Null keys are allowed due to comparator's ordering.
                    -> Internal Implementation: Red-black tree. [self-balancing tree]
                    -> usecase: ordered key set.
                    eg:
                        1. Map<Integer, String> treeMap = new TreeMap<>(
                            (a, b) -> b-a
                        )
                        -> Defining TreeMap with custom comparator => "b-a" orders the keys in descending order.
                        2. Map<String, Integer> treeMap = new TreeMap<>(
                            Comparator.comparingInt(String::length)
                        )
                        -> Keys are sorted based on the length of the key. [Note who we used function reference like String::length and Comparator.comparingInt to comapre 2 integer values]
                        3. Map<Employee, Integer> treeMap = new TreeMap<>(
                            (e1, e2) -> e1.name.comapreTo(e2.name)
                        )
                        -> In case keys are Object instance -> we need to use custom comparator like above or in class you must implement Comparable interface and override comapreTo for default natural Ordering.
            8. How HashMap Works in Java ?
                -> 3 steps:
                    1. Hashing: use the hash funtion to get the hashcode.
                    2. Initialize the arrays of bucket i.e "Node<K, V>[] table"  -> Each bucket is like a slot where entries are stored.
                    3. Storing in the bucket.
                -> Working: 
                    -> Find the hash of the key --> find the bucket corresponded to that hashcode -> If empty, directly insert, if not [colloision case] -> resolve using LinkedList [< java 8] OR Tree [>= Java 8].
                -> Collosion Case:
                    -> When 2 keys have the same hash [Colloision occurs]
                    1. Before Java 8:
                        -> Each Bucket is a LinkedList of Node<K,V>.
                        -> On Colloision a new entry is inserted in the List.
                        -> Problem: With too many colloisions -> The LinkedList grows, lookup will be O(N).
                    2. After Java 8:
                        -> If LinkedList size > 8 --> Then it will converted to balanced Red-black tree.
                        -> solutions: Lookup are Tree Operations with O(log n) [** improvement **]
                        -> Can handle heavy collisions.
                -> NOTE:
                    1. Default size is 16, with LoadFactor: 0.75 [means, On 75% full, the capacity becomes 2 times of original]
                    2. Problem: Expensive operation -> Since all keys must be re-hashed again.
                -> HashMaps are not thread-safe. 
                    -> multiple thread waiting to access the HashMap can result in data-loss or overwrite or Infite loops causing deadlocks.
            9. ConcurrentHashMap/ Collections.SynchronizedMap(new HashMap<>()) for thread Safety. 
                -> SynchronizedMap used to lock the whole map on every operation => very slow in multi-threaded env.
                -> ConcurrentHashMap is designed for high Efficiency.
                    1. Before Java 7:
                        -> It used to have segements internally -> threads can parallelly write to different segements at a time.
                        -> But if 2 threads writing the same segment -> One has to wait.
                    2. After Java 8 onwards:
                        -> Segmentation removed.
                        -> Locking is implemented at bucket level for write actions -> better concurrency.
                        -> Read operation is never blocked.
                        -> It doesnot accept null keys or Values.  [To avoid ambiguity in multi-threading]
                ->  useCase:
                    -> Caching DB result in services => multiple thread can read/write concurrently.
                eg: 
                    ConcurrentHashMap<Integer, String> newMap = new ConcurrentHashMap<>();
                    newMap.put(23, "test1");
                    newMap.put(34, "test2");
                    newMap.put(56, "test3");

                    // thread-safe Iteration.
                    for(Integer key : newMap.keySet()) {
                        System.out.println(key + ":" + newMap.get(key));   // Pring key: value pairs...
                    }
            10. WeakHashMap:
                -> In weakHashMap -> keys are stored as weak reference [i.e If they are not referenced anywhere then GC will automatically remove them]
                -> In HashMAp, keys are strong reference i.e Unitll we remove the keys, it wont be removed.
                -> Keys must be Objects (Why? weak reference works only on Objects !!)
                eg: 
                    Map<Object, String> newMap = new WeakHashMap<>();
                    Object key = new Object();
                    
                    newMap.put(key, "test");

                    // Make the key as null...
                    key = null;
                    system.gc();  //request GC to perform cleanup.

                -> Since Key lost it's reference, It will automatically collected by the GC.
            11. LinkedHashMap:
                -> Maintains Insertion Order or access order.'
                -> useCase: LRU Cache.
                eg: 
                    class LRUCahe<K, V> extends LinkedHashMap<K, V> {
                        private final int capacity;

                        public LRUCache(int capacity) {
                            super(capacity, 0.75f, true);   //Calling the constructor of parent class.
                            this.capacity = capacity;
                        }

                        // Overrides method for removing the old entry when the size exceeds..
                        @Override
                        protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
                            return size() > capacity;   //remove the last recently used entry.
                        }
                    }



	7. Stream API in Java
        -> Steams are seq of elements supporting functional style operations. 
        -> Streams are not DS like Collections [eg: ArrayList, HashMap], they are more like pipeline view for data.
        -> Streams are lazy -> Without terminal Operator, they won't executes.
        1. Stream Operations:
            1. intermediate (return another stream) -> map, filter, sorted, distinct, limit
            2. terminal (produce Result) -> collect, forEach, reduce, count.
        2. How to create Stream ?
            1. From Collection:  list.stream()
            2. From Arrays: Arrays.stream()
            3. using Straem.of(...)
        3. Frequently used Stream Methods:
            1. filter(s -> s.startsWith("s"))  -> filter the data 
            2. Map(String::toUpperCase)        -> Return modified stream data -> Map(s -> s.toUpperCase())
            3. reduce(0, Integer::Sum)         -> Reduces the data <startVal, (acc, curr) -> {...}>
            4. faltMap -> flattern the nested List/streams.
            5. collect() -> eg: Collectors.toList() -> Collects the the stream into List, Map, Set etc.
            6. sorted() -> sort stream as per natural order or custom Order based on Comapartor used.
            7. distinct -> remove duplicates.
            8. anyMatch(), allMatch(), nonMatch() -> Conditional checks.
        4. ParallelStream:
            -> can split the workload across thread. 
            -> use only if data is too big. Dont use for smaller data set.
        5. Collectors [** IMP **]:
            -> toList(), toSet(), toMap()
            -> groupingBy()
            -> PartitioningBy()
            -> joining()
        eg: Group Employee with highest salary by department.
            Map<String, Optional<Employee>> topEmpByDept = 
                employeeList.stream()
                    .collect(
                        Collectors.groupingBy(Employee::getDept, 
                            Collectors.maxBy(Comparator.comparingInt(EMployee::getSalary));
                        )
                    );
            -> NOte the above, First, you group the employees based on dept, then use comparator to find the maxSalary employee in that dept using Colelctors.maxBy() and .comapringInt(salaryField).
        NOTES:
            -> Why streams ? why not loops ?
                -> Consise, Functional-style, ParallelStream support.
                -> Loops has more control and preferred for smaller data-sets.
            -> Limit() behaive differently in ordered and unordered streams. [TODO]
            -> forEach, Dont do any side-effects like API calls or anything..
            -> How can we short-circuit a Stream ?
                -> use limit(), findFirst() or anyMatch() -> When this satisfy, .ifPresent(System.out::println) -> will catch the output and print it.
            -> Problems useCases: [TODO]
                1. Find duplicates in a list using streams. [groupBy and counting + using entryset and Map.entries, to iterate map items]
                2. Find top N records in a List of instances. (eg: top highest salaries).  [limit]
                3. Convert List<Employee> --> Map<Dept, Employee> as per highes salary per dept. [groupBy + maxBy + comparingInt]
	

	8. Memory Management in Java
		1. How to identify Memory leaks in long running applications ?
		2. Memory Leaks issues inspite of having Garbage Collection Concept ?
			-> Causes for a Memory Leaks:
                1. Static Reference still holding objects
                    -> static fields lives for the lifetime of the classloader. -> If we don't clean it up, it causes memory leak
                    eg: 
                        class Cache {
                            private static List<String> cache = new ArrayList<>();

                            public static void addData(String data) {
                                cache.add(data);   // this will stay in the cache forever, if not manully cleaned....
                            }
                        }
                2. Unclosed Resources
                    -> Database Connections, file straems or sockets etc -> If not closed stays in memory for long time.
                    -> Sol: use try-catch resources block to check if the connection exists.
                3. Listners and Callbacks
                    -> If Listners are published and never cleaned --> It's reference stays in memory..
                4. Improper Equal() and hashcode() implementation
                    -> If equals() is overriden, but hashcode() is not overridden then it will never get removed from hashMap/hashSet. 
                5. ThreadLocal Misuse
                    -> ThreadLocal stores values per thread, if not removed explicitly, it will stay for the entire thread life-cycle.
                6. Large Collections Growing unboubed 
                    -> Collections like ArrayList, Map, tend to grow while storing data, If not cleared for the data which are not in use -> Can cause memory leaks.
            -> Tools:
                -> use VisualVM, JProfiler or YourKit to identify the memory leak issues.
		3. How design a theread pull that adjust size based on System load ?
			-> using thread pool executor. [In older Versions like Java 8], with Java 21 we have virtual threads
			-> using dynamic pools or execution handlers. [Need to look into it]
        4. Java Memory Model ?  [** IMP **]
            -> It defines how threads interact through memory i.e How changes done by one thread is visible to others.
            -> Problems to be addressed in multi-threaded programs:
                1. Visibility Issues
                    -> Thread A updates a variable, But Thread B doen't see the change.
                2. Reordering issues
                    -> CPU or compiler might reorder instructions for optimizations.
                3. Atomicity issues 
                    -> operations like i++ might not be atomic.
            -> Component of JVM:
                1. Heap
                    -> shared between all the threads.
                    -> All objects and instances variables lives here. 
                2. thread Stack
                    -> Each thread has it's own stack.
                    -> Local variable, Function call frames and primitive type lives here.
                3. Working Memory (thread Cache)
                    -> Thread may cache variable locally -> For Performace optimization.
            -> Concepts:
                1. Volatile
                    -> variable updated by one thread is immediatly visible to other threads.
                    eg: 
                        class Shared {
                            volatile boolean flag = false;
                        }
                2. Synchronized
                    -> Ensures mutually exclusion + visibility.
                    -> blocking a block ensures atomicity, visibility.
                3. Happens-Before Relationship
                    -> Rules that defines memory visibility order between threads.
                    -> eg: 
                        writing to a volatile -> happens-before reading from it.
            -> Notes:
                1. Why volatile works ? Why preferred over Synchronized ?
                    -> volatile ensures visibility but not atomicity.
                    -> for flags, status variables, single variable upates => use volatile.
                    -> for incrementing a counter i.e i++, Or updating a list  -> use Synchronized as we need atomicity here. i.e 1 thread to perform action, other must wait.
                2. analogy:
                    1. heap -> shared whiteboard [all threads can see changes]
                    2. thread stack -> personal notebook [Each thread has it's own stack]
                    3. volatile -> notes on whiteboard [all can see any update to any variable] 
                    4. Synchronise -> meeting room -> Only 1 thread can see do the updates, others need to wait.
	
	

	9. Multi-Threading Concept in Java
		1. Concurrency Risk with HashMap in Multi-threaded Env
		    -> Risks of 2 threads reading and updating the hashMap.
                1. Data Loss -> (loss updates or overwritten values)
                2. Infinite loop -> (due to resizing and rehashing, if 2 threads perfrom this action -> creates a circular linkedList inside the bucket)
                3. Unexpected Null values -> (changes of one thread is not visible to other, possible null values)
            -> Solution:
                -> For Read operation from multiple thread -> HashMap will work [no threads are blocked]
                -> For Read and Write operations from multiple thread => ConcurrentHashMap [build for efficiency because of bucket level locks]
		2. Volatile Keyword guarntee thred-safety ?
            -> Volatile Ensures : Visiblity [changes by 1 thread is visible to others] + Happens-before relationship [a write to variable happens-before read from that variable by another thread]
            -> Drawback:
                1. Doesnot guarntee Atomicity i.e increment operator like "count++" are unsafe
            eg: 
                class ShareData {
                    private volatile boolean running = true;

                    public void runTask() {
                        while (running) {.. Do some task...}
                        Sysout("Task Stopped")'
                    }

                    public void stop() {
                        running = false;
                    }
                }

                main() {
                    SharedData data = new SharedData();
                    Thread t1 = new thread(data::runTask);   //thread starts with the run action...
                    t1.sleep(1000);  // thread is paused for 1ms.
                    data.stop();  // update running to false --> Since volatile, thread catch this update and stop the runTask() method.
                }
		3. Synchronise Vs Volatile ?
            -> Volatile is just for 1 variable and it's visibility, Synchronized is for both of method for visibility + Atomicity.
            -> Volatile doesnot have any locking concept, Synchronized do have locking concept.
            eg: 
                class SharedData {
                    private volatile int count = 0; 

                    public void incrementVolatile() {
                        count++;    // Not-thread safe -> multiple thread can update this count, and no thread can determine the correct value. [Atomicity issue]
                    }

                    private int SynchroniseCount = 0;

                    public Synchronise void incrementSync() {
                        SynchroniseCount++;   // thread-safe -> Since only 1 thread at a time can access this method => others will wait, once done, other can read correct value. [Atomicity ensured]
                    }
                }
		4. Why creating thread through ExectorService is Preferred over thread/Runnable ?
            -> Ways to Spin up threads in Java: 
                1. extend the thread Class.
                    Issue:
                        -> If you want to extend Thread to other class, you cannot do that => Multiple Inheritance is not allowed for classes.
                2. implement Runnable Interface.
                    -> with Interfaces, we can implement for as many classes as we want -> Flexible.
                    eg: 
                        class MyThread implements Runnable {
                            public void run() {
                                sysout("Thread is running");
                            }
                        }

                        Main() {
                            Thread t1 = new Thread(new MyThread());
                            newthread.start();  // starts the thread...
                        }
                3. implemtns Callable interface.
                    -> Unlike Runnable Interface, Callable interface does return a result and throws exception.
                    eg: 
                        class MyTask implements Callable<Integer> {
                            public Integer call() throws Exception {
                                return 42;
                            }
                        }

                        Main() {
                            ExecutorService service = ExectorService.newSingleThreadExecutor();
                            Future<Integer> result = service.submit(new MyTask());
                            sysout(result.get());
                            service.shutdown();
                        }

            -> Why do we use ServiceExecutor instead of using Thread/Runnable ?
                -> Problems with Thread():
                    1. Too many thread can crash JVM. -> out of Memory
                    2. Each task creates a new thread -> expensive
                    3. hard to mange life-cycle.
                    4. with Runnable, you dont even get return values.

                -> Advantages of ServiceExecutor:
                    1. Thread Pooling  -> reuses fixed no of threads -> better resource management.
                    2. Task Submission -> submit(), invokeAll(), invokeAny() more flexible that thread.start().
                    3. Callable + Future Support. -> get result from Thread.
                    4. Better Resource management -> shutdown() can terminate the thread.
                    5. Scalability -> can use different pool size.
                eg: 
                    Main() {
                        ExecutorService exec = Executors.newFixedThreadPool(3);   //fixed the thread count to 3.

                        for(int i=0; i<5; i++) {
                            final int taskId = i;
                            exec.submit(() -> {
                                sysout(taskId + Thread.currentThread().getName());
                            })
                        }

                        exec.shutdown();   //orderly shutdown.
                    }
                NOTE: thread pool is fixed to 3 thread but it handling all 5 tasks. -> Efficient.
        5. How do we decide the number of thread for an appliction ?
            -> Cases:
                1. For CPU bound tasks -> Thread count should be equal to the number of cores, extra thread only cause context-switching overheating.
                2. For I/O tasks -> Most of the tasks will be blocked waiting for input or output, we need more threads -> Formula: N_thread = N_Cores * (1 + wait/compute);
            -> This can only provide the starting value, with testing dependin upon the load, thread count can be managed.
        6. Thread Deadlocks ? Example with code ?
            -> Deadlocks situation occurs when 2 threads are waiting for each-other's resources -> none of them can proceed.
            eg:
                Main() {
                    Resource r1 = new Resource();
                    Resource r2 = new Resource();

                    // Thread 1 -> locks r1 and then looks for locking r2.
                    Thread t1 = new Thread(() -> {
                        Synchronized(r1) {
                            sysout("r1 is locked now...");
                            Synchronized(r2) {
                                sysout("r2 is locked now...");

                            }
                        }
                    });

                    // Thread 2 -> locks r2 and then look for locking r1.
                    Thread t2 = new Thread(() -> {
                        Synchronized(r2) {
                            sysout("r2 is locked now...");
                            Synchronized(r1) {
                                sysout("r1 is locked now...");

                            }
                        }
                    });

                    t1.start();
                    t2.start();
                }
        NOTE: This ends up into a deadlock situation with Thread 1 and Thread 2 locking each other resources and none of them can proceed.
        7. What exactly are Threads ? Life-cycle of Threads ?
            -> What ?
                -> threads are the smallest unit of execution in a process. [Smallest unit of any running Task -> called thread]
            -> lifecycle:
                1. New -> Thread is created but not started yet i.e Thread t1 = new Thread()
                2. Runnable -> Ready to run, waiting for CPU. t1.start()
                3. Running -> thread is running, doing some work. "run()"
                4. Blocked/waiting/sleeping -> thread is paused, because either it is sleeping ["sleep(ms)"], waiting [wait()] or blocked i.e waiting for some other resource to complete.
                5. Terminated -> Thread has finsihed the task, can't restart again.
            



	10. Spring Boot With Java
		1. Diference between All spring terms Like Spring, Spring MVC, Spring boot ?
            -> Differences between different Spring terms:
                1. Spring FrameWork
                    -> This is the core tech for building loosly coupled Java application using Dependency Injection and aspect-oriented framework.
                    -> feat:
                        1. IOC (Inversion of Control) / Dependency Injection 
                        2. Aspect Oriented Programming -> cross-cutting concerns like logging and transaction.
                        3. Data Base Layer (JDBC, ORM Ikntegration)
                    -> Foundation framework to manager beans, dependencies and cross-cutting concerns.
                2. Spring MVC
                    -> MVC (Model-view-controller) is web framework build on top of Spring MVC. --> Helps building web applications -> Handle HTTP req, contollers and view.
                    -> feat: 
                        1. DispatchServelt -> Front controller for all incmong traffic.
                        2. Controller -> Handles user input and returns model data.
                        3. ViewResolver -> Maps model data to UI (JSP).
                    -> Spring MVC = Web layer built on top of Spring Core, handling HTTP request/response flow.
                3. Spring Boot 
                    -> Production-Ready extension of Spring that simplifies setup and configurations.
                    -> feat: 
                        1. Auto-Configuration -> automatically configure beans based on classpath dependencies.
                        2. Embedded Servers -> Tomcat/Jetty/undertow - no need to deploy wars
                        3. Starter Dependencies -> pre-packaged dependencies like "spring-boot-starter-web"
                        4. PRoduction Tools -> Actuators, metric, health checks etc
                    -> Spring boot -> No Tomcat config, no XML -> Just run the app directly as a Java Application.
            ->  What is IOC and DI ?
                -> Problem:
                    -> Traditional way (without Spring) -> In Java application, We create Objects for any dependent class directly inside the dependent class.
                    -> eg: Inside EmployeeService class, you create new object from Employee and save it.
                    -> Strongly binded, hard to test, maintain or replace dependencies.
                    -> Solution: IOC -> instead of us manually maintaining the dependencies, Let the Container (IOC container of Spring) manage it.
                1. IOC [Inversion of Control]
                    -> we don't manually create dependencies, Instead we tell spring container what we need and it insert it for us.
                2. DI  [Dependency Injection]
                    -> This is a design pattern use to implement IOC.
                    eg: 
                        class EmployeeService {
                            private final EmployeeRepository empRepo;

                            // Here the dependency is inserted using Constructor..
                            @Autowired 
                            public EmployeeService(EmployeeRepository empRepo) {
                                this.empRepo = empRepo;
                            }
                        }
                    NOTE: Here Spring creates and Inject EmployeeRepository automatically into EmployeeService.
                    -> Types Of DI in Spring:
                        1. Constructor Injection [@Autowired on Constructor] -> Recommeneded
                        2. Setter Injection [@Autowired on setter method] -> Optional dependencies
                        3. field Injection [@Autowired on field]  -> Quick but less testable.
                -> IOC Container
                    -> Heart of spring framework.
                    -> role:
                        1. create and managing beans.
                        2. Inject dependencies
                        3. Manage bean life-cycle and scope.
                    -> Common Container:
                        1. ApplicationContext (used majorly)
                            eg: 
                            ApplicationContext appcontext = new AnnotationConfigApplicationContext(AppConfig.class);
                            EmployeeService empService = appcontext.getBean(EmployeeService.class);
                -> Analogy:
                    1. without IOC: You as chedf, buy, cook, clean the dish all by yourself.
                    2. with IOC : The restaurent (Spring) supplies whatever you need. You just cook the dish you want using what injected in your application.

            1. Spring Boot Actuators ?
                -> Prod ready feature of Spring boot that provides Monitoring, metrics, health-checks and application-insights.
                -> Add dependency in POM.xml -> Spring-boot-starter-actuator.
                -> url: http://localhost:8080/actuator/[health [application running status] or info [custom app info] or metrics [JVM, memory] or loggers [view/ change log level] or beans [shows all spring beans and dependncies] or shutdown [gracefully shutdown] or envs [show env properties]]
                -> By default: health and info is exposed, for other, need to add in application.properties: management.endpoints.web.exposure.include=* 
            2. Spring Boot Profiles (application-dev.yml, application-prod.yml)
                -> It segregates env specific configurations in spring-boot application.
                -> Instead of manully updating the env properties for Prod, dev or QA -> use application-{profileName}.properties.
                -> During run-time, spring boot picks the active profile form application.properties with: spring.profile.active=dev
                -> for Beans also, we can use @Profile("dev") --> This create the bean for a particular service only for the mentioned profile.
		2. What are Srping Beans? Spring Beans Life cycle ? How bean Discovery Works ?
            -> Spring beans are Objects created, managed and controlled by Spring IOC Controller (ApplicationContext).
            -> creation: whenever you define a class as @Service, @Repository, @Controller, @Component -> Spring takes over the class
                1. Create a single object of that class (singleton bydefault)
                2. Inject any dependencies if any
                3. Manage it's life-cycle (initialize to destruction)
            -> usecase:
                1. without Spring, we need to manuall create the instance: EmployeeService empService = new EmployeeService.
                2. With spring, we tell Spring we need it: [Constructor Injection of bean]
                   class Employee {
                        private EmployeeService empservice;

                        @Autowired
                        Employee(EmployeeService empservice) {
                            this.empService = empService;
                        }
                   }
                NOTE: we have other ways like setter injection or field injection but the above one is more preferred.
            -> How Spring discovery works ?
                1. using @SpringBootApplication includes @ComponentScan, @EnbaleAutoConfigurations, @Configurations.
                2. ComponentScan -> Tells spring to search all files in the current Package and sub-packages for components.
                3. Type of components it picks up:
                    1. @Component  -> generic spring-banged beans
                    2. @Service    -> business logic layer beans
                    3. @Repository -> DAO (Database Access Object) Layer bean.
                    4. @Contorller / @RestController -> Web API Controller bean.
                    5. @Configuration -> Beclared using @Bean method.
            -> Bean Life-cycle:
                1. Bean Defination loaded -> Spring reads bean meta-data from @configurations/@Config files. 
                2. Bean Instantiation -> Object is created using constructor.
                3. Dependency injection => Dependency is injected if any.
                4. @PostConstruct -> runs the logic like connection to DB or loading cache.
                5. Bean Ready -> bean is now available to the application.
                6. Bean Cleanup -> Before conatiner shutdown, bean cleanup is performed.
            -> Bean Scopes :
                1. singleton -> One instance per spring IOC container. (by default)
                2. prototype -> New instance everytime, we request the bean.
                3. request -> one instance per HTTP request (web only)
                4. session -> one instance per HTTP session (web only)
                5. application -> one instance per ServletContext (web only)
            eg:
                @Scope("prototyp")
                @Component
                public class TaskProcessor {....}
		3. Why Spring prefers Constructor injection over other any other Injections.
            -> Types of DIs:
                1. Constructor -> via class constructor    -> injected at object creation.
                2. Setter      -> via public setter method -> injected after object creation.
                3. Field       -> via @Autowired on fields -> injected into fields directly after reflection.
            -> Reasons to prefer Constructor method ?
                1. immutability 
                    -> dependencies once set using constructor -> can be marked as final.
                    -> This is safer and easy.
                2. Ensure Mandatory Dependencies
                    -> You cannot create object without including it's dependencies -> as it is used in the Object constructor.
                    -> If the dependencies are not found, App fails to start -> "fail-fast behaviour" ensured.
                3. Helps unit testing
                    -> Easy to mock dependency and inject them using mockito.
                4. Avoid Null prointer exceptions. 
                    -> Since dependenies are added in constructor -> They cannot be null like field or setter methods.
            -> Usecase for Setter Injection:
                1. For optional dependencies.
                2. Reconfigurable beans -> may change later.
            eg: 
                class NotificationService {
                    private EmailService email;

                    @Autowired(required = false)
                    public void setEmailService(EmailService email) {
                        this.email = email;  //optional dependency.
                    }
                }
            -> Usecase for Field Injection:  [Not Recommeneded to use atall]
                1. Testing is difficult, cannot mock fields.
                2. Hidden dependencies. (not visible to constructors)
                3. breaks encapsulation and SRP [Single responsibility principle]
            eg: 
                public class Order {
                    @Autowired
                    private PaymentService payservice;
                } 
            NOTE: use this method of injection for small demo or exmaple only. ---> Not for production application.
			-> Can we have Circular dependency with Constructor Injection ?
                -> What is circular dependency condition ?
                    -> When Bean A depends upon Bean B, and Bean B depends upon Bean A [Deadlock scenarios]
                    -> Since both dependencies are required for creation of each other's object --> Spring cannot create both of them.
                -> REsult: The aPplication fails to start.
		4. Custom conditional Annotations ?
			-> Conditional Annotations decide which beans to create or skip during runtime based on certain conditions on class, present of property val or env values.
            -> usecase: Spring Boot auto-configuration decide which beans to load during app startup.
            -> Builtin -> @ConditionsOnProperty, @ConditionOnClass and @Proile are using for dynamic configurations.
            NOTE: We can create custom Conditions too by implementing the Condition interface [override match method], use annotation bean like: @Conditional(MyCondition.class)
		5. SpringBoot Auto-Configuration feature ? How it works ? @SpringBootApplication Annotation ? Why it is used ? [** IMP **]
            -> Auto-config is the key feature that helps Srping boot create production-ready application faster.
            -> When you add dependency: spring-boot-starter-web, It does the below configs: 
                1. Embedded Tomcat server.
                2. DispatchServlet
                3. WebMvcConfigurerer
                4. Default page
                5. Jackson JSON mapper
                Static resource handling.
            -> Auto-Configuration working step by step:
                1. @SpringbootApplication -> Define your on your main Class. -> triggers auto-configuration process.
                    -> Includes @SpringBootConfiguration or Just @Configuration, @ComponentScan and @EnableAutoConfiguration 
                2. @SpringBootConfiguration
                    -> Special version of configurations.
                    -> Marks the class as the source for bean definations for the Spring context. i.e register current class as configuration classs to applicationContext.
                3. @ComponentScan
                    -> Enables Component Scanning starting from the package of the main class.
                    -> Detects and register beans annoted with @Component, @Service, @Controller, @Repository.
                4. @EnableAutoConfiguration:
                    -> the heart of Springboot.
                    -> Tells Springboot internally to automatically configure the application based on the classPath and exisiting beans.
                    -> It loads auto-configurations [DispatchServelt, RequestMappingHandlerMapping etc are created and registered] only after user defined beans [@Component, @Service ...] are registered.
		6. How does @Scope Annotation behaves in a multi-threaded REST Controllers ?
			3. Creates a new Bean on every http requests. It is not shared between the threads.
		7. Approach to follow if you want to update specific fields in a class.
			4. use POJO Classes with getters and setters.
		8. Difference between PUT and PATCH Methods ?
		    1. Difference between @RestController & @Controller
                -> Both are parth of Spring MVC -> Implements differs based on the requirement for HTML view or JSON/XML View.
                1. @Controller
                    -> used for returning views (HTML/JSP pages)
                    -> Returns a view name --> resolved by ViewRenderer.
                    -> annotation: @Controller
                    -> usecase: Traditional MVC web applications.
                    eg:
                        @Controller
                        public class HomeController {
                            
                            @GetMapping("/home")
                            public String home(Model model) {
                                modelt.addAttribute("message", "welcome Home !");
                                return "home";  //resolved to home.html  --> renders the page directly.
                            }
                        }
                    NOTE: here, "home" is passed to ViewResolver -> Which loads a template related to home.html.    
                2. @RestController 
                    -> used for creating RESTful webservices.
                    -> returns Response Body in from of JSON or XML.
                    -> annotaion: @Controller + @ResponseBody
                    -> usecase: Rest APIs / MicroServices.
                    eg:
                        @RestController
                        public class UserController {

                            @GetMapping("/user")
                            public User getUser() {
                                return new User("sourav", "developer");
                            }
                        } 
                    NOTE: @Restcontroller -> converts the Enity object into JSON response using Jackson(via HttpMessageConverter).
            2. SpringBoot REST API flow
                -> Flow involves:
                    1. Client Request
                        -> Client sends a HTTP req to GET: /api/product/101
                    2. DispatchServlet (Front Controller)
                        -> All Request goes through this DispatchServelt.
                        -> It's Job:
                            1. acts as a front controller -> Intercept every HTTP calls.
                            2. Delegate reqs to the correct-relevant controller via Handler Mapping.
                    3. Handler Mapping
                        -> Spring finds the matching method associated with @RequstController and @GetMapping with "/product/{id}"
                    4. Handler Adapter
                        -> handler Adapter invokes the method found.
                    5. Controller Execution
                        -> Controller executes and returns a Product Object.
                    6. HttpMessageConverter
                        -> This checkes Accept header for "application/json" -> Serialize the product object, -> to JSON (using Jackson) /XML. (using JAXB)
                    7. Response Returned
                        -> The serialized JSON is written to HTTP response body and send back to client.
                Summary:
                    Client Requst ---> DispatchServelt ----> Handler mapping + Adapter [Find and execute matching method] --> Controller + HttpMessageConverter [response from Entity -> JSON] -> Returned to client.
            3. REST API: PUT Vs Patch Operations: 
                1. PUT: we update the entire Object.
			    2. PATCH: we can update any particular column, we can do that.
		9. Calling 3 mincroservices in parallel, combine the result, What Appraoch to use ?
		10. How do you implement distributed Tracing ? How do you track the life cycle of an API ?
			-> use SAGA Pattern -> Tracks all ongoing API calls across the microservices.
		11. JWT token is expired mid-way. How this situation can be handled ?
			-> It will call the refresh Token. 
		12. How do you implement IP-rate limiting in Springboot for public APIs ? [*IMP*]
            -> How do you optimize your connection to database where to limit the no. of hits to DB to fetch data ?
		13. SOLID Principles Implementation usecase in a real Enterprice level Application.
        14. Caching in Springboot for faster response ? What different ways to implement it ?
            -> Different Caching strategices ?
        15. Database connection realted annotations with SpringBoot. Like @Transactional Annotation and Singleton Principle.
            1. How to use @transaction with Spring Data JPA
                -> @Transaction manages database transactions automatically.
                -> usecase: If a public method is marked as @Transactional  [NOTE: Proxies works only for public methods]
                    1. all DB Operations inside are part of the same transaction.
                    2. If all methodes completes Successfully -> Transaction is commited.
                    3. If any one of them exception occured -> Transaction is rolledback.
            eg:
                @Service
                public class OrderService {
                    @Autowired
                    private OrderRepository orderRepo;
                    
                    @Autowired
                    private PaymentRepository paymentRepo;

                    @Transactional
                    public void placeOrder(Order order, Payment payment) {
                        orderRepo.save(order);
                        paymentRepo.save(payment);

                        //Error case...
                        if(payment.getAmount() > 10000) {
                            throw new RuntimeException("Playment Limit exceed");
                        }
                    }
                }
             NOTE:
                1. Spring starts transaction before calling PlaceOrder.
                2. both save are called. 
                3. Any exception occurs -> Everything is rolled back [Nothing gets saved]      
            2. Why @Transactional is Preferred on method level ? Why not defined it at class level ?
                -> @Transaction is added on public method of the Service class.
                -> Reasons:
                    1. You cannot exculde transaction behaviour for methods --> i.e all pbulic operation inside the class will be Transactional.
                    2. Even Read-methods and light weigth methods will fall under Transaction -> Not required, unnecessary. [**IMP**]
                    3. Confusing ! Which method should we need transactional and which are not ?
            NOTE:
                case: If a transaction method calls another transaction method inside the same class --> The proxy is bypassed and the second Transaction will be ignored.
                @Transactional
                public void outer() {
                    inner();   // same class call --> proxy bypassed i.e the Transaction for inner class is ignored.
                }

                @Transactional
                public void inner() {....}
                Sol: move the second method to it's own service or use bean reference.
            3. How to handle a rollback of a transaction due to operation failure at remote service -> SAGA Patterns, Compensation or Distributery Pattern.
        16. What are the servers provided by Springboot ? 
            1. Which is the default one ? And how can we update it ?
        17. Spring Data JPA ? Why it is Preferred over normal JPA ?
            -> Spring Data JPA makes working with Databases and JPA (Java Persistence API) much simpler and faster.
            -> Concept:
                1. JPA  --> Standard/specification (interface) for ORM.
                2. Hibernate -> Implementation of JPA.
                3. Spring Data JPA -> Higher-level abstraction to reduce repetative CRUD and query code.
            Summary -> Spring Data JPA -> reduce query code and fewer bugs and faster development.
            1. Why Spring Data JPA preffered over JPA ? [***IMP***]
                1. JPA/Hibernate
                    -> Required to manager EnityManager, Transactions.
                    -> Manual Implementation.
                    -> manually write PSQL/ SQL.
                    -> Pagiantion Support -> Manual.
                2. Spring Data JPA 
                    -> Auto-managed by Spring.
                    -> Provided out of the box.
                    -> Supports method-name-based query generation.
                    -> Pagination/Sorting -> out of the box.
            2. Implementation of Spring Data JPA 
            Steps:
                1. Add Spring-boot-starter-data-JPA + Database (H2/Mysql) under pom.xml.
                2. Configure application.properties -> Add Database connection detials.
                3. Create Enity class:
                eg: 
                    @Entity
                    public class Product {
                        @Id
                        @GeneratedValue(strategy = GenerationTypes.IDENTITY)
                        private Long id;
                        
                        private String name;
                        private String category;
                        private double price;

                        //getters and setters.... 
                    }
                4. Create Repository interface.
                eg:
                    public interface ProductRepository extends JpaRepository<Product, Long> {
                        List<Product> findByCategory(String category);
                    }
                NOTE:
                    -> JpaRepository provides a lot of in-built methods like: save(), findAll(), findById(), deleteById(), count(), existsById()....etc.
                5. Define Service [takes to ProductRepository] + Controller [define routes and controllers]:
                    @Service
                    publi class ProductService {
                        @AutoWired
                        private ProductRepository repo;   //For demo, used field injection.

                        public List<Product> getAllProducts() {
                            return repo.findAll();
                        }

                        public List<Product> searchByCategory(String category) {
                            return repo.findByCategory(category);
                        }
                    }

                    @RestController 
                    @RequestMapping("/api/prodcuts")
                    class ProductController {
                        @AutoWired
                        private ProductService service;

                        @GetMapping
                        public List<Product> getAll() {
                            return service.getAllProducts();
                        }

                        @GetMapping("/search")
                        public List<Product> search(@RequestParam String category) {
                            return service.searchByCategory(category);
                        }
                    }
            3. How do you implement Search functionality ?
                -> Defines 3 main Appraoches for implementing Search or filter with Spring Data JPA -> This must be deined in "ProductRepository" interface.
                -> options:
                    1. using DerivedQueries (Method Name Queries)
                        eg:
                            List<Product> findByNameContainingIgnoreCases(String keyword);
                            List<Product> findByCategoryAndPriceLessThan(String category, double price); 
                        -> The above named method -> will automatically generate the queires required.
                    2. Custom JPQL Queires with @Query
                        eg:
                            @Query("SELECT p FROM Product p WHERE p.name LIKE %:keyword%")
                            List<Product> searchByName(@Param("keyword") String keyword);
                    3. Native Queries [use Raw Queries]
                        eg:
                            @Query(value = "SELECT * FROM product WHERE price > :minPrice", nativeQuery=true).
                            List<Product> findExpensive(@Parm("minPrice") double minPrice);
            4. custom Query usecases And in-built Queries usecases ?
                Types:
                    1. DerivedQueries -> simple filters, equals, contains, startWith etc
                    2. JPQL -> Complex Joins, computed values.
                    3. Native -> DB specific optimizations, custom SQL functions.
        18. Concept of Repository with Sping Data JPA ?
            -> Repository is a data access abstraction in Spring => That hides the details of data persistence from application logic.
            -> Respository Pattern -> Seperate the Persistence Logic from business logic. 
            -> JPA hierarchy:
                JPARepository [Adds JPA specific methods like flush, batch etc] --> PagingAndSortingRespository[Adds Paging and sorting method] --> CRUDRepository [CRUD methods like save, findAll] --> Repository [Marker Interface (no methods)]
            -> Pagination method with JPA: findAll(Pageable pageable), Sorting Method: findAll(Sort sort);
            1. Advantages of using Repository (Srping Data JPA):
                1. No Boiler Plate Code
                2. Auto Query Derivations 
                3. Built-in Pagination and Sorting Support.
                4. Custom Queries whenever needed.
                5. Transaction management by default.
                6. Integrated with Springboot -> add spring-boot-starter-data-jpa in pom.xml and you are good to go.
            2. Limitations/Disadvantages for Repository.
                1. Limited Control over SQL. [Not great for complex joins, multi-table subqueries]
                2. Not Ideal for High performance APPs.
                3. Difficult debuggin derivedQueries.  [derived Queries by method-names, we have no debugging guidelines]
                4. No built-in Support for Non-Relational Database
                    -> JPA is build for Realational databases, No-SQL needed seperate dependency.
        
	

	11. Kubes concepts:
		1. While deploying a micro-service -> How do implements zero-downtime rolling deployments.











### Coding Practices backup:

import java.util.*;

// Encapsulation Example...
class BankAccount {
    // declare private variables..
    private String accountNo;
    private double balance;
    // decalre constructors..
    public BankAccount(String account, double amount) {
        this.accountNo = account;
        this.balance = amount;
    }
    // declare getters..
    public String getAccountNo() {
        return this.accountNo;
    }
    
    public double getBalance() {
        return this.balance;
    }
    
    // declare setters...
    public void setAccountNo(String acc) {
        this.accountNo = acc;
    }
    
    public void setBalance(double amount) {
        this.balance = amount;
    }
}

// Abstraction example...
interface Vehicle {
    void start(); // implicitly public
    void stop();
    default void run() {
        System.out.println("Vehicle is running");
    }
    static void intro() {
        System.out.println("This is vehicle interface !");
    }
}

class Car implements Vehicle {
    // By default access is package-private [accessible inside the same package ], must define public.
    @Override
    public void start() {
        System.out.println("Car Starts");
    }
    @Override
    public void stop() {
        System.out.println("Car Stops");
    }
}

class Bike implements Vehicle {
    @Override
    public void start() {
        System.out.println("Bike Starts");
    }
    @Override
    public void stop() {
        System.out.println("Bike Stops");
    }
}

class Main {
    public static void bubbleSortAlgo(List<Integer> nums) {
        int n = nums.size();
        boolean swapped;
        
        for(int i=0; i<n; i++) {
            swapped = false;
            for(int j=0; j < n-1-i; j++) {
                if(nums.get(j) > nums.get(j+1)) {
                    Collections.swap(nums, j, j+1);
                    swapped = true;
                }
            }
            
            // Already sorted for this ith index...
            if(!swapped) {
                break;
            }
        }
    }
    public static void main(String[] args) {
        
        // Can directly call in main class..
        Vehicle.intro();
        
        Car myCar = new Car();
        Bike myBike = new Bike();
        
        myCar.start();
        myBike.start();
        
        myCar.run();
        
        
        // BankAccount bac = new BankAccount("67789", 56000.98);
        // System.out.println(bac.getAccountNo());
        // bac.setBalance(8900.0);
        // System.out.println(bac.getBalance());
        
        // int[] arr = {5, 2, 9, 7, 1};
        // List<Integer> nums = Arrays.asList(5, 2, 9, 7, 1);
        // // Arrays.sort(arr);  // O(n logn)
        // bubbleSortAlgo(nums);
        // System.out.println(nums);
        
        
        
    }
}





### Anangram code....

import java.util.*;

public class App {

    public static boolean checkAnagram (String str1, String str2) {
        Map<Character, Integer> freqMap = new HashMap<>();
        
        for(char ch : str1.toCharArray()) {
            freqMap.put(ch, freqMap.getOrDefault(ch, 0) + 1);
        }

        for(char ch : str2.toCharArray()) {
            if(!freqMap.containsKey(ch)) return false;
            freqMap.put(ch, freqMap.getOrDefault(ch, 0) - 1);
            if(freqMap.get(ch) == 0) freqMap.remove(ch);
        }

        return freqMap.isEmpty();
    }

    public static void main(String[] args) throws Exception {
       System.out.println(
        checkAnagram("listen", "silent")
       );

    }
}



### Reverse a string...
import java.util.*;

public class App {
    public static void main(String[] args) throws Exception {
        
        String name = "Sourav";
        StringBuffer str = new StringBuffer();

        int r = name.length() - 1;
        while(r >=0 ) {
            str.append(name.charAt(r));
            r--;
        }
        System.out.println(str);
    }
}