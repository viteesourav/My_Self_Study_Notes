** Interview preparation For Core Java Devs ***

1. Core Java.
    1. OOP => Encapsulation, Inheritance, Polymorphism.
    2. JavaBaisc => DataTypes, Variables, Loops, Arrays, TypeCasting.
    
    3. Object Class & Wrapper Class => equals(), hashcode(), toString(), AutoBoxing/Unboxing.
    4. Java Memory Management => Stack vs Heap, Garbage Collection, Finalize, System.get().
    5. Exception Handling => Checked vs UnChecked, try-catch-Finally, Custom Excpetion.
    6. Collection FrameWork => List, Set, Map, Queue, Iterator, Comparables vs Comparator.
    7. Multi-Threading & Concurrancy => Thread class, Runnable, Synchronization, ExecutorService
    8. Immutable Objects & String Pool => String, StringBuilder, StringBuffer, Interning
    9. Access Modifiers & Keywords =>	static, final, this, super, transient, volatile
    10. Interfaces & Abstract Classes =>	default, static methods in interfaces, multiple inheritance
    11. Inner Classes =>	Static, Non-static, Anonymous, Lambda context
    12. Enum, Annotations, Reflection =>	Real use cases, runtime inspection
    13. Design Principles & Patterns	=> SOLID, Factory, Singleton, Builder (intro for now)
    14. Best Practices & Common Pitfalls => Null handling, equals/hashCode contracts, immutability
			
		
	
2. Java 8
    1. Lambdas
    2. Stream
    3. function Interfaces.
    4. Optional
    5. Method References.
    
3. Springboot.
    1. Annotations.
    2. Dependency Injection.
    3. Rest APIs.
    4. Spring Data JPA.
    5. Profiles.
		
		

### Java Core:

-> OOPS:
    1. Encapsulation => Class [bundling data + method] => use Private variable, getters and setters to access it.
    2. Inheritance => Code sharing => use "extend" to access other class and their methods eg: single, Multilevel, Hierarchical [Supports Multiple Inheritance only with interfaces => avoid ambiguity]
    3. Polymorphism =>
        1. Static  => Method Overloading. => same fun name but different return type and params type.
        2. Dynamic => Method Overriding. => In Inheritance => you override the method that you inherite.
    -> Static Method belong to class, not to it's Object. ==> You cannot Override it.
    4. Abstraction.
        -> hide complex implementaion and show only needed details.
        -> supports: Abstract class & Inheritance.
    eg:
        1. Abstract Class Implementation:   [A template for vehicle => all vehicle has engine, each defined how it starts. => ** code sharing **]
            abstract class Vehicle {
                int speed;

                // Constructor
                Vehicle(int speed) {
                    this.speed = speed;
                }

                // Concrete method
                void applyBrakes() {
                    System.out.println("Brakes applied at speed: " + speed);
                }

                // Abstract method
                abstract void start();
            }
            
            
            class Car extends Vehicle {

                Car(int speed) {
                    super(speed);
                }

                @Override
                void start() {
                    System.out.println("Car started with speed: " + speed);
                }
            }


        2. Interface Implementation:  ["Rechargeable" => Any vehicle using this, Must define how it charge. We dont care how. => **featuers whoever using, must define it**]
        
            interface ElectricVehicle {
                int getBatteryLevel(); // abstract method by default
                void charge();

                // default method from Java 8
                default void showBatteryStatus() {
                    System.out.println("Showing battery status...");
                }

                // static method from Java 8
                static void plugInfo() {
                    System.out.println("Use Type-C charging port.");
                }
            }
            
            class ElectricScooter implements ElectricVehicle {
                private int battery = 80;

                public int getBatteryLevel() {
                    return battery;
                }

                public void charge() {
                    battery = 100;
                    System.out.println("Scooter charged to " + battery + "%");
                }
            }				
        
    -> When to use which one ? [** NOTE **]
        1. want to share code => use abstract class, interface with default [Java 8 onwards]
        2. you need state or construtor => use abstract class.
-> 	commonly used DataTypes => byte, int, long, float [float fb = 10.5f], double[double d = 10.4], char, boolean.
    -> Type Conversion & casting.
        int a = 10;
        double d = a; // allowed.

        double d = 10.5;
        int a = (int) d; // manually casted.
    -> Arrays: 
        -> Arrays are Objects in Java. ==> Stored in heap => get length as arr.length [length is a property of Array Object]
        -> define:
            int[] arr = new int[5];
            int[] arr = {1, 2, 3, 4};
    -> Strings:
        -> Immutable in Java => Once define cannot update it. [thread safe, slowest performance]
        eg: 
            String a = "Hi";
            a.concat(" Thanks");
            sysout(a);  // Prints "Hi" => the same variable cannot be updated.

        -> StringBuilder => Mutable, not thread-safe, faster Performance.
        -> StringBuffer => Mutable, thread-safe, medium Perfromance. [** Preferred **]
    -> == vs .equals()
        -> == : Checkes reference equality.
        -> equals => Checkes for value equality.
    -> main() 
        -> main method can be overloaded => JVM only calls main with args => String[] args.
NOTE:
    -> Java is strictly pass-by-value.
    -> For Objects => reference value is passed by value ==> Any change with the params inside the function won't effect the original val of params.  ==> return the updated value from the function.
-> 


    






#### Java Interview Notes:
## Java Interview Notes:
	1. Constructors.
		-> Initialize the Object for any class with default values or custom values using parameterized constructors.
		-> Always called when the object is initialized for a class.
            -> If any constructor is defined, compiler won't create default one.
            -> Can call one constructor from another using "this()" 
		-> In Inheritance, the flow is from parent first and then child consutructors are invoked.
            -> Every child's class Constructor implicitly calls super() -> parent's default constructor by default.
            -> Java ensures Object is fully constructed from top (Parent) to bottom (child).
            -> If Parent has only parameterized constructor, Child must call it explicitly.
        -> Super() keyword is used to call the Parent's constructor -> Must be first line.
        -> If class has any final variable -> Constructor must set the value during object creation.
            -> NOTE: If the variable is static final => variable belongs to the class directly can have constant value across all Objects for the class.
		
	2. Aggregation in Java
		-> Any class that have Entity Reference. 
		-> Represents a relationship.
		-> Basically, using another class reference Object inside a class.
		   -> Employee Obj has details like name, id, age etc, along with that it also has Object name Address -> [a seperate class which has details includes city, state, country]
        -> Weak Association i.e Child class can exists without Parent Class [Address can be used as an independent class without employee class]
    
    2.1 Composition in Java
        -> Relationship between Classes where the child lifecycle is strongly bounded with Parent class. [Strong Association]
        -> useCase: Car -> Engine or Human -> Heart  [here the one cannot exist with it's child]
        eg: 
            class Engine {
                void start() {
                    sysout("Start the Engine");
                }
            }

            class Car {
                private Engine engine;   //strongly coupled..

                public Car() {
                    this.engine = new Engine();   //consturctor we have initialize the engine.
                }

                public void start() {
                    this.engine.start();  // calling the method from Enginee class -> Has to be here othewise no point of car.
                    sysout("Car is moving");  
                }

            }
	
	3. Inheritances.
		-> Properties of parents can be reused in by the child class. [Code Reuseablity]
		-> Types: 
			1. single-level -> A->B
			2. Hierarchical  -> A->B, A->C.
			3. Multi-level -> A->B->C
			4. Multiple.  [A,B -> C  => Not supported for normal class in Java -> can cause method ambiguity in child class]
                -> Can be acheived using Interfaces
	
	4. Data Structures:
		1. Arrays
			-> Sorting program in Java.
			  1. Go with standard int[] arr = {}, Arrays.sort() // sorts in O(n logn).
			  2. use List<Integer> nums = Arrays.asList(...) => buuble sort Logic O(n^2).
					-> Shorter tech: use Collections.sort().
					-> Write logic for bubble sort. 
		NOTE: 
			- primitive dataType like int[] arr = {1, 2, 4} -> has .length, and can access elements like arr[5];   //O(1)
			- Non-primitive dataType like List<Integer> arr = Arrays.asList(....)  --> Here to access the element .get(index) //O(1), .size() for length.
            - For LinkedList<Integer> => Random access is not possible i.e O(N)
			
	5. Encapsulation & Abstraction [Explain via code]
		1. Encapsulation
			-> Wrapping up of data + methods in a single unit (i.e class), restrict direct access using, exposed using getter and setters.
			-> Define:
				1. Class.
				2. private data members.
				3. Constructors.
				4. getters with proper return type.
				5. setters with proper void as return type.
				
		2. Abstraction 
			-> Data Hiding, hide details and expose only essential features -> using abstract classes and interfaces.
			-> Define:
				1. interface class
					-> field will be public static final (constants)
					-> Methods are implicitly public.
					-> No constructors allowed.
					-> Java 8 Enhancements:
						1. default:
							-> methods can be defined with: default void method_name() {...};
							-> This methods can be acessed by the child class directly.
                            -> default methods in an interface can be overridden -> No Issues.
						2. static:
							-> static void method_name() {...};
							-> belongs to the interface, not to an instance of the implenting class.
							-> can be called with the interface_name.method_name() in Main class directly.
				2. Child classes implementing the interfaces 
					-> Methods must be public. By default access scope is package-private [accessible in the same package]
					-> use @Override annotation to override the implementing methods.
                    -> In case of conflict while override methods in case of multiple implementation of interfaces i.e 
                        class A implements B, c {...}
                        -> This will cause ambiguity, as it is not sure which interface method we are overriding. 
                        -> If interfaces have default methods -> You can call specific interface's method using interface_name.super.method_name() [call's show method from B interface]
			Alternative:
				-> using Abstract classes.
					1. Define abstract class {}.
					2. Define the Abstract method with public abstract void method_name();
					3. Define the Concrete method: public void method_name() {....};
				NOTE:
					-> Can have constructors too.. [** IMP **]
				-> Child Classes will extend the abstract class.
					-> use @Override to overwrite the abstract methods.
					-> can directly access the concrete class.

    NOTES:
		1. Why do we still need Abstract classes when we already have default with Interfaces in Java 8 onwards.
			1. Fields in Abstract class can be (public/private/protected), In Interface it can only be public static final i.e constant.
			2. Constructors are there with Abstract class. Interface has nothing.
			3. methods can be (public/private/protected) with Abstract class, In Interfaces, methods are implicitly public.
			4. useCase:
				Interfaces can be very generic -> there not necessary we have a strong bind with the child class. i.e interface vehicle -> class Car [Both have same functionality]
				Abstract classes are more strongly binded with the child class -> abstract class Vehicle -> Car [More similarities]
			5. Multiple Inheritance:
				Abstract classes -> class Child extends A, B {...}
					-> this is wrong, As it will create ambiguity/Confusion as in which method we are overriding !
					-> Not allowed in abstract classes.
				Interfaces: class Child implements A, B {...}
					-> this is allowed, as it doesnot hold any state and method conflict can be resolved.
					-> Conflict method_name case:
						-> Assumed, in both the interfaces we used default void method_name() {...} i.e same method name but different implementation
						-> Resolution in child class: 
							@override
							public void method_name() {
								A.super.method_name();   // This specify which interface's method we are calling 
							}
		2. Difference between "static final" and "final":
			-> public static final int constVal = 56;
				-> This belongs to the class not to the instance.
				-> Can be accessed with the class name directly.
				-> Value is shared across all instance.
			
			-> public final int constVal;
				-> belongs to the instance not to the class.
				-> It's value must be set using a parameterized constructor.
				-> Each Instance can have, it's own copy of constant value.
        3. Function Interfaces:
            -> interface with only single abstract method.
            -> example: 
                1. Runnable interface [method run()]
                2. Callable interface [method call()]
                3. Comparator interface [method compare()]
            -> Advantages: 
                -> before Java 8, we need to create an Anonymous class to override the method of the interface.
                    eg: Sort the list of strings, based on their length: [old ways]
                        Collections.sort(list, new Comaparator<String>() {
                            @Override
                            public int compare(String a, String b) {
                                return a.length() - b.length();
                            }
                        });
                -> with Function interface we can directly access the method using lambda expressions. [Since we know only 1 method is there anyways]
                    eg: eg: Sort the list of strings, based on their length: [new ways]
                        Collections.sort(list, (a, b) -> a.length() - b.length());   [Here comparator is a functional Interface]
        4. How can we create Immutable class ?
            -> A class whose fields cannot be changed after the Object is created.
                eg: String, Integer, LocalDate are immutable class.
            -> Defination: 
                1. declare the class as final.   eg: final class Config {...};
                2. declare the fields are private and final:  eg: private final String variable_name;  [set value using constructor]
                3. declare the get_methods alone.
            -> Advantages of Immutable objects:
                1. Complete Thread Safety [As fields value never changes]  usecase: shared configurations, constants, caching.
                2. Keys in hashMap/Hashset => need to have a fixed hashcode() for a particular key. eg: Strings as keys in HashMap, hashCode for the key never changes.
                3. Caching => JVM uses String pool to cache immutable String value -> Saves Memory
        5. Exception Handling with Java
            -> Checked [handled using try-catch block] and unChecked Exceptions [Runtime Exceptions, handled using "throws" keyword]
            -> eg:
                1. checked Exception [try-catch, Compile time]  --> extended from Exception Class.
                    1. IOException
                    2. SQLException
                    3. ClassNotFoundException
                2. unChecked Exception [throws, throw - run time exception] -> exctended form RuntimeException Class.
                    1. ArrayIndexOutOfBoundException
                    2. NullPointerException
                    3. ArithmeticException
            -> Notes:
                1. Multiple catch blocks are possible but the order also matters. [Catch specific exceptions first and then at the end "Exception e" i.e generic one]
                2. Finally block will always executes, except if we have used "System.exit(0)".
                3. throw vs throws
                    -> throw: used "inside the method" to explictly throw execeptions.
                    -> throws: used in the "method signature" to declare exceptions that can be thrown.
                eg: 
                    void readFile() throws IOException {
                        throw new IOException("file is missing");
                    }
                4. Custom Exceptions:
                    -> we can create out own custom exception by extending the Exception class. 
                        -> it's Constructor can be called using super(msg).
        6. What is Maven ? How we use it in Application ?
            -> A build automation and project management tool.
            -> uses POM file -> manages Project dependencies, plugins, build configs. [ maven has centralised repo for all dependency Jars]
            -> Handle build life cycle => [complie -> test -> package -> install -> deploy]
            -> Difference between Maven install vs maven package
                -> maven install -> install dependency jars into local repo [.m2 folder]
                -> maven package -> create Jar/War file inside target dir of the project.
                -> maven clean  => clens the target dir from previous builds.
                -> maven compile => compile the source code.

	

	6.  Collections in Java
		-> Baically taking about Data structure supports in Java: List, Set, Map, PriorityQueue, Comparables vs Comparator
		-> Comparable Vs comparators:
			1.Comparable
				-> It is defined inside the class.
				-> method overridden: compareTo(T obj);
				-> Only 1 natural order allowed inside the class.
				-> uses Java.lang
				-> used in: Collections.sort();
				-> eg: 
					class Person implements Comparable<Person> {
						String name;
						int age;

						@Override
						public int compareTo(Person other) {
							return this.age - other.age; // natural order = by age
						}
					}
					Collections.sort(list); // uses compareTo(), list => contains list of Person objs...

			2. Comparators
				-> It is defined outside the class.
				-> Method used: compareTo(T obj1, T obj2);
				-> can be used for multiple custom ordering.
				-> uses Java.util
				-> used in: Collections.sort(list, comp)
				-> eg:
					// By name
					Collections.sort(list, (a, b) -> a.name.compareTo(b.name));   // list => Contains list of person objs..

					// By descending age
					Collections.sort(list, (a, b) -> b.age - a.age);

		-> Notes:
			1. Null values with Linear data structurs: 
				-> List, LinkedList, => allows null inside them.
				-> HashSet -> allows only 1 null.
				-> TreeSet -> Doesnot allow null atall, as it needs compareTo to sort.
                -> For primitive type array i.e int[] arr => It will not take null value [compile error]
			2. Difference between ArrayList & LinkedList ?
				1. ArrayList:
					-> Internally uses dynamic array.
					-> ArrayList class can act as List only.
					-> implements randomAccess interface. i.e Retrival is faster with ArrayList. O(1)
					-> insertion in the middle or Random places is slower.
                    -> Binary Search is faster in case of ArrayList -> O(log n)
					
				2. LinkedList:
					-> Internally uses doubly Linked List.
					-> LinkedList class can act as List and queue. [implements List and dequeue Interfaces]
					-> No implementation of randomAccess Interface i.e Retrival takes O(n) time. => slower.
					-> Insertion/Deletion in the middle or random places is faster with LinkedList. O(1).
			3. No Random Access in case of String Manupulation.
				-> Reverse a string directly is not possible as Strings are immutable in Java.
				-> First convert the string in charArray. -> Perfrom operations.
				-> Then convert charArray into String using new String(charArray).
				-> Alternativly use -> StringBuffer, can use append() to add chars/strings into existing str. Bonus: It also have .reverse() to reverse the whole str.
			4. Super Keyword in Java.
				1. call the constructor of the immediate parent class. 
				2. In case of Overriden method => super.method_name(); --> Calls the parent class method. [access original logic]
			5. .equals() Vs == in Java
				-> ArrayList or int[] list => compares list items element by element.
				-> String's content we can compare i.e str1.equals(str2).
				-> "==" -> compares memory refeneces, comapre values directly for primitive data types.
				-> .equals() => Defined in Object Class, overriden by String, Integer, ArrayList classes to comapre Content.
				NOTE:
					1. String str = new String("name") -> Heap + pool
						-> This always creates new object in the heap.
					2. String str = "name";
					   String str2 = "name";
					   -> "name" will go inside the string pool and it's reference will be reused.
					   -> str == str2 [same reference, true]
					3. String str = new String("name");  [** Important **]
					   String str2 = "name";
					   -> str == str2 [One is in heap, other one is in pool i.e false]
					   -> str.equals(str2) [true, as the content is same]
			6. How do you compare 2 object's content not their Refrences
                -> We must override the "equals()" from the object class inside the class's body.
                -> For using the Object of the class inside hashed-based collection like HashMap or Hashset -> we must override "hashcode()" also. [IMP]
                eg: 
                    class Employee {
                        private int empId;
                        private String name;

                        public Employee(int id, String name) {
                            this.empId = id;
                            this.name = name;
                        } 

                        //Override the equals method to comapre instances of this class..
                        @Override
                        public boolean equals(Object obj) {
                            if(this == obj)  return true;  //If the same instance is used.

                            Employee emp = (Employee) obj;
                            return this.id == emp.id && Object.equals(this.name, emp.id);
                        }

                        //For using Employee instance as a key in Hashed-based containers...
                        @Override
                        public int hashcode() {
                            return Object.hash(id, name);   //using name + id field to create unique hashvalue for each instance of this class.
                        }
                    }
                ***NOTE:
                    -> "==" this compares the refernce in the memory, Not the content.
                    -> equals() method from Object class must be overriden to compare the content of an instance of any class.
                    -> usecase and example:
                        String class's .equals() already is overriden => thus it compare ths content.
                        Integer class's .equals() is also already overriden => this is comapares the value ! not the reference.
                    -> Dont Forget to override the hashcode method from Object class too -> If this instance will be used as key in Hashed based DS -> specify fiels used to generate unique hash.
            7.  TreeMap Over HashMap ?
				1. HashMap:
                    -> HashMap stores elements in non-structured way [due to Hashing].
                    -> Operations are faster i.e get/remove/update all are O(1).
                    -> Allows 1 null value as key.
                    -> Internal Implementation: Hashtable + LinkedList/Bucket (hashing)
                    -> usecase: faster lookup, insertion/deletion.
                    eg:
                        Map<Integer, String> map = new HashMap<>();
                        map.put(56, "testing");
				2. TreeMap:
                    -> TreeMap stores elements in a stored in a ordered manner, based on either natural Ordering or Custom comparator.
                    -> Operations are slower i.e get/remove.update all are O(log n) -> as order updates after each action in red-black tree.
                    -> No Null keys are allowed due to comparator's ordering.
                    -> Internal Implementation: Red-black tree. [self-balancing tree]
                    -> usecase: ordered key set.
                    eg:
                        1. Map<Integer, String> treeMap = new TreeMap<>(
                            (a, b) -> b-a
                        )
                        -> Defining TreeMap with custom comparator => "b-a" orders the keys in descending order.
                        2. Map<String, Integer> treeMap = new TreeMap<>(
                            Comparator.comparingInt(String::length)
                        )
                        -> Keys are sorted based on the length of the key. [Note who we used function reference like String::length and Comparator.comparingInt to comapre 2 integer values]
                        3. Map<Employee, Integer> treeMap = new TreeMap<>(
                            (e1, e2) -> e1.name.comapreTo(e2.name)
                        )
                        -> In case keys are Object instance -> we need to use custom comparator like above or in class you must implement Comparable interface and override comapreTo for default natural Ordering.
            8. How HashMap Works in Java ?
                -> 3 steps:
                    1. Hashing: use the hash funtion to get the hashcode.
                    2. Initialize the arrays of bucket i.e "Node<K, V>[] table"  -> Each bucket is like a slot where entries are stored.
                    3. Storing in the bucket.
                -> Working: 
                    -> Find the hash of the key --> find the bucket corresponded to that hashcode -> If empty, directly insert, if not [colloision case] -> resolve using LinkedList [< java 8] OR Tree [>= Java 8].
                -> Collosion Case:
                    -> When 2 keys have the same hash [Colloision occurs]
                    1. Before Java 8:
                        -> Each Bucket is a LinkedList of Node<K,V>.
                        -> On Colloision a new entry is inserted in the List.
                        -> Problem: With too many colloisions -> The LinkedList grows, lookup will be O(N).
                    2. After Java 8:
                        -> If LinkedList size > 8 --> Then it will converted to balanced Red-black tree.
                        -> solutions: Lookup are Tree Operations with O(log n) [** improvement **]
                        -> Can handle heavy collisions.
                -> NOTE:
                    1. Default size is 16, with LoadFactor: 0.75 [means, On 75% full, the capacity becomes 2 times of original]
                    2. Problem: Expensive operation -> Since all keys must be re-hashed again.
                -> HashMaps are not thread-safe. 
                    -> multiple thread waiting to access the HashMap can result in data-loss or overwrite or Infite loops causing deadlocks.
            9. ConcurrentHashMap/ Collections.SynchronizedMap(new HashMap<>()) for thread Safety. 
                -> SynchronizedMap used to lock the whole map on every operation => very slow in multi-threaded env.
                -> ConcurrentHashMap is designed for high Efficiency.
                    1. Before Java 7:
                        -> It used to have segements internally -> threads can parallelly write to different segements at a time.
                        -> But if 2 threads writing the same segment -> One has to wait.
                    2. After Java 8 onwards:
                        -> Segmentation removed.
                        -> Locking is implemented at bucket level for write actions -> better concurrency.
                        -> Read operation is never blocked.
                        -> It doesnot accept null keys or Values.  [To avoid ambiguity in multi-threading]
                ->  useCase:
                    -> Caching DB result in services => multiple thread can read/write concurrently.
                eg: 
                    ConcurrentHashMap<Integer, String> newMap = new ConcurrentHashMap<>();
                    newMap.put(23, "test1");
                    newMap.put(34, "test2");
                    newMap.put(56, "test3");

                    // thread-safe Iteration.
                    for(Integer key : newMap.keySet()) {
                        System.out.println(key + ":" + newMap.get(key));   // Pring key: value pairs...
                    }
            10. WeakHashMap:
                -> In weakHashMap -> keys are stored as weak reference [i.e If they are not referenced anywhere then GC will automatically remove them]
                -> In HashMAp, keys are strong reference i.e Unitll we remove the keys, it wont be removed.
                -> Keys must be Objects (Why? weak reference works only on Objects !!)
                eg: 
                    Map<Object, String> newMap = new WeakHashMap<>();
                    Object key = new Object();
                    
                    newMap.put(key, "test");

                    // Make the key as null...
                    key = null;
                    system.gc();  //request GC to perform cleanup.

                -> Since Key lost it's reference, It will automatically collected by the GC.
            11. LinkedHashMap:
                -> Maintains Insertion Order or access order.'
                -> useCase: LRU Cache.
                eg: 
                    class LRUCahe<K, V> extends LinkedHashMap<K, V> {
                        private final int capacity;

                        public LRUCache(int capacity) {
                            super(capacity, 0.75f, true);   //Calling the constructor of parent class.
                            this.capacity = capacity;
                        }

                        // Overrides method for removing the old entry when the size exceeds..
                        @Override
                        protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
                            return size() > capacity;   //remove the last recently used entry.
                        }
                    }



	7. Stream API in Java
        -> Steams are seq of elements supporting functional style operations. 
        -> Streams are not DS like Collections [eg: ArrayList, HashMap], they are more like pipeline view for data.
        -> Streams are lazy -> Without terminal Operator, they won't executes.
        1. Stream Operations:
            1. intermediate (return another stream) -> map, filter, sorted, distinct, limit
            2. terminal (produce Result) -> collect, forEach, reduce, count.
        2. How to create Stream ?
            1. From Collection:  list.stream()
            2. From Arrays: Arrays.stream()
            3. using Straem.of(...)
        3. Frequently used Stream Methods:
            1. filter(s -> s.startsWith("s"))  -> filter the data 
            2. Map(String::toUpperCase)        -> Return modified stream data -> Map(s -> s.toUpperCase())
            3. reduce(0, Integer::Sum)         -> Reduces the data <startVal, (acc, curr) -> {...}>
            4. faltMap -> flattern the nested List/streams.
            5. collect() -> eg: Collectors.toList() -> Collects the the stream into List, Map, Set etc.
            6. sorted() -> sort stream as per natural order or custom Order based on Comapartor used.
            7. distinct -> remove duplicates.
            8. anyMatch(), allMatch(), nonMatch() -> Conditional checks.
        4. ParallelStream:
            -> can split the workload across thread. 
            -> use only if data is too big. Dont use for smaller data set.
        5. Collectors [** IMP **]:
            -> toList(), toSet(), toMap()
            -> groupingBy()
            -> PartitioningBy()
            -> joining()
        eg: Group Employee with highest salary by department.
            Map<String, Optional<Employee>> topEmpByDept = 
                employeeList.stream()
                    .collect(
                        Collectors.groupingBy(Employee::getDept, 
                            Collectors.maxBy(Comparator.comparingInt(EMployee::getSalary));
                        )
                    );
            -> NOte the above, First, you group the employees based on dept, then use comparator to find the maxSalary employee in that dept using Colelctors.maxBy() and .comapringInt(salaryField).
        NOTES:
            -> Why streams ? why not loops ?
                -> Consise, Functional-style, ParallelStream support.
                -> Loops has more control and preferred for smaller data-sets.
            -> Limit() behaive differently in ordered and unordered streams. [TODO]
            -> forEach, Dont do any side-effects like API calls or anything..
            -> How can we short-circuit a Stream ?
                -> use limit(), findFirst() or anyMatch() -> When this satisfy, .ifPresent(System.out::println) -> will catch the output and print it.
            -> Problems useCases: [TODO]
                1. Find duplicates in a list using streams. [groupBy and counting + using entryset and Map.entries, to iterate map items]
                2. Find top N records in a List of instances. (eg: top highest salaries).  [limit]
                3. Convert List<Employee> --> Map<Dept, Employee> as per highes salary per dept. [groupBy + maxBy + comparingInt]
	

	8. Memory Management in Java
		1. How to identify Memory leaks in long running applications ?
		2. Memory Leaks issues inspite of having Garbage Collection Concept ?
			-> Causes for a Memory Leaks:
                1. Static Reference still holding objects
                    -> static fields lives for the lifetime of the classloader. -> If we don't clean it up, it causes memory leak
                    eg: 
                        class Cache {
                            private static List<String> cache = new ArrayList<>();

                            public static void addData(String data) {
                                cache.add(data);   // this will stay in the cache forever, if not manully cleaned....
                            }
                        }
                2. Unclosed Resources
                    -> Database Connections, file straems or sockets etc -> If not closed stays in memory for long time.
                    -> Sol: use try-catch resources block to check if the connection exists.
                3. Listners and Callbacks
                    -> If Listners are published and never cleaned --> It's reference stays in memory..
                4. Improper Equal() and hashcode() implementation
                    -> If equals() is overriden, but hashcode() is not overridden then it will never get removed from hashMap/hashSet. 
                5. ThreadLocal Misuse
                    -> ThreadLocal stores values per thread, if not removed explicitly, it will stay for the entire thread life-cycle.
                6. Large Collections Growing unboubed 
                    -> Collections like ArrayList, Map, tend to grow while storing data, If not cleared for the data which are not in use -> Can cause memory leaks.
            -> Tools:
                -> use VisualVM, JProfiler or YourKit to identify the memory leak issues.
		3. How design a theread pull that adjust size based on System load ?
			-> using thread pool executor. [In older Versions like Java 8], with Java 21 we have virtual threads
			-> using dynamic pools or execution handlers. [Need to look into it]
        4. Java Memory Model ?  [** IMP **]
            -> It defines how threads interact through memory i.e How changes done by one thread is visible to others.
            -> Problems to be addressed in multi-threaded programs:
                1. Visibility Issues
                    -> Thread A updates a variable, But Thread B doen't see the change.
                2. Reordering issues
                    -> CPU or compiler might reorder instructions for optimizations.
                3. Atomicity issues 
                    -> operations like i++ might not be atomic.
            -> Component of JVM:
                1. Heap
                    -> shared between all the threads.
                    -> All objects and instances variables lives here. 
                2. thread Stack
                    -> Each thread has it's own stack.
                    -> Local variable, Function call frames and primitive type lives here.
                3. Working Memory (thread Cache)
                    -> Thread may cache variable locally -> For Performace optimization.
            -> Concepts:
                1. Volatile
                    -> variable updated by one thread is immediatly visible to other threads.
                    eg: 
                        class Shared {
                            volatile boolean flag = false;
                        }
                2. Synchronized
                    -> Ensures mutually exclusion + visibility.
                    -> blocking a block ensures atomicity, visibility.
                3. Happens-Before Relationship
                    -> Rules that defines memory visibility order between threads.
                    -> eg: 
                        writing to a volatile -> happens-before reading from it.
            -> Notes:
                1. Why volatile works ? Why preferred over Synchronized ?
                    -> volatile ensures visibility but not atomicity.
                    -> for flags, status variables, single variable upates => use volatile.
                    -> for incrementing a counter i.e i++, Or updating a list  -> use Synchronized as we need atomicity here. i.e 1 thread to perform action, other must wait.
                2. analogy:
                    1. heap -> shared whiteboard [all threads can see changes]
                    2. thread stack -> personal notebook [Each thread has it's own stack]
                    3. volatile -> notes on whiteboard [all can see any update to any variable] 
                    4. Synchronise -> meeting room -> Only 1 thread can see do the updates, others need to wait.
	
	

	9. Multi-Threading Concept in Java
		1. Concurrency Risk with HashMap in Multi-threaded Env
		    -> Risks of 2 threads reading and updating the hashMap.
                1. Data Loss -> (loss updates or overwritten values)
                2. Infinite loop -> (due to resizing and rehashing, if 2 threads perfrom this action -> creates a circular linkedList inside the bucket)
                3. Unexpected Null values -> (changes of one thread is not visible to other, possible null values)
            -> Solution:
                -> For Read operation from multiple thread -> HashMap will work [no threads are blocked]
                -> For Read and Write operations from multiple thread => ConcurrentHashMap [build for efficiency because of bucket level locks]
		2. Volatile Keyword guarntee thred-safety ?
            -> Volatile Ensures : Visiblity [changes by 1 thread is visible to others] + Happens-before relationship [a write to variable happens-before read from that variable by another thread]
            -> Drawback:
                1. Doesnot guarntee Atomicity i.e increment operator like "count++" are unsafe
            eg: 
                class ShareData {
                    private volatile boolean running = true;

                    public void runTask() {
                        while (running) {.. Do some task...}
                        Sysout("Task Stopped")'
                    }

                    public void stop() {
                        running = false;
                    }
                }

                main() {
                    SharedData data = new SharedData();
                    Thread t1 = new thread(data::runTask);   //thread starts with the run action...
                    t1.sleep(1000);  // thread is paused for 1ms.
                    data.stop();  // update running to false --> Since volatile, thread catch this update and stop the runTask() method.
                }
		3. Synchronise Vs Volatile ?
            -> Volatile is just for 1 variable and it's visibility, Synchronized is for both of method for visibility + Atomicity.
            -> Volatile doesnot have any locking concept, Synchronized do have locking concept.
            eg: 
                class SharedData {
                    private volatile int count = 0; 

                    public void incrementVolatile() {
                        count++;    // Not-thread safe -> multiple thread can update this count, and no thread can determine the correct value. [Atomicity issue]
                    }

                    private int SynchroniseCount = 0;

                    public Synchronise void incrementSync() {
                        SynchroniseCount++;   // thread-safe -> Since only 1 thread at a time can access this method => others will wait, once done, other can read correct value. [Atomicity ensured]
                    }
                }
		4. Why creating thread through ExectorService is Preferred over thread/Runnable ?
            -> Ways to Spin up threads in Java: 
                1. extend the thread Class.
                    Issue:
                        -> If you want to extend Thread to other class, you cannot do that => Multiple Inheritance is not allowed for classes.
                2. implement Runnable Interface.
                    -> with Interfaces, we can implement for as many classes as we want -> Flexible.
                    eg: 
                        class MyThread implements Runnable {
                            public void run() {
                                sysout("Thread is running");
                            }
                        }

                        Main() {
                            Thread t1 = new Thread(new MyThread());
                            newthread.start();  // starts the thread...
                        }
                3. implemtns Callable interface.
                    -> Unlike Runnable Interface, Callable interface does return a result and throws exception.
                    eg: 
                        class MyTask implements Callable<Integer> {
                            public Integer call() throws Exception {
                                return 42;
                            }
                        }

                        Main() {
                            ExecutorService service = ExectorService.newSingleThreadExecutor();
                            Future<Integer> result = service.submit(new MyTask());
                            sysout(result.get());
                            service.shutdown();
                        }

            -> Why do we use ServiceExecutor instead of using Thread/Runnable ?
                -> Problems with Thread():
                    1. Too many thread can crash JVM. -> out of Memory
                    2. Each task creates a new thread -> expensive
                    3. hard to mange life-cycle.
                    4. with Runnable, you dont even get return values.

                -> Advantages of ServiceExecutor:
                    1. Thread Pooling  -> reuses fixed no of threads -> better resource management.
                    2. Task Submission -> submit(), invokeAll(), invokeAny() more flexible that thread.start().
                    3. Callable + Future Support. -> get result from Thread.
                    4. Better Resource management -> shutdown() can terminate the thread.
                    5. Scalability -> can use different pool size.
                eg: 
                    Main() {
                        ExecutorService exec = Executors.newFixedThreadPool(3);   //fixed the thread count to 3.

                        for(int i=0; i<5; i++) {
                            final int taskId = i;
                            exec.submit(() -> {
                                sysout(taskId + Thread.currentThread().getName());
                            })
                        }

                        exec.shutdown();   //orderly shutdown.
                    }
                NOTE: thread pool is fixed to 3 thread but it handling all 5 tasks. -> Efficient.
        5. How do we decide the number of thread for an appliction ?
            -> Cases:
                1. For CPU bound tasks -> Thread count should be equal to the number of cores, extra thread only cause context-switching overheating.
                2. For I/O tasks -> Most of the tasks will be blocked waiting for input or output, we need more threads -> Formula: N_thread = N_Cores * (1 + wait/compute);
            -> This can only provide the starting value, with testing dependin upon the load, thread count can be managed.
        6. Thread Deadlocks ? Example with code ?
            -> Deadlocks situation occurs when 2 threads are waiting for each-other's resources -> none of them can proceed.
            eg:
                Main() {
                    Resource r1 = new Resource();
                    Resource r2 = new Resource();

                    // Thread 1 -> locks r1 and then looks for locking r2.
                    Thread t1 = new Thread(() -> {
                        Synchronized(r1) {
                            sysout("r1 is locked now...");
                            Synchronized(r2) {
                                sysout("r2 is locked now...");

                            }
                        }
                    });

                    // Thread 2 -> locks r2 and then look for locking r1.
                    Thread t2 = new Thread(() -> {
                        Synchronized(r2) {
                            sysout("r2 is locked now...");
                            Synchronized(r1) {
                                sysout("r1 is locked now...");

                            }
                        }
                    });

                    t1.start();
                    t2.start();
                }
        NOTE: This ends up into a deadlock situation with Thread 1 and Thread 2 locking each other resources and none of them can proceed.
        7. What exactly are Threads ? Life-cycle of Threads ?
            -> What ?
                -> threads are the smallest unit of execution in a process. [Smallest unit of any running Task -> called thread]
            -> lifecycle:
                1. New -> Thread is created but not started yet i.e Thread t1 = new Thread()
                2. Runnable -> Ready to run, waiting for CPU. t1.start()
                3. Running -> thread is running, doing some work. "run()"
                4. Blocked/waiting/sleeping -> thread is paused, because either it is sleeping ["sleep(ms)"], waiting [wait()] or blocked i.e waiting for some other resource to complete.
                5. Terminated -> Thread has finsihed the task, can't restart again.
            



	10. Spring Boot With Java
		1. Diference between All spring terms Like Spring, Spring MVC, Spring boot ?
            1. Spring Boot Actuators ?
            2. Spring Boot Profiles (application-dev.yml, application-prod.yml)
		2. What are Srping Beans? Spring Beans Life cycle ? How bean Discovery Works ?
		3. Why Spring prefers Constructor injection over other any other Injections.
			1. Can we have Circular dependency with Constructor Injection ?
            2. usecase of Constructor Injection and Setter Injection ? When to use ?
		4. Custom conditional Annotations ?
			1. creates Beans based on when a condition is satisfied.
		5. SpringBoot Auto-Configuration feature ? How it works ?
            1. @SpringBootApplication Annotation ? Why it is used ?
            2. Springboot Annotations like @SpringBootApplication, @Component, @ Service, @Repository, @Configurations etc.
		6. How does @Scope Annotation behaves in a multi-threaded REST Controllers ?
			3. Creates a new Bean on every http requests. It is not shared between the threads.
		7. Approach to follow if you want to update specific fields in a class.
			4. use POJO Classes with getters and setters.
		8. Difference between PUT and PATCH Methods ?
		    1. Difference between @RestController & @Controller
            2. SpringBoot Rest REST API flow.
            3. PUT: we update the entire Object.
			4. PATCH: we can update any particular column, we can do that.
		9. Calling 3 mincroservices in parallel, combine the result, What Appraoch to use ?
		10. How do you implement distributed Tracing ? How do you track the life cycle of an API ?
			-> use SAGA Pattern -> Tracks all ongoing API calls across the microservices.
		11. JWT token is expired mid-way. How this situation can be handled ?
			-> It will call the refresh Token. 
		12. How do you implement IP-rate limiting in Springboot for public APIs ? [*IMP*]
            -> How do you optimize your connection to database where to limit the no. of hits to DB to fetch data ?
		13. SOLID Principles Implementation usecase in a real Enterprice level Application.
        14. Caching in Springboot for faster response ? What different ways to implement it ?
            -> Different Caching strategices ?
        15. Database connection realted annotations with SpringBoot. Like @Transactional Annotation and Singleton Principle.
            -> Why @Transactional is Preferred on method level ? Why not defined it at class level ?
            -> How to handle a rollback of a transaction due to operation failure at remote service -> SAGA Patterns, Compensation or Distributery Pattern.
            -> How to use @transaction with Spring Data JPA
        16. What are the servers provided by Springboot ? 
            1. Which is the default one ? And how can we update it ?
        17. Springboot Data JPA ? Why it is Preferred over normal JPA ?
            1. How do you implement Search functionality ? 
            2. custom Query usecases And in-built Queries usecases ?
        18. Concept of Repository with Sping Data JPA ?
            3. Limitations/Disadvantages for Repository.
        
	

	11. Kubes concepts:
		1. While deploying a micro-service -> How do implements zero-downtime rolling deployments.











### Coding Practices backup:

import java.util.*;

// Encapsulation Example...
class BankAccount {
    // declare private variables..
    private String accountNo;
    private double balance;
    // decalre constructors..
    public BankAccount(String account, double amount) {
        this.accountNo = account;
        this.balance = amount;
    }
    // declare getters..
    public String getAccountNo() {
        return this.accountNo;
    }
    
    public double getBalance() {
        return this.balance;
    }
    
    // declare setters...
    public void setAccountNo(String acc) {
        this.accountNo = acc;
    }
    
    public void setBalance(double amount) {
        this.balance = amount;
    }
}

// Abstraction example...
interface Vehicle {
    void start(); // implicitly public
    void stop();
    default void run() {
        System.out.println("Vehicle is running");
    }
    static void intro() {
        System.out.println("This is vehicle interface !");
    }
}

class Car implements Vehicle {
    // By default access is package-private [accessible inside the same package ], must define public.
    @Override
    public void start() {
        System.out.println("Car Starts");
    }
    @Override
    public void stop() {
        System.out.println("Car Stops");
    }
}

class Bike implements Vehicle {
    @Override
    public void start() {
        System.out.println("Bike Starts");
    }
    @Override
    public void stop() {
        System.out.println("Bike Stops");
    }
}

class Main {
    public static void bubbleSortAlgo(List<Integer> nums) {
        int n = nums.size();
        boolean swapped;
        
        for(int i=0; i<n; i++) {
            swapped = false;
            for(int j=0; j < n-1-i; j++) {
                if(nums.get(j) > nums.get(j+1)) {
                    Collections.swap(nums, j, j+1);
                    swapped = true;
                }
            }
            
            // Already sorted for this ith index...
            if(!swapped) {
                break;
            }
        }
    }
    public static void main(String[] args) {
        
        // Can directly call in main class..
        Vehicle.intro();
        
        Car myCar = new Car();
        Bike myBike = new Bike();
        
        myCar.start();
        myBike.start();
        
        myCar.run();
        
        
        // BankAccount bac = new BankAccount("67789", 56000.98);
        // System.out.println(bac.getAccountNo());
        // bac.setBalance(8900.0);
        // System.out.println(bac.getBalance());
        
        // int[] arr = {5, 2, 9, 7, 1};
        // List<Integer> nums = Arrays.asList(5, 2, 9, 7, 1);
        // // Arrays.sort(arr);  // O(n logn)
        // bubbleSortAlgo(nums);
        // System.out.println(nums);
        
        
        
    }
}





### Anangram code....

import java.util.*;

public class App {

    public static boolean checkAnagram (String str1, String str2) {
        Map<Character, Integer> freqMap = new HashMap<>();
        
        for(char ch : str1.toCharArray()) {
            freqMap.put(ch, freqMap.getOrDefault(ch, 0) + 1);
        }

        for(char ch : str2.toCharArray()) {
            if(!freqMap.containsKey(ch)) return false;
            freqMap.put(ch, freqMap.getOrDefault(ch, 0) - 1);
            if(freqMap.get(ch) == 0) freqMap.remove(ch);
        }

        return freqMap.isEmpty();
    }

    public static void main(String[] args) throws Exception {
       System.out.println(
        checkAnagram("listen", "silent")
       );

    }
}



### Reverse a string...
import java.util.*;

public class App {
    public static void main(String[] args) throws Exception {
        
        String name = "Sourav";
        StringBuffer str = new StringBuffer();

        int r = name.length() - 1;
        while(r >=0 ) {
            str.append(name.charAt(r));
            r--;
        }
        System.out.println(str);
    }
}