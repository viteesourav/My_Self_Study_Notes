***NOTES On Important Interview concepts For JS***

-- Js came out around 1995. By - Brendan Eich
-- Js is OOPs compliant and Works on Both Client and server side. Server-Side Js is called Node JS

**Basic Knowledge on JS**

Data Types ?
* Primitive: String, Number, BigInt, Boolean, undefined, null and symbol.
NOTE:
    -- 3 or 3.5 both are handled by Number type.
    -- BigInt can hold huge number eg: let c = 3453656n; It ends with n suffix.
    -- undefined: Value declared but not assigned.
    -- null: Doesnot exist.
    -- Symbol: newly added in ES6 of JS. stores anonymous and unique values. eg: let s = symbol('hi');
* Non-Primitive: Arrays and Objects.

Hoisting ? 
-- variable and function Declaration moves to the top of the scope. Scope can be both local and global
-- This behavior is strictly for declaration only. Intializing won't be hoisted. **Imp**
-- Its JS default's Behaviour and can be stopped by adding this at the top "use strict".
NOTE: 
  Hoisting Differences between var, let and const ?
  1) var: The Variable decalration is hoisted with a default initialization of `undefined`., means you can access the variable before defining it -> function or global scope.
  2) let: Block scope, The variable is hoiseted with no initialization thus JS knows about the variable, but it will throw a REference Error saying, cannot access the variable before initialization.
  3) Const: Same as let, Value once initialized is fixed.

== vs === ?
-- == will just check the value. Interanlly It converts both them to String and then checkes the value.
-- === will check both typeOf and the value.

var Vs let ?
-- let came around 2015. Let is block Scoped i.e let can be accessed anywhere between '{' ans '}'
-- Var is function scoped. var can be accessed anywhere inside a function.
Note: 
var vs Let vs Const ?
-- Two Scopes: 
   1) Block Scope eg: scope of if..else 
   2) function Scope eg: funct() {...}
-- Var is bounded by the scope of the function. Let and const are blocked scoped.
Within a given scope:
-- Redeclaration of var is allowed but for let and const not allowed. 
-- Var is hoisted with undefined. But let and const hoisted with no Intialization.(throw error).

implicit type coercion ?
-- Automatic Conversion of Value from one data Type to another.(while using +,-, ||, && or ==).
-- '+' convert both operands to String and then concat them.
-- '-' convert both operands to Number and then subtract them. 
-- '==' converts both sides to same type i.e string before comparing.
NOTE: Boolean Coercion:
-- Falsy: null, 0, 0n, -0, undefined, false, "" and NaN are falsey. REst are all are truthy. (**Imp**).
Logical Operator Working ? 
-- Returns one of the operand.
1) OR Operator: a||b
    -- if a truth --> returns a, otherwise always b is returned.
2) And Operator: a && b
    -- If a and b both are truty, then b is returned else whichever is false is returned.

JS is static or Dynamic ?
-- JS is dynamic. type of variable is checked during run-time not compile time.
-- eg: let x =5; x= 'Sourav'; (Valid case for Dynamic language)

 NaN ?
 -- NaN -> Not a Number.
 -- type is Number. It falls under special. eg: 0/0 gives NaN.
 -- isNaN() -> checks if a number is NaN. It converts the arg to Number and then compares with NaN.
 -- eg: isNaN('anyString') --> true, isNaN(undefined) --> true,  isNaN(45) --> false, isNaN(true) --> false.

 pass by Value Or pass by Reference ?
 -- Premitive data-types are passed by value.
 eg: let x=5; let y=x; here, y points to a new location that copy's the value of x and put there. Changing x value wont effect y.
 -- Non-premitive data-types are passed by Reference.
 eg: let obj = {one:"1", two: "2"}; let obj1 = obj; here, obj1 is pointing at a refernce to obj. so Any change in Obj will be reflected in obj1.

 Immediatly invoked Functions (IIFE or pronounced as IIFY) ?
 -- function that runs as soon as it is declared.
 -- Syntax: (function () {console.log('Hoola');})();
 NOTE:
 -- The First set of () around the function tells it is not a function defination, it is a fucntion expression. 
 -- Without this bracket, it would throw error asking for function name not present.
 -- The second set of () executes the function immediately. else it just returns a defination.

NOTE: 
About EcmaScript ?
-- It is a standard for JS, and how it should be used. Js became ES standard in 1997 i.e ES1
-- Each Release of ES addes and standarise some new features of JS.
NOTE: ***Important Developements in ES***
-- ES5 --> strict mode is introduced.
-- ES6(2015) --> added let and const, Array.find() and Array.findIndex().
-- NOTE:
   -- All modern Browser fully supports ES6 standards.
-- After 2015, we have ECMAScript 2015 - ECMAScript 2020 (**latest**)

use Strict ? What and Why we use ?
-- It runs the JS in strict mode. Introduced in ES5.
-- "use Strict" --> add this line at the starting to enable strict mode.
-- features of Strict Mode JS:
   1) Duplicated declaration not allowed.
   2) cannot use JS keyword in funct name or param.
   3) Hoisting is not allowed i.e Intializing variable not allowed before defining it.

Higher Ordered Functions ?
-- Functions taking another funtions as parms or returning another function are called higher ordered function.
-- All Callback functions are higher order functions. eg: forEach,map,filter,reduce. 
-- Two Ways: 
1) Function as an input: eg: 

const eatFun = (foodFun) =>{
    foodFun();
    console.log('Function Digested !!');
}

eatFun(function(){
    console.log('Shit! I am going to be eaten');
});

2) returns a Function: eg:

const spitFun = ()=> {
    let a = 5;
    return function() {
        console.log(`So i am been spitted out with ${a}`);
    }
}

const newFun = spitFun();
newFun();

"this" keyword explain ?
-- "this" points to the object, the current function is a property of.
-- simply put, this is used to access the current object.
Note: The Catch here is, this behaves differntly under normal funtion and arrow function.
1) Noraml Function: "this" sees who is executing that function, it points to that.
2) Arraow functions: "this" sees where the fun is created. OR we can put like it looks for function keyword above it.
 -- If it finds that whoever executing that this points to the same.
 -- If not, It points to the global Object. In browser we have windows object.

eg: 
const testObj = {
    key1: "first key",
    key2: "second Key",
    fun1: function() {
        console.log(this);   //"function" keyword is used, so this points to current Obj.
        console.log('fun1 is executing !');
    },
    fun2: ()=>{
        console.log(this);  //no "function" is used, so this points to global.
        console.log('fun2 is executing !');
    },
    fun3: function() {
        setTimeout(()=>{
            console.log(this); //no function is used, but it is created inside a fun with "Function" keyword, so point to current Obj.
            console.log('fun3 is executing !');
        },3000);
    },
    fun4: function() {
        setTimeout(function () {
            console.log(this);   //"function" is used, so who is executing setTimeOut ? thus, this points to global Obj.
            console.log('fun4 is executing !');
        },3000);
    }
}

Tag LINE: Never use "this" and arrow function together !!! **Important**

Self Invoking Function ?
-- functions invokes themselves automatically without calling them.
-- eg: immediately invoked Function i.e IIFY.

NOTE: What are rest param ?
-- noraml fucntions have params syntax eg: ...msg
-- Means no matter how many arguments you pass in the function during call time, all are pushed in an array called msg.
eg: const example = function(...msg) {
    console.log(msg);  //msg -> ['sourav', 45, 'hi']
}
example('sourav', 45, 'hi');

call(), apply() and bind() ? What and Why ?
-- All are methods for functions.
1) call() 
  -- it invokes function taking obj as a param. syntax: funName.call(obj);
  -- use: 
  1) When function is not a part of obj but it want to access the obj params.
  2) Obj can access functions of another Obj.
  eg: obj.sayHi.call(newObj, 'BeautifulDay')
  Note: obj and newObj are different obj. obj has sayHi fun but newObj dont.
  3) it takes param also, first obj and then any params you pass.(**Implementation of REST Param, i.e ...argv --> takes all the passed argv in the list)
eg: 
const add = function (msg) {
    console.log(`Hello amigoo ${this.name} and msg: ${msg}`);
}
let obj = {name: "sourav"};
add.call(obj, "call function done")

2) apply()
  -- similar as call() method.
  -- Difference: It takes arguments as an array.
eg: oldObj.fun.apply(newObj, ["sayThisMsg"]);

3) bind()
  -- returns a new function, where this belongs to the obj which is passed in the param.
  -- "this" keyword in function will point to the newly passed param Obj.
  -- bind() wont execute immediately unlike call and apply. It will wait untill the new function is called.
eg:
const newFun = oldObj.fun.bind(newObj, 'someMsg');
newFun();

Why we needed bind ?
1) To manage the scope of 'this' when handling with callbacks.
  -- you have one myObj, with method sayHello() {console.log(this)};  Here this point to myObj.
  -- now you took refernece to this method: const newFun = myObj.sayHello;
  -- When you pass newFun to any callback, 'this' points to global scope thus a problem.
  -- solution: bind the method with obj before passing. const newFun = sayHello.bind(myObj); Thus the 'this' still points to myObj.

2) To Borrow fun from other methods.
  -- you have obj1 with fly() and obj2 with run().
  -- If you want obj2 also to have run() eg: const newFly = obj1.fly.bind(obj2); newFly();

exec() vs test()
  -- Both are RegExp methods in JS.
exec() -> Test against the match. Returns the index of First matched char. If not matched return null.
test() -> Test against the match. Return boolean. True/False. 
eg: text = 'sourav is good'; 
const res = /good/.exec(text);  //['good', index: 10] NOTE: Index of the first character matching.
const res = /good/.test(text);  //return true.

Currying in JS ?
  -- advanced tech to convert functions with n params to n functions with one or more param.
  -- basically Converts fun(a,b) to fun(a)(b);
  -- Functionality Remain same but the way it's invoke is different.
eg: Modifying noraml sum function into currySum:
const currySum = function(a) {
    return function(b) {
        return a+b;
    }
}
currySum(5)(4);  //returns 9.
    
SCope and Scope chains ? 
  -- Role of scope: DEfines boundaries for variables and functions.
3 types: 
  1) Global  --> accessable to all functions. 
  2) local or Function Scope --> local to the function where it is defined.
  3) block Scope -> variable defined with { and } brases.

Scope Chaining: (***Very important***)
  -- JS engine Follow a method to find the variable, not declared in the scope.
  -- If x used in nested function, but not declared.
     then, It will look for x in parent function. If not found
     then, it will go to global scope to find the declaration for the variable x.
If still not found in the global scope, It throws refernce error, means it not able to identify x.

closure in JS ? (***V.IMP***)
  -- Ability of a fucntion to Remeber any variables declared in it's Outer scope.
  -- Basically, From a funA, when you retrun a function using the local Variable of function A.
  -- After funA completes, It gets destroyed but the local Variable data is saved in memory for further use. [This is closure]
NOTE:
  -- Closure is implemented when a func returns a function with a local variable, Thus, That local variable is accessable outside the scope.
  -- Closure logic is used while caching the data, in Memorization tech.
eg:
const myFun = () => {
    let obj1 = {
        name: "sourav",
        age: 25
    }
    return function() {
        console.log(obj1);
    }
}

const newFun = myFun();
console.log(obj1);  //This will fail, 
newFun(); //This has still access to obj1

Object Prototypes ?
  -- This are basically Blueprint of any Object in JavaScript.
  -- we have Object.prototype, That has property and methods for all the Prototypes supported in JS.
eg of few Prototypes, Date prototype, Math prototype, Array prototype, Object prototype.
Why we need it ?
  -- It gives access to a wide range of methods on an Object, Even if that Object doesn't contains the declaration of that method.
  -- Code reusability.
  -- As we declare our data-Type, Js Engine will attach proper prototype based on the type of Data defined.
NOTE:
When you call a method for an Object,
  -- First it checks if method declared in the Object declaration ? If NOt...
  -- Then it looks for the defination in its protoype ? If not..
  -- then it looks into Object's prototype ? If not..
  -- then it throws error.

Callbacks in JavaScript ?
  -- Functions that are used as arguments to another funtions are called as callbacks.
use ? 
  -- They are used in nested synchronous function structure, It will be executed after another function done executed.
eg:
const productNum = (a, b) => a*b;
const findSumProd = (x,y, callBack)=>{
    let sum = x+y;
    return callBack(sum, 6);
}

const ans = findSumProd(5,6, productNum);
console.log(ans);

Types of Error in JS ?
1) Syntax Error
  -- Cause the Program to crash. Mainly due to misspelling of keywords and identifiers.
2) Logical Error
  -- All Syntax is proper, but the logic of Prog is incorrect.

Memorizations ?
  -- Caching Technique, If parameter passed doesnot change then the value is returned form cache instead of computing all over again.
  -- This makes processing faster for time-consuming functions.
NOTE: This tech is only used for expensive fun calls, expensive -> funs that consumes lot of time in processing.
How to Do ?
  -- Define a Object, cache, use the closure logic to make cache accessable outside the function.
  -- Inside the function, Check if the cache all ready have the value for the param passed ? IF yes, return from cache.
  -- If not ? Store in cache and return it.
Drawback of Caching ?
  -- It saves time in expensive function, but it consumes extra space.
eg:
const increment = () => {
    let cache = {};
    
    return function(data) {
        for(let keys in cache) {
            if(keys == data) {
                console.log('returning from Cache date');
                return cache[data];
            }
        }
        cache[data] = data+10;
        console.log('Not from the cache');
        return cache[data];
    }
}

const fun1 = increment();
console.log(fun1(10));  //this will return not from the cache data.
console.log(fun1(10));  //this will return from the cache data.

Recursion in JS ?
  -- A function calling itself. [Recursion]
  -- Always includes one baseCase or exist condition.
eg:
const findArrSum = function (arr, index=0) {
    //basecondition
    if(index == arr.length-1) return arr[index];
    
    return arr[index] + findArrSum(arr, index+1);
}

console.log(findArrSum([1,2,3,4,5,6]));

*********************************************************************
NOTE: While submitting code in Compiler during problem Solving...
1) To accept the input from the user, const input = parseInt(readLine());
2) then write the function. fn(param) {...}
3) To print the ouput for the give input, console.log(fn(input));
*********************************************************************

Constructors in JS ?
  -- This are invokes when a object is created using new keyword.
  -- Constructor Should always starts with Caps.
  -- If defined inside a class, Both names should match.
eg:
const MyInfo = function(name, age, place) {
    this.name = name;
    this.age = age;
    this.place = place;
}

const newObj = new MyInfo('souav', 34, 'chennai'); // we can create many Objects using the constructor.
console.log(newObj);
console.log('My name is: ',newObj.name);
const newObj2 = new MyInfo('bob', 23, 'UK'); //new object is create using constructor.

Client Side JS Vs Server Side JS ?

Client Side JS
    -- Have access to Special Objects like DOM -> Access to all the webpage elements.
    -- Have access to Browser Object Model(BOM) i.e windows object. --> provide functionality like setTimeInterval, prompt etc.
    -- Runs on the Browser Engine, Is designed to handle the Client side web-page Animations and manipulation.
Server-side JS:
    -- Node Js -> Js platform runs outside browser.
    -- Independent of any browser platform. Runs outside of browser.
    -- No access to Windows or dom elements.
    -- Have access to npm packages, That manage various open-source package for server side development and database integration. eg: express and mongoose.
    -- Mostly focused on REST API Creatio and managing server-side scripting.

DOM ?
  -- Document Object Model. A programming interface to HTML and XML documents.
  -- brower creates DOM Objects when it trys to Render the HTML files.
  -- In the browser, DOM enables to manipulate HTML Pages using Js.
Also, Provides DOM events, That can trigger the code listener function, when a particular action is performed with HTML elements.
NOTE: Most of the animations in the client side, includes DOM that binds HTML with JS.

BOM ?
  -- Browser Object Model. i.e The Window Object available in the browser.
  -- a huge list of property and methods for the current page.
  -- Contains tones of functionality for browser related work, has access to methods like setTimeOut, propmpt and many more.
  -- document, screen, naviagator, location and other attributes are avialble in BOM.


NOTEs TO DO: 
  -- On Feature wise on ES
  -- Working of EventLoop [Preference among promise ALL and setTimeout]
  -- Other advance Concepts. 
  -- SOLID Design principle with example.


**Experience Knowledge on JS**



























