***NOTES On Important Interview concepts For JS***

-- Js came out around 1995. By - Brendan Eich
-- Js is OOPs compliant and Works on Both Client and server side. Server-Side Js is called Node JS

**Basic Knowledge on JS**

Data Types ?
* Primitive: string, number, bigInt, boolean, undefined, null and symbol.
NOTE:
    -- 3 or 3.5 both are handled by Number type.
    -- BigInt can hold huge number eg: let c = 3453656n; It ends with n suffix.
    -- undefined: Value declared but not assigned.
    -- null: Doesnot exist.
    -- Symbol: newly added in ES6 of JS. stores anonymous and unique values. eg: let s = symbol('hi');
* Non-Primitive: Arrays and Objects.

NOTE:
  -- string is immutable in JS --> Once the value is initialize, You cannot modify it again.
  -- eg: let newStr = 'Hello';
         newStr[0] = 'k'; //No errors here...
         console.log(newStr);  //Hello  --> i.e No Change in the original value.
  -- Additionally, String methods are concat(), slice() etc will create and return a new string instead of modifying the original string value.
  -- thus, immutability.

Hoisting ? 
-- variable and function Declaration moves to the top of the scope. Scope can be both local and global
-- This behavior is strictly for declaration only. Intializing won't be hoisted. **Imp**
-- Its JS default's Behaviour and can be stopped by adding this at the top "use strict".
  eg: "use strict";
      x = 10; 
    - the above throws error as x is not defined.
    - But if you remove "use strict" ---> It doesnot throw error.

NOTE:
  x = 10;
  -> The above variable if defined outside of any function or block scope -> is stored in global/window scope.

NOTE: 
  Hoisting Differences between var, let and const ?
  1) var: The Variable decalration is hoisted with a default initialization of `undefined`., means you can access the variable before defining it -> function or global scope.
  2) let: Block scope, The variable is hoiseted with no initialization thus JS knows about the variable, but it will throw a REference Error saying, cannot access the variable before initialization.
  3) Const: Same as let, Value once initialized is fixed.

NOTE:
  Temporal Dead Zone [TDZ] **IMP
    -- This is involved with the use of keyword 'let' and 'const';
    -- In it's scope, TDZ is the time till which the variable is not defined and You are trying to access it. --> thorws Refernce Error.
    -- eg:
      //let and const are blocked scope..
        { 
          //TDZ starts at the start of the scope..

          console.log(myVar); //Reference Error i.e cannot access my var before Initialization.

          let myVar = 5; //TDZ ends here, once it's defined and initialized

          console.log(myVar); //5
        }

== vs === ?
-- == will just check the value. Interanlly It converts both them to String and then checkes the value.
-- === will check both typeOf and the value.

var Vs let ?
-- let came around 2015. Let is block Scoped i.e let can be accessed anywhere between '{' ans '}'
-- Var is function scoped. var can be accessed anywhere inside a function.
Note: 
var vs Let vs Const ?
-- Two Scopes: 
   1) Block Scope eg: scope of if..else 
   2) function Scope eg: funct() {...}
-- Var is bounded by the scope of the function. Let and const are blocked scoped.
Within a given scope:
-- Redeclaration of var is allowed but for let and const not allowed. 
-- Var is hoisted with undefined. But let and const hoisted with no Intialization.(throw error).

implicit type coercion ?
-- Automatic Conversion of Value from one data Type to another.(while using +,-, ||, && or ==).
-- '+' convert both operands to String and then concat them.
-- '-' convert both operands to Number and then subtract them. 
-- '===' converts both sides to same type i.e string before comparing.

NOTE: Boolean Coercion:
-- Falsy: null, 0, 0n, -0, undefined, false, "" and NaN are falsey. REst are all are truthy. (**Imp**).
Logical Operator Working ? 
-- Returns one of the operand.
1) OR Operator: a||b
    -- if a truth --> returns a, otherwise always b is returned.
2) And Operator: a && b
    -- If a and b both are truty, then b is returned else whichever is false is returned.

JS is static or Dynamic ?
-- JS is dynamic. type of variable is checked during run-time not compile time.
-- eg: let x =5; x= 'Sourav'; (Valid case for Dynamic language)

 NaN ?
 -- NaN -> Not a Number.
 -- type is Number. It falls under special. eg: 0/0 gives NaN.
 -- isNaN() -> checks if a number is NaN. It converts the arg to Number and then compares with NaN.
 -- eg: isNaN('anyString') --> true, isNaN(undefined) --> true,  isNaN(45) --> false, isNaN(true) --> false.

 pass by Value Or pass by Reference ?
 -- Premitive data-types are passed by value.
 eg: let x=5; let y=x; here, y points to a new location that copy's the value of x and put there. Changing x value wont effect y.
 -- Non-premitive data-types are passed by Reference.
 eg: let obj = {one:"1", two: "2"}; let obj1 = obj; here, obj1 is pointing at a refernce to obj. so Any change in Obj will be reflected in obj1.

NOTE: 
  1. shallow copy: [copy only the parent keys of the obj, nested keys are still taken as reference] --> 2 ways -> Object.assign({}. obj1), {...obj1};
  2. Deep copy: [copy the whole Obj and newly create a object, no references] -> 1 way -> JSON.parse(JSON.stringify(obj1))


 Immediatly invoked Functions (IIFE or pronounced as IIFY) ?
 -- function that runs as soon as it is declared.
 -- Syntax: (function () {console.log('Hoola');})();
 NOTE:
 -- The First set of () around the function tells it is not a function defination, it is a fucntion expression. 
 -- Without this bracket, it would throw error asking for function name not present.
 -- The second set of () executes the function immediately. else it just returns a defination.

NOTE: 
About EcmaScript ?
-- It is a standard for JS, and how it should be used. Js became ES standard in 1997 i.e ES1
-- Each Release of ES adds and standarise some new features of JS.
NOTE: ***Important Developements in ES***
-- ES5 --> strict mode is introduced.
-- ES6(2015) --> added let and const, Array.find() and Array.findIndex().
-- NOTE:
   -- All modern Browser fully supports ES6 standards.
-- After 2015, we have ECMAScript 2015 - ECMAScript 2020 (**latest**)

use Strict ? What and Why we use ?
-- It runs the JS in strict mode. Introduced in ES5.
-- "use Strict" --> add this line at the starting to enable strict mode.
-- features of Strict Mode JS:
   1) Duplicated declaration not allowed.
   2) cannot use JS keyword in funct name or param.
   3) Hoisting is not allowed i.e Intializing variable not allowed before defining it.

eg: 
  1. If a function takes param1, param2, param1.
    In non-strict mode --> param1 will take whatever passed in the 3rd paramter in the call.
    In strict mode --> duplicate parameters are not allowed.


Higher Ordered Functions ?
-- Functions taking another funtions as parms or returning another function are called higher ordered function.
-- All Callback functions are higher order functions. eg: forEach,map,filter,reduce. 
-- Two Ways: 
1) Function as an input: eg: 

const eatFun = (foodFun) =>{
    foodFun();
    console.log('Function Digested !!');
}

eatFun(function(){
    console.log('Shit! I am going to be eaten');
});

2) returns a Function: eg: [closure example]

const spitFun = ()=> {
    let a = 5;
    return function() {
        console.log(`So i am been spitted out with ${a}`);
    }
}

const newFun = spitFun();
newFun();


### "this" keyword explain ? [** V.IMP **]
-- "this" points to the object, the current function is a property of.
-- simply put, this is used to access the current object.
Note: The Catch here is, this behaves differntly under normal funtion and arrow function.
1) Noraml Function: "this" sees who is executing that function, it points to that.
2) Arraow functions: "this" sees where the fun is created. OR we can put like it looks for function keyword above it.
 -- If it finds that whoever executing that "this" points to the same.
 -- If not, It points to the global Object. In browser we have windows object.

eg: 
const testObj = {
    key1: "first key",
    key2: "second Key",
    fun1: function() {
        console.log(this);   //"function" keyword is used, so this points to current Obj.
        console.log('fun1 is executing !');
    },
    fun2: ()=>{
        console.log(this);  //no "function" is used, so this points to global.
        console.log('fun2 is executing !');
    },
    fun3: function() {
        setTimeout(()=>{
            console.log(this); //no function is used, but it is created inside a fun with "Function" keyword, so point to current Obj.
            console.log('fun3 is executing !');
        },3000);
    },
    fun4: function() {
        setTimeout(function () {
            console.log(this);   //"function" is used, so who is executing setTimeOut ? thus, this points to global Obj.
            console.log('fun4 is executing !');
        },3000);
    }
}

Tag LINE: Never use "this" and arrow function together !!! **Important**
Remember:
  -- We can use Arrow Fucntion/ normal Fucntions as we want, In Our global scope. => It doesn't matter, this points to global.
  -- Always use Function keyword inside an Obj => If you use this, it will point to current obj.
  -- Never user Arrow Function for Function defination, Inside an Object, It will always points to Global Scope bydefault.

Self Invoking Function ?
-- functions invokes themselves automatically without calling them.
-- eg: immediately invoked Function i.e IIFY.

NOTE: What are rest param ?
-- noraml fucntions have params syntax eg: ...msg
-- Means no matter how many arguments you pass in the function during call time, all are pushed in an array called msg.
eg: const example = function(...msg) {
    console.log(msg);  //msg -> ['sourav', 45, 'hi']
}
example('sourav', 45, 'hi');

call(), apply() and bind() ? What and Why ?
-- All are methods for functions.
1) call() 
  -- it invokes function taking obj as a param. syntax: funName.call(obj);
  -- use: 
  1) When function is not a part of obj but it want to access the obj params.
  2) Obj can access functions of another Obj.
  eg: obj.sayHi.call(newObj, 'BeautifulDay')
  Note: obj and newObj are different obj. obj has sayHi fun but newObj dont.
  3) it takes param also, first obj and then any params you pass.(**Implementation of REST Param, i.e ...argv --> takes all the passed argv in the list)
eg: 
const add = function (msg) {
    console.log(`Hello amigoo ${this.name} and msg: ${msg}`);
}
let obj = {name: "sourav"};
add.call(obj, "call function done")

2) apply()
  -- similar as call() method.
  -- Difference: It takes arguments as an array.
eg: oldObj.fun.apply(newObj, ["sayThisMsg"]);

3) bind()
  -- returns a new function, where this belongs to the obj which is passed in the param.
  -- "this" keyword in function will point to the newly passed param Obj.
  -- bind() wont execute immediately unlike call and apply. It will wait untill the new function is called.
eg:
const newFun = oldObj.fun.bind(newObj, 'someMsg');
newFun();

Why we needed bind ?
1) To manage the scope of 'this' when handling with callbacks.
  -- you have one myObj, with method sayHello() {console.log(this)};  Here this point to myObj.
  -- now you took refernece to this method: const newFun = myObj.sayHello;
  -- When you pass newFun to any callback, 'this' points to global scope thus a problem.
  -- solution: bind the method with obj before passing. const newFun = sayHello.bind(myObj); Thus the 'this' still points to myObj.

2) To Borrow fun from other methods.
  -- you have obj1 with fly() and obj2 with run().
  -- If you want obj2 also to have run() eg: const newFly = obj1.fly.bind(obj2); newFly();

exec() vs test()
  -- Both are RegExp methods in JS.
exec() -> Test against the match. Returns the index of First matched char. If not matched return null.
test() -> Test against the match. Return boolean. True/False. 
eg: text = 'sourav is good'; 
const res = /good/.exec(text);  //['good', index: 10] NOTE: Index of the first character matching.
const res = /good/.test(text);  //return true.

Currying in JS ?
  -- advanced tech to convert functions with n params to n functions with one or more param.
  -- basically Converts fun(a,b) to fun(a)(b);
  -- Functionality Remain same but the way it's invoke is different.
eg: Modifying noraml sum function into currySum:
const currySum = function(a) {
    return function(b) {
        return a+b;
    }
}
currySum(5)(4);  //returns 9.

NOTE: Basically, a simple function [with Params] can be converted to a higher order function.
    
SCope and Scope chains ? 
  -- Role of scope: DEfines boundaries for variables and functions.
3 types: 
  1) Global  --> accessable to all functions. 
  2) local or Function Scope --> local to the function where it is defined.
  3) block Scope -> variable defined with { and } brases.

Scope Chaining: (***Very important***)
  -- JS engine Follow a method to find the variable, not declared in the scope.
  -- If x used in nested function, but not declared.
     then, It will look for x in parent function. If not found
     then, it will go to global scope to find the declaration for the variable x.
If still not found in the global scope, It throws refernce error, means it not able to identify x.

closure in JS ? (***V.IMP***)
  -- Ability of a fucntion to Remeber any variables declared in it's Outer scope.
  -- Basically, From a funA, when you retrun a function using the local Variable of function A.
  -- After funA completes, It gets destroyed but the local Variable data is saved in memory for further use. [This is closure]
NOTE:
  -- Closure is implemented when a func returns a function with a local variable, Thus, That local variable is accessable outside the scope.
  -- Closure logic is used while caching the data, in Memorization tech.
eg:
const myFun = () => {
    let obj1 = {
        name: "sourav",
        age: 25
    }
    return function() {
        console.log(obj1);
    }
}

const newFun = myFun();
console.log(obj1);  //This will fail, 
newFun(); //This has still access to obj1

Object Prototypes ?
  -- This are basically Blueprint of any Object in JavaScript.
  -- we have Object.prototype, That has property and methods for all the Prototypes supported in JS.
eg of few Prototypes, Date prototype, Math prototype, Array prototype, Object prototype.
Why we need it ?
  -- It gives access to a wide range of methods on an Object, Even if that Object doesn't contains the declaration of that method.
  -- Code reusability.
  -- As we declare our data-Type, Js Engine will attach proper prototype based on the type of Data defined.
NOTE:
When you call a method for an Object,
  -- First it checks if method declared in the Object declaration ? If NOt...
  -- Then it looks for the defination in its protoype ? If not..
  -- then it looks into Object's prototype ? If not..
  -- then it throws error.

Callbacks in JavaScript ?
  -- Functions that are used as arguments to another funtions are called as callbacks.
use ? 
  -- They are used in nested synchronous function structure, It will be executed after another function done executed.
eg:
const productNum = (a, b) => a*b;
const findSumProd = (x,y, callBack)=>{
    let sum = x+y;
    return callBack(sum, 6);
}

const ans = findSumProd(5,6, productNum);
console.log(ans);

Types of Error in JS ?
1) Syntax Error
  -- Cause the Program to crash. Mainly due to misspelling of keywords and identifiers.
2) Logical Error
  -- All Syntax is proper, but the logic of Prog is incorrect.

Memorizations ?
  -- Caching Technique, If parameter passed doesnot change then the value is returned form cache instead of computing all over again.
  -- This makes processing faster for time-consuming functions.
NOTE: This tech is only used for expensive fun calls, expensive -> funs that consumes lot of time in processing.
How to Do ?
  -- Define a Object, cache, use the closure logic to make cache accessable outside the function.
  -- Inside the function, Check if the cache all ready have the value for the param passed ? IF yes, return from cache.
  -- If not ? Store in cache and return it.
Drawback of Caching ?
  -- It saves time in expensive function, but it consumes extra space.
eg:
const increment = () => {
    let cache = {};
    
    return function(data) {
        for(let keys in cache) {
            if(keys == data) {
                console.log('returning from Cache date');
                return cache[data];
            }
        }
        cache[data] = data+10;
        console.log('Not from the cache');
        return cache[data];
    }
}

const fun1 = increment();
console.log(fun1(10));  //this will return not from the cache data.
console.log(fun1(10));  //this will return from the cache data.

Recursion in JS ?
  -- A function calling itself. [Recursion]
  -- Always includes one baseCase or exist condition.
eg:
const findArrSum = function (arr, index=0) {
    //basecondition
    if(index == arr.length-1) return arr[index];
    
    return arr[index] + findArrSum(arr, index+1);
}

console.log(findArrSum([1,2,3,4,5,6]));

*********************************************************************
NOTE: While submitting code in Compiler during problem Solving...
1) To accept the input from the user, const input = parseInt(readLine());
2) then write the function. fn(param) {...}
3) To print the ouput for the give input, console.log(fn(input));
*********************************************************************

Constructors in JS ?
  -- This are invokes when a object is created using new keyword.
  -- Constructor Should always starts with Caps.
  -- If defined inside a class, Both names should match.
eg:
const MyInfo = function(name, age, place) {
    this.name = name;
    this.age = age;
    this.place = place;
}

const newObj = new MyInfo('souav', 34, 'chennai'); // we can create many Objects using the constructor.
console.log(newObj);
console.log('My name is: ',newObj.name);
const newObj2 = new MyInfo('bob', 23, 'UK'); //new object is create using constructor.

Client Side JS Vs Server Side JS ?

Client Side JS
    -- Have access to Special Objects like DOM -> Access to all the webpage elements.
    -- Have access to Browser Object Model(BOM) i.e windows object. --> provide functionality like setTimeInterval, prompt etc.
    -- Runs on the Browser Engine, Is designed to handle the Client side web-page Animations and manipulation.
Server-side JS:
    -- Node Js -> Js platform runs outside browser.
    -- Independent of any browser platform. Runs outside of browser.
    -- No access to Windows or dom elements.
    -- Have access to npm packages, That manage various open-source package for server side development and database integration. eg: express and mongoose.
    -- Mostly focused on REST API Creation and managing server-side scripting.

DOM ?
  -- Document Object Model. A programming interface to HTML and XML documents.
  -- brower creates DOM Objects when it trys to Render the HTML files.
  -- In the browser, DOM enables to manipulate HTML Pages using Js.
Also, Provides DOM events, That can trigger the code listener function, when a particular action is performed with HTML elements.
NOTE: Most of the animations in the client side, includes DOM that binds HTML with JS.

BOM ?
  -- Browser Object Model. i.e The Window Object available in the browser.
  -- a huge list of property and methods for the current page.
  -- Contains tones of functionality for browser related work, has access to methods like setTimeOut, propmpt and many more.
  -- document, screen, naviagator, location and other attributes are avialble in BOM.


NOTE:
  lexical scope --> the place where the function is defined.
  eg: For arraw fun, they dont have their own 'this'. They inherit from their lexical scope, where the function is defined.




** Experience Knowledge on JS**

Why we need Arrow Functions When we have noraml Functions ? 

  -- Following Reasons:
      1. Lexical this Binding: Arrow functions inherit this from the surrounding scope, avoiding common pitfalls with the this keyword.
      2. Shorter Syntax: Arrow functions provide a concise syntax, making code cleaner and easier to read.
      3. Implicit Return: For single-expression functions, arrow functions allow omitting the return keyword.
      4. No arguments Binding: Arrow functions do not have their own arguments object, reducing potential confusion.
      5. Predictable Behavior: Arrow functions make handling the this context more predictable in certain situations, like callbacks and event handlers.



"arguments" keyword in JS ?

  -- It holds the arguments passed to a function, If the arguments are updated, This also will update.
  -- NOTE: One way, to prevent this is to use "use strict" inside the function.
  -- eg: 
          function test(x, y) {
            console.log(arguments[0], arguments[1]);  // Prints 1, 2
          }

          test(1, 2);
NOTE:
  -- arguments keyword doesnot work with Arrow Fucntions.
  -- arguments will follow the input to the functions. any change in arguments will reflect in the input params.
  -- But any change in the input params will not effect the arguments, --> It always carries the values when the control enters the function.
  -- "use strict" to disable "arguments"



Debouncing and Thorttling Concept in JavaScript: [ Optimise Event Handling ]
  
  -- Debouncing:
      - useCase:
          -- In SerachBox, If we make service call to backend on every KeyDown, It will make a lot of unneccessary calls.
              Solution: In Debouncing, When the user stops typing, Then we make the service call to the backend.
      - Defination:
          -- Debouncing, limits the rate of execution of a function and waits for a certain amount of time before exectuting it again.


  -- Thorttling:
    - useCase:
        -- In Scrolling action, When we reach a particular point, In backend we make service call to fetch new data. 
        -- This gives an infinite scrolling effect.
    - Defination:
        -- Thorttling, a teqnique to limit the execution of a event handler function, Even though the event is constantly getting triggered due to user action.
        -- In above Context, scrolling is the event, And we limit it untill we reach a certain point in the scroll bar.

  -- Libraries that has debounce and thorttle functions:
      - library name: lodash [Add as cdn or use npm]
      - For debouncing: const handleDebounce = _.debounce(()=> {}, delay); -->  Put the handleDebounce in the event handling function.
      - For Thorttling: const handleThrottle = _.throttle(()=> {}, delay); -->  Put the handleThrottle in the event handling function.

  NOTE: Diff between Debouncing and Thorttling  
    -- Notice, Debouncing delays the execution of a function like API service call untill the specified time. [OnSearch Functionality]
      But, Thorttling limits the execution of the event handler function itself, till the sepecified time. --> [Infinite Scrolling event]


*** IMP ***
  -- While using debouncing in React, Never !!! Neever use the state variables inside debounce to make service call or any actions.
  -- This gives rise to redunduncy because of the Re-renders and how colsures and Async state updates works in React.
  -- Solution: 
      -- Pass the payload for service call in params.
      -- InputField --> OnChangeEventHandler [update the field state and call debouceCallback method along with new FieldValue i.e e.target.value] 
      --> then call the function That do useCallback of the debounce method pass the params[ preseve the state during re-renders]
      --> then call the accutal debounse method [library: lodash] [use the paramaters to preapre the paylod]



Wrapper Objects in JS ?
  -- Wrapper Objects are built-in JS Objects ---> provides additional methods and functionality to existing primitive values.
  -- example of Wrapper class that wraps primitive data-types:
    1. String: 
          let newStr = new String("sourav"); 
          typeof newStr --> Object 
    2. Number
          let newNumber = new Number(45);
          typeof newNumber --> Object
    3. Boolean
          let newBool = new Boolean(45);
          typeof newBool --> Object
    4. BigInt
          let newBigint = new Object(123n);
          typeof newBigint --> Object
    5. Object
          let obj = {};
          let newObj

  -- There are others built-In objects which are not wrapper but provides additional Functionaility
    1. funtion
       let newFun = new Function('return 43;');
    *2. Array
        let newArr = new Array(1, 2, 3, 5);
    3. Regrex
        let newRegrex = new Regrex('\\d+');
    *4. Date
        let newDate = new Date();
        newDate --> A Current Date instance. [Methods are available to extract, days, month, year etc]
    *5. Error
        let errmsg = new Error('Something went Wrong');
        typeof errmsg --> Object.

  NOTE: Is it wise to use wrapper Objects Or primitive data-Types in Js ?
    -- Wrapper objects are usually very rarely used in actual programming.
    -- Reasons:
        1) All methods provided by wrapper Objects are already available to premitive types.
        2) Wrapper Objects sometimes behaive in weird manner.
          eg: 
            if('sourav ') ---> Returns True,  if(new String('')) ---> Also returns True [ideally, for '' is should be false]
        3) They introduce unneccessary perfromance Overhead and complexity compared to primitive strings.


EventLoop Explaination: 
  -- JS is a single threaded Language i.e Only one call stack to manage the execution of the whole code.
  
  -- Issue:
      - If we have any long running task in our code i.e a huge loop or a network call etc will take some time to execeute.
      - If executed synchronous, The Thread will be blocked and the code below needs to wait.
      - This slows down the efficiency and performance of the coding language.
    Solution:
      - Browser provides webApis i.e an interfaces to interact with the browser's features.
      - These APIs are responsible for handling heavy stuff by interacting with the browser.
      - eg: fetch, DOM, Timers, Console, Geolocation, web storages [local and session storage], Handle Files etc.
      - Some of these web APIs, enables offloading the task to the browser.
        - i.e it offloads the task from callstack and give it to the browser to handle.
      
      NOTE: Most of these webAPIs, which expose offloading are either callback based or Promise based. 
  
  -- Components Involved in the JS RunTime for handling Async Task in a non-blocking way in JS:
      1. JS Engine:
          - Heap 
          - CallStack [Stack the Execution of Js Code Script one by one]
      2. EventLoop [Checks if the callstack is empty, If empty it moves the Tasks from Task queue or Micro Task Queue into CallStack]
      3. Web Apis
      4. Task Queue [Also called Callback Queue, holds callbacks] and MicroTask Queue [Holds promises]
  
  -- Task Queue or Callback Queue Handles --> setTimeOut, SetInterval, Geolocation, eventListener or any webAPI with callback.
  -- MicroTask Queue Handles --> .then(), .catch(), .finally(), the function after await keyword or queueMicrotask(()=> {}). 
  
  NOTE: [** IMP **]
    -- Event Loop prioritise the MicroTask queue and then Task Queue.
    -- i.e Event Loop first check if microTask queue is empty --> then only it moves to TaskQueue.
    -- After Moving each Task From Task Queue, it checks microTaskQueue 
        --> If Empty, It moves the next Task From Task queue.
        --> If Not, It first moves all the Tasks from MicroTask Queue to callstack and then move the Task From TaskQueue. 
  
  -- example: 
    1. Let see the execution of callback Based Task:  
        SetTimeOut(() => console.log('Done'), 500); 
      
      -- first SetTimeOut Goes to callStack.
      -- As it is a webAPI with callback, It will be immediately offloaded from the callstack and moved given to browser to handle.
      -- The callstack will process other Tasks.
      -- After 500ms, The Result is moved to Task Queue, Where it Waits.
      -- Now, Event Loop waits till the callStack is empty, once empty It moves the callback function to callStack.
          NOTE: 
          -- If CallStack is not empty, Event Loop will still wait, untill it is empty and then only, the callback function moves from Task queue --> callStack.

    2. Let see the exectution of Promise based Task: 
        fetch('some url')
          .then(resp => console.log(resp));
      
      -- first fetch goes to the callstack --> This returns a promise object with status as pending. --> Also Initiate the network call by the browser.
      -- Then .then goes to callstack --> It will be offloaded and handled by the browser.
      -- Then Other tasks will loaded and executed in the callstack.
      -- Once we received the response, The Function will be stacked in microTask queue.
      -- Now, Event Loop waits, Till the call stack is empty --> Then loads the function to the callStack.
      NOTE:
        If you have any callbacks Functions waiting at Task Queue, It has to Wait till microTask Queue is empty.


** Swallow copy Vs Deep Copy of Objects ?
  1. Swallow copy:
    -- eg: let obj1 ==> Exists which holds 2 strings and a deep nested Object.
    -- Now, You do, let obj2 = {...obj1};
    -- It will spread the keys of obj1 in Obj2 where obj1 and obj2 hold 2 different references in the memory.
    -- Interestingly,
       -- When the nested object of obj1 is spread, Obj2 and obj1 points to the same reference.
       -- i.e If you change something in nested object with obj2, It will be for sure reflect in obj1.

  2. Deep copy:
    -- This method suggest a copy in such a way that Obj1 and obj2 are totally 2 different reference in the memory.
    -- eg: let jsonString = JSON.stringify(obj1);
           let obj2 = JSON.parse(jsonString);
    -- This method,
       -- Prevent swallow copy of nested object and obj1 and obj2 are toally 2 different reference.
        

####### Revision and Notes for Important Topics in JS #############


** Core JavaScipt COncepts ** 

1. Variables and Scoping
2. var, let, const
3. Hoisting
4. Data Types and Structures
5. Temporal Dead Zone
6. Primitive vs. reference types
7. Arrays and objects
8. Type coercion and type checking
9. Functions
10. Function declarations vs. expressions
11. Arrow functions
12. Closures
13. IIFE (Immediately Invoked Function Expressions)
14. Higher-order functions
15. Asynchronous JavaScript
16. Callbacks
17. Promises
18. async/await
19. Event loop and microtasks/macrotasks
20. Object-Oriented Programming (OOP)
21. Prototypal inheritance
22. ES6 classes
23. this keyword, call, apply, bind
24. Functional Programming
25. Pure functions
26. Immutability
27. Function composition
28. Array methods (map, filter, reduce)



** Advance Javascript
		Event Handling
		Event listeners
		Event propagation (bubbling and capturing)
		Event delegation
		Error Handling
		try, catch, finally
		Custom errors
		JavaScript Engine and Runtime
		V8 Engine
		Just-In-Time (JIT) compilation
		Memory management
		Modules
		ES6 modules (import/export)
		CommonJS
		Advanced Data Structures
		Sets and Maps
		WeakSet and WeakMap
		Design Patterns
		Singleton
		Factory
		Module
		Observer
		Concurrency and Parallelism
		Web Workers
		Service Workers

** Frontend-Specific Topics
		DOM Manipulation
		Selecting elements
		Modifying elements
		Event handling
		Web APIs
		try, catch, finally
		Custom errors
		JavaScript Engine and Runtime
		Fetch API
		WebSockets
		LocalStorage, SessionStorage, and IndexedDB
		Navigator API
		Frameworks/Libraries
		React (hooks, lifecycle methods, state management)
		Angular (directives, services, dependency injection)
		Vue.js (reactivity, components, Vuex)
		Performance Optimization
		Debouncing and throttling
		Lazy loading
		Code splitting
		
** Best Practices
		Code Quality
		Clean code principles
		Code reviews
		Refactoring
		Security
		XSS, CSRF
		CORS
		Secure coding practices
		Accessibility
		ARIA roles
		Semantic HTML



Important Notes:
  -- TDZ [Temporal dead zone]: the time between variable declared and initialization when let or const exist but cannot be access.
    eg: console.log(a);  //Reference Error.
      let a = 10;
  --  let x; 
      console.log(x); // undefined.
  -- var, let, const --> scope, reassignable, hoisted, initialized.
  -- Shadowing: 
    With let if inside a nested block, If the variable is declared again [defined and initialized], for that block, the value changes.
  -- Function expression like var greet() = () => {console.log("hi")} 
    -> Here greet will be hoisted and initialized as undefined.
    -> NOTE: If we have greet() {...} => here the whole function will get hoisted.
  -- typeof null --> Object [** JS legacy bug **]
  -- NaN === NaN -> false , [] == false -> true.
  -- prmitive data types are stored in "stack", Reference type data are stored in "heap"
  -- Arrays:
      1. reverse arr without using .reverse(). [ use .reduce([acc, item] => [item, ...acc], [])]
      2. flatten nested arr. [.flat(_nested-level_), use Recusrion: consider if the ele is array, call the fn again else push the val inside the arr.]
      3. find duplicates. [use freq Map and then filter on main arr]
  -- Non-Integer keys in arr --> Length will be 0. 
    const arr = [];
    arr["test"] = "fool";
    console.log(arr); // print ["test": fool]
    console.log(arr.length); // length ==> 0
  -- false + 1 ==> 1 [false will become 0], true + '1' ==> true1 [true will be string].
  -- Type Coercion:
      1. Implicit --> automatically [using + or -]
      2. Explict --> using wrapper class [Number('3'), String(123), Boolean(0), !!'hello" ]
  -- [] + {} --> [object, object]
     {} + [] --> 0
     [] == false --> true
     null == undefined -> true.  
  -- 2 ways of checking types:
    1. typeof 
    2. Object.prototype.toString().call() --> Precise type check.
  -- First class citizens:
      3 things are allowed -> can be stored in varaible, passed as params, or returned from function.
      NOTE: Functions are first class citizens.
  --  When you using "this" inside a function ==> You must call the fun like: new fun() --> The fun will be a constructor function.
  -- var loop trap fixed using closure...
      for (var i = 0; i < 3; i++) {
        (function(j) {
          setTimeout(() => console.log(j), 1000);
        })(i);
      }
  -- NOTE:
     The variables inside a closure will be garbage collected when the reference of the inner function is out of scope or is no longer in use.
     as long as we have the refernce of the inner function, The variable exists in memory.
  -- Callbacks --> fun passed to another fun, that executes after sometime.
     Prmise: JS Object that returns a value that may be available now, later or never.
  -- OOPs in JS:
    1. Prototype based.
    2. ES6 class based.
  -- private field inside a class --> declare variabel with # eg: #balance [from ES2022]
  -- JS follows prototype based inheritance --> Every obj has __proto__ --> that links to another object forming a link.
  -- at the end of the link it will always be Object.prototype.
  -- __proto__ vs prototype
    __proto__ ==> Points to the object's internal prototype chain. [exist on the obj]
    Func.prototype --> used only on constructor functions and classes. ==> Can be used to define new methods on the class.
  -- Object.create(fn) --> creates a new Object with prototype set to proto. [using Object.create is manual inheritance]
  -- using extend keyword with classes --> [Syntactic Sugar on the way we inherit properties of other classes]
  eg:
    - a class Animal, a class dog extends animal, then we create an object for the class dog.
    - d.__proto__ == Dog.prototype // true
      Dog.prototype.__proto__ === Animal.prototype // true [extends create a link between dog class and animal class]
  -- In ES6 classes,
    -> any method declared inside a function ==> will go inside it's prototype.
    -> "constructor" keyword is used to define constructor for the class when object is created.
    -> base class, a derived class extends the base class --> Inside derived class constructor, we must call super(); // this calls the base class constructor.
    1. static method:
     any method inside a class can be declared as static. eg: class MathUtil { static sq(x) { return x*x} };
     -> Here you can call sq method directly on Class without creating instance.
    2. Private field:
     -> variable declared with # eg: #count --> this are private to the class methods cannot be accessed outside.
    3. getter and setter:
      get/set key word infront of method inside the class.
  -- "this" keyword --> execution context.
  NOTE: sometime this context get lost...
     eg: const user = {
          name: "Sourav",
          greet() {
            console.log("Hi " + this.name);
          }
        };
      setTimeout(user.greet, 1000); // Hi undefined. ==> because here the context for this is not passed.
      setTimeout(() => user.greet(), 1000); // Hi Sourav.
  -- Functional Programming --> programs build using Pure function, immutable data and function composition.
  -- pure Function: give same input --> always same output, no side effects.
     immutable --> data is not mutable, copies are made with changes.
     Function componsition --> small funs are combined to build complex logic.
    eg:  
      const multiply = x => x*x;
      const increment = x => x++;
      // fun composition...
      const compose = (f, g) => {
          return x => {
              return f(g(x));
          }
      }
      console.log(compose(multiply, increment)(5));  // 25
  -- Array methods that mutates the original arr content --> push, pop, shift(), unshift(), splice(), others method returns new arr.
  -- Pure Functions:
      -> It should have any dependency on outer variable or any thing that can change.
      -> Impure eg: 
          function addItem(arr, item) {   // modify the input arr based on item.
            arr.push(item);
            return arr;
          }
        Pure one: // input arr doesnot change --> we return a new arr with change.
          function addItem(arr, item) {
          return [...arr, item];
        }
    usecase:
      -> In react, useMemo, useCallback, memo depends upon pure fun behavior for optimization.
  -- 2 condition for pure function:
      1. same input --> always same output.
      2. should not Change anything outside the function.
  -- Muttable vs Immutable example:
    const user = {name: "test"}
      Mutable --> user.name = "sourav"  //the user object is updated.
      Immutable --> {...user, name: test}  // the user obj is not updated.
    -- How keep data immutable:
      - For arrays --> use methods other that push, pop, slice or splice or Spread the elements.
      - for obejct -> spread the keys 
  -- In React state --> It detects changes via reference (shallow compare).
  -- Reducers must returns pure and must not mutate state.
    eg: return {...state, count: state.count + 1 };
  

        


    






## Regrex basic in JS:

Metacharacters:
1. Special characters with specific meanings:
  .: Matches any single character (except newline).
  \d: Matches any digit (0-9).
  \w: Matches any word character (alphanumeric and underscore).
  \s: Matches any whitespace character.
  ^: Matches the beginning of the string.
  $: Matches the end of the string.

Quantifiers:
2.Define how many times a character or group can appear:
  *: Zero or more occurrences.
  +: One or more occurrences.
  ?: Zero or one occurrence.
  {n}: Exactly n occurrences.
  {n,}: At least n occurrences.
  {n,m}: Between n and m occurrences.

Character Classes:
3.Define a set of characters to match:
  [abc]: Matches 'a', 'b', or 'c'.
  [0-9]: Matches any digit from 0 to 9.
  [^abc]: Matches any character not 'a', 'b', or 'c'

eg: Email Regrex -> /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/

BreakDown:

1. ^[a-zA-Z0-9._%+-]+ → Matches the beginning of the email (username part), allowing letters, numbers, dots, underscores, percentage signs, plus, and minus symbols.
2. @ → Ensures the presence of the @ symbol.
3. [a-zA-Z0-9.-]+ → Matches the domain name, which can include letters, numbers, dots, and hyphens.
4. \.[a-zA-Z]{2,}$ → Ensures a valid top-level domain (TLD) with at least two letters, such as .com or .org.






















