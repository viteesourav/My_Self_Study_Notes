***NOTES On Important Interview concepts For JS***

-- Js came out around 1995. By - Brendan Eich
-- Js is OOPs compliant and Works on Both Client and server side. Server-Side Js is called Node JS

**Basic Knowledge on JS**

Data Types ?
* Primitive: string, number, bigInt, boolean, undefined, null and symbol.
NOTE:
    -- 3 or 3.5 both are handled by Number type.
    -- BigInt can hold huge number eg: let c = 3453656n; It ends with n suffix.
    -- undefined: Value declared but not assigned.
    -- null: Doesnot exist.
    -- Symbol: newly added in ES6 of JS. stores anonymous and unique values. eg: let s = symbol('hi');
* Non-Primitive: Arrays and Objects.

NOTE:
  -- string is immutable in JS --> Once the value is initialize, You cannot modify it again.
  -- eg: let newStr = 'Hello';
         newStr[0] = 'k'; //No errors here...
         console.log(newStr);  //Hello  --> i.e No Change in the original value.
  -- Additionally, String methods are concat(), slice() etc will create and return a new string instead of modifying the original string value.
  -- thus, immutability.

NOTE: any in string manipulation -> spit the string [creates char array] -> Do string manipulation -> join() to create a new string.

Hoisting ? 
-- variable and function Declaration moves to the top of the scope. Scope can be both local and global
-- This behavior is strictly for declaration only. Intializing won't be hoisted. **Imp**
-- Its JS default's Behaviour and can be stopped by adding this at the top "use strict".
  eg: "use strict";
      x = 10; 
    - the above throws error as x is not defined.
    - But if you remove "use strict" ---> It doesnot throw error.

NOTE:
  x = 10;
  -> The above variable if defined outside of any function or block scope -> is stored in global/window scope.

NOTE: 
  Hoisting Differences between var, let and const ?
  1) var: The Variable decalration is hoisted with a default initialization of `undefined`., means you can access the variable before defining it -> function or global scope.
  2) let: Block scope, The variable is hoiseted with no initialization thus JS knows about the variable, but it will throw a REference Error saying, cannot access the variable before initialization.
  3) Const: Same as let, Value once initialized is fixed.

NOTE:
  Temporal Dead Zone [TDZ] **IMP
    -- This is involved with the use of keyword 'let' and 'const';
    -- In it's scope, TDZ is the time till which the variable is not defined and You are trying to access it. --> thorws Refernce Error.
    -- eg:
      //let and const are blocked scope..
        { 
          //TDZ starts at the start of the scope..

          console.log(myVar); //Reference Error i.e cannot access my var before Initialization.

          let myVar = 5; //TDZ ends here, once it's defined and initialized

          console.log(myVar); //5
        }

== vs === ?
-- == will just check the value. Interanlly It converts both them to String and then checkes the value.
-- === will check both typeOf and the value.

var Vs let ?
-- let came around 2015. Let is block Scoped i.e let can be accessed anywhere between '{' ans '}'
-- Var is function scoped. var can be accessed anywhere inside a function.
Note: 
var vs Let vs Const ?
-- Two Scopes: 
   1) Block Scope eg: scope of if..else 
   2) function Scope eg: funct() {...}
-- Var is bounded by the scope of the function. Let and const are blocked scoped.
Within a given scope:
-- Redeclaration of var is allowed but for let and const not allowed. 
-- Var is hoisted with undefined. But let and const hoisted with no Intialization.(throw error).

## Famous Interview question:
for (var i = 0; i < 10; i++) {
  setTimeout(() => console.log(i), 100);
}
// Prints 10 -- 10 times.  ==> by the time loop ends and callback starts running, i is 10 and since 'var' is shared between everyone, all prints 10.

//Fix1:
for (var i = 0; i < 10; i++) {
  (
    function(j) {
      setTimeout(() => console.log(j), 100);
    }
  )(i)
}

//Fix2:
for (let i = 0; i < 10; i++) {
  setTimeout(() => console.log(i), 100);
}
// Prints 1 to 10.  ==> each block has it's own scope of 'let'  => it prints it one by one as callback queue empties.


implicit type coercion ?
-- Automatic Conversion of Value from one data Type to another.(while using +,-, ||, && or ==).
-- '+' convert both operands to String and then concat them.
-- '-' convert both operands to Number and then subtract them. 
-- '==' converts both sides to same type i.e string before comparing.

NOTE: Boolean Coercion:
-- Falsy: null, 0, 0n, -0, undefined, false, "" and NaN are falsey. REst are all are truthy. (**Imp**).
Logical Operator Working ? 
-- Returns one of the operand.
1) OR Operator: a||b
    -- if a truth --> returns a, otherwise always b is returned.
2) And Operator: a && b
    -- If a and b both are truty, then b is returned else whichever is false is returned.

JS is static or Dynamic ?
-- JS is dynamic. type of variable is checked during run-time not compile time.
-- eg: let x =5; x= 'Sourav'; (Valid case for Dynamic language)

 NaN ?
 -- NaN -> Not a Number.
 -- type is Number. It falls under special. eg: 0/0 gives NaN.
 -- isNaN() -> checks if a number is NaN. It converts the arg to Number and then compares with NaN.
 -- eg: isNaN('anyString') --> true, isNaN(undefined) --> true,  isNaN(45) --> false, isNaN(true) --> false.

 pass by Value Or pass by Reference ?
 -- Premitive data-types are passed by value.
 eg: let x=5; let y=x; here, y points to a new location that copy's the value of x and put there. Changing x value wont effect y.
 -- Non-premitive data-types are passed by Reference.
 eg: let obj = {one:"1", two: "2"}; let obj1 = obj; here, obj1 is pointing at a refernce to obj. so Any change in Obj will be reflected in obj1.

NOTE: 
  1. shallow copy: [copy only the parent keys of the obj, nested keys are still taken as reference] --> 2 ways -> Object.assign({}. obj1), {...obj1};
  2. Deep copy: [copy the whole Obj and newly create a object, no references] -> 1 way -> JSON.parse(JSON.stringify(obj1))


 Immediatly invoked Functions (IIFE or pronounced as IIFY) ?
 -- function that runs as soon as it is declared.
 -- Syntax: (function () {console.log('Hoola');})();
 NOTE:
 -- The First set of () around the function tells it is not a function defination, it is a fucntion expression. 
 -- Without this bracket, it would throw error asking for function name not present.
 -- The second set of () executes the function immediately. else it just returns a defination.

NOTE: 
About EcmaScript ?
-- It is a standard for JS, and how it should be used. Js became ES standard in 1997 i.e ES1
-- Each Release of ES adds and standarise some new features of JS.
NOTE: ***Important Developements in ES***
-- ES5 --> strict mode is introduced.
-- ES6(2015) --> added let and const, Array.find() and Array.findIndex().
-- NOTE:
   -- All modern Browser fully supports ES6 standards.
-- After 2015, we have ECMAScript 2015 - ECMAScript 2020 (**latest**)

use Strict ? What and Why we use ?
-- It runs the JS in strict mode. Introduced in ES5.
-- "use Strict" --> add this line at the starting to enable strict mode.
-- features of Strict Mode JS:
   1) Duplicated declaration not allowed.
   2) cannot use JS keyword in funct name or param.
   3) Hoisting is not allowed i.e Intializing variable not allowed before defining it.

eg: 
  1. If a function takes param1, param2, param1.
    In non-strict mode --> param1 will take whatever passed in the 3rd paramter in the call.
    In strict mode --> duplicate parameters are not allowed.


Higher Ordered Functions ?
-- Functions taking another funtions as parms or returning another function are called higher ordered function.
-- All Callback functions are higher order functions. eg: forEach,map,filter,reduce. 
-- Two Ways: 
1) Function as an input: eg: 

const eatFun = (foodFun) =>{
    foodFun();
    console.log('Function Digested !!');
}

eatFun(function(){
    console.log('Shit! I am going to be eaten');
});

2) returns a Function: eg: [closure example]

const spitFun = ()=> {
    let a = 5;
    return function() {
        console.log(`So i am been spitted out with ${a}`);
    }
}

const newFun = spitFun();
newFun();


### "this" keyword explain ? [** V.IMP **]
-- "this" points to the object, the current function is a property of.
-- simply put, this is used to access the current object.
Note: The Catch here is, this behaves differntly under normal funtion and arrow function.
1) Noraml Function: "this" sees who is executing that function, it points to that.
2) Arraow functions: "this" sees where the fun is created. OR we can put like it looks for function keyword above it.
 -- If it finds that whoever executing that "this" points to the same.
 -- If not, It points to the global Object. In browser we have windows object.

eg: 
const testObj = {
    key1: "first key",
    key2: "second Key",
    fun1: function() {
        console.log(this);   //"function" keyword is used, so this points to current Obj.
        console.log('fun1 is executing !');
    },
    fun2: ()=>{
        console.log(this);  //no "function" is used, so this points to global.
        console.log('fun2 is executing !');
    },
    fun3: function() {
        setTimeout(()=>{
            console.log(this); //no function is used, but it is created inside a fun with "Function" keyword, so point to current Obj.
            console.log('fun3 is executing !');
        },3000);
    },
    fun4: function() {
        setTimeout(function () {
            console.log(this);   //"function" is used, so who is executing setTimeOut ? thus, this points to global Obj.
            console.log('fun4 is executing !');
        },3000);
    }
}

Tag LINE: Never use "this" and arrow function together !!! **Important**
Remember:
  -- We can use Arrow Fucntion/ normal Fucntions as we want, In Our global scope. => It doesn't matter, this points to global.
  -- Always use Function keyword inside an Obj => If you use this, it will point to current obj.
  -- Never user Arrow Function for Function defination, Inside an Object, It will always points to Global Scope bydefault.

Self Invoking Function ?
-- functions invokes themselves automatically without calling them.
-- eg: immediately invoked Function i.e IIFY.

NOTE: What are rest param ?
-- noraml fucntions have params syntax eg: ...msg
-- Means no matter how many arguments you pass in the function during call time, all are pushed in an array called msg.
eg: const example = function(...msg) {
    console.log(msg);  //msg -> ['sourav', 45, 'hi']
}
example('sourav', 45, 'hi');

call(), apply() and bind() ? What and Why ?
-- All are methods for functions.
1) call() 
  -- it invokes function taking obj as a param. syntax: funName.call(obj);
  -- use: 
  1) When function is not a part of obj but it want to access the obj params.
  2) Obj can access functions of another Obj.
  eg: obj.sayHi.call(newObj, 'BeautifulDay')
  Note: obj and newObj are different obj. obj has sayHi fun but newObj dont.
  3) it takes param also, first obj and then any params you pass.(**Implementation of REST Param, i.e ...argv --> takes all the passed argv in the list)
eg: 
const add = function (msg) {
    console.log(`Hello amigoo ${this.name} and msg: ${msg}`);
}
let obj = {name: "sourav"};
add.call(obj, "call function done")

2) apply()
  -- similar as call() method.
  -- Difference: It takes arguments as an array.
eg: oldObj.fun.apply(newObj, ["sayThisMsg"]);

3) bind()
  -- returns a new function, where this belongs to the obj which is passed in the param.
  -- "this" keyword in function will point to the newly passed param Obj.
  -- bind() wont execute immediately unlike call and apply. It will wait untill the new function is called.
eg:
const newFun = oldObj.fun.bind(newObj, 'someMsg');
newFun();

Why we needed bind ?
1) To manage the scope of 'this' when handling with callbacks.
  -- you have one myObj, with method sayHello() {console.log(this)};  Here this point to myObj.
  -- now you took refernece to this method: const newFun = myObj.sayHello;
  -- When you pass newFun to any callback, 'this' points to global scope thus a problem.
  -- solution: bind the method with obj before passing. const newFun = sayHello.bind(myObj); Thus the 'this' still points to myObj.

2) To Borrow fun from other methods.
  -- you have obj1 with fly() and obj2 with run().
  -- If you want obj2 also to have fly() eg: const newFly = obj1.fly.bind(obj2); newFly();

exec() vs test()
  -- Both are RegExp methods in JS.
exec() -> Test against the match. Returns the index of First matched char. If not matched return null.
test() -> Test against the match. Return boolean. True/False. 
eg: text = 'sourav is good'; 
const res = /good/.exec(text);  //['good', index: 10] NOTE: Index of the first character matching.
const res = /good/.test(text);  //return true.

Currying in JS ?
  -- advanced tech to convert functions with n params to n functions with one or more param.
  -- basically Converts fun(a,b) to fun(a)(b);
  -- Functionality Remain same but the way it's invoke is different.
eg: Modifying noraml sum function into currySum:
const currySum = function(a) {
    return function(b) {
        return a+b;
    }
}
currySum(5)(4);  //returns 9.

NOTE: Basically, a simple function [with Params] can be converted to a higher order function.
    
SCope and Scope chains ? 
  -- Role of scope: DEfines boundaries for variables and functions.
3 types: 
  1) Global  --> accessable to all functions. 
  2) local or Function Scope --> local to the function where it is defined.
  3) block Scope -> variable defined with { and } brases.

Scope Chaining: (***Very important***)
  -- JS engine Follow a method to find the variable, not declared in the scope.
  -- If x used in nested function, but not declared.
     then, It will look for x in parent function. If not found
     then, it will go to global scope to find the declaration for the variable x.
If still not found in the global scope, It throws refernce error, means it not able to identify x.

closure in JS ? (***V.IMP***)
  -- Ability of a fucntion to Remeber any variables declared in it's Outer scope.
  -- Basically, From a funA, when you retrun a function using the local Variable of function A.
  -- After funA completes, It gets destroyed but the local Variable data is saved in memory for further use. [This is closure]
NOTE:
  -- Closure is implemented when a func returns a function with a local variable, Thus, That local variable is accessable outside the scope.
  -- Closure logic is used while caching the data, in Memorization tech.
eg:
const myFun = () => {
    let obj1 = {
        name: "sourav",
        age: 25
    }
    return function() {
        console.log(obj1);
    }
}

const newFun = myFun();
console.log(obj1);  //This will fail, 
newFun(); //This has still access to obj1


### Famous interview question on closure... 

const perform  = (val) => {
    let init = val;
    
    return {
        add: function(...args) {
            init += args[0];
            return this;
        },
        multiply: function(...args) {
            init = init * args[0];
            return this;
        },
        value: function() {
            return init;
        }
    }
}

const action = perform(34);
console.log(action.add(2).multiply(5).value());  // (34 + 2) * 5 ==> 180.


Other example of Closures:
  1. Loop with var keyword.  => the value is shared between all.
  2. Currying operations => sum(2)(3)();



Object Prototypes ?
  -- This are basically Blueprint of any Object in JavaScript.
  -- we have Object.prototype, That has property and methods for all the Prototypes supported in JS.
eg of few Prototypes, Date prototype, Math prototype, Array prototype, Object prototype.
Why we need it ?
  -- It gives access to a wide range of methods on an Object, Even if that Object doesn't contains the declaration of that method.
  -- Code reusability.
  -- As we declare our data-Type, Js Engine will attach proper prototype based on the type of Data defined.
NOTE:
When you call a method for an Object,
  -- First it checks if method declared in the Object declaration ? If NOt...
  -- Then it looks for the defination in its protoype ? If not..
  -- then it looks into Object's prototype ? If not..
  -- then it throws error.


Callbacks in JavaScript ?
  -- Functions that are used as arguments to another funtions are called as callbacks.
use ? 
  -- They are used in nested synchronous function structure, It will be executed after another function done executed.
eg:
const productNum = (a, b) => a*b;
const findSumProd = (x,y, callBack)=>{
    let sum = x+y;
    return callBack(sum, 6);
}

const ans = findSumProd(5,6, productNum);
console.log(ans);

Types of Error in JS ?
1) Syntax Error
  -- Cause the Program to crash. Mainly due to misspelling of keywords and identifiers.
2) Logical Error
  -- All Syntax is proper, but the logic of Prog is incorrect.

Memorizations ?
  -- Caching Technique, If parameter passed doesnot change then the value is returned form cache instead of computing all over again.
  -- This makes processing faster for time-consuming functions.
NOTE: This tech is only used for expensive fun calls, expensive -> funs that consumes lot of time in processing.
How to Do ?
  -- Define a Object, cache, use the closure logic to make cache accessable outside the function.
  -- Inside the function, Check if the cache all ready have the value for the param passed ? IF yes, return from cache.
  -- If not ? Store in cache and return it.
Drawback of Caching ?
  -- It saves time in expensive function, but it consumes extra space.
eg:
const increment = () => {
    let cache = {};
    
    return function(data) {
        for(let keys in cache) {
            if(keys == data) {
                console.log('returning from Cache date');
                return cache[data];
            }
        }
        cache[data] = data+10;
        console.log('Not from the cache');
        return cache[data];
    }
}

const fun1 = increment();
console.log(fun1(10));  //this will return not from the cache data.
console.log(fun1(10));  //this will return from the cache data.

Recursion in JS ?
  -- A function calling itself. [Recursion]
  -- Always includes one baseCase or exist condition.
eg:
const findArrSum = function (arr, index=0) {
    //basecondition
    if(index == arr.length-1) return arr[index];
    
    return arr[index] + findArrSum(arr, index+1);
}

console.log(findArrSum([1,2,3,4,5,6]));

*********************************************************************
NOTE: While submitting code in Compiler during problem Solving...
1) To accept the input from the user, const input = parseInt(readLine());
2) then write the function. fn(param) {...}
3) To print the ouput for the give input, console.log(fn(input));
*********************************************************************

Function Constructors in JS ?
  -- This are invokes when a object is created using new keyword.
  -- Constructor Should always starts with Caps.
  -- If defined inside a class, Both names should match.
eg:
const MyInfo = function(name, age, place) {
    this.name = name;
    this.age = age;
    this.place = place;
}

const newObj = new MyInfo('souav', 34, 'chennai'); // we can create many Objects using the constructor.
console.log(newObj);
console.log('My name is: ',newObj.name);
const newObj2 = new MyInfo('bob', 23, 'UK'); //new object is create using constructor.

Client Side JS Vs Server Side JS ?

Client Side JS
    -- Have access to Special Objects like DOM -> Access to all the webpage elements.
    -- Have access to Browser Object Model(BOM) i.e windows object. --> provide functionality like setTimeInterval, prompt etc.
    -- Runs on the Browser Engine, Is designed to handle the Client side web-page Animations and manipulation.
Server-side JS:
    -- Node Js -> Js platform runs outside browser.
    -- Independent of any browser platform. Runs outside of browser.
    -- No access to Windows or dom elements.
    -- Have access to npm packages, That manage various open-source package for server side development and database integration. eg: express and mongoose.
    -- Mostly focused on REST API Creation and managing server-side scripting.

DOM ?
  -- Document Object Model. A programming interface to HTML and XML documents.
  -- brower creates DOM Objects when it trys to Render the HTML files.
  -- In the browser, DOM enables to manipulate HTML Pages using Js.
Also, Provides DOM events, That can trigger the code listener function, when a particular action is performed with HTML elements.
NOTE: Most of the animations in the client side, includes DOM that binds HTML with JS.

BOM ?
  -- Browser Object Model. i.e The Window Object available in the browser.
  -- a huge list of property and methods for the current page.
  -- Contains tones of functionality for browser related work, has access to methods like setTimeOut, propmpt and many more.
  -- document, screen, naviagator, location and other attributes are avialble in BOM. [WebAPis]


NOTE:
  lexical scope --> the place where the function is defined.
  eg: For arraw fun, they dont have their own 'this'. They inherit from their lexical scope, where the function is defined.




** Experience Knowledge on JS**

Why we need Arrow Functions When we have noraml Functions ? 

  -- Following Reasons:
      1. Lexical this Binding: Arrow functions inherit this from the surrounding scope, avoiding common pitfalls with the this keyword.
      2. Shorter Syntax: Arrow functions provide a concise syntax, making code cleaner and easier to read.
      3. Implicit Return: For single-expression functions, arrow functions allow omitting the return keyword.
      4. No arguments Binding: Arrow functions do not have their own arguments object, reducing potential confusion.
      5. Predictable Behavior: Arrow functions make handling the this context more predictable in certain situations, like callbacks and event handlers.



"arguments" keyword in JS ?

  -- It holds the arguments passed to a function, If the arguments are updated, This also will update.
  -- NOTE: One way, to prevent this is to use "use strict" inside the function.
  -- eg: 
          function test(x, y) {
            console.log(arguments[0], arguments[1]);  // Prints 1, 2
          }

          test(1, 2);
NOTE:
  -- arguments keyword doesnot work with Arrow Fucntions.
  -- arguments will follow the input to the functions. any change in arguments will reflect in the input params.
  -- But any change in the input params will not effect the arguments, --> It always carries the values when the control enters the function.
  -- "use strict" to disable "arguments"



Debouncing and Thorttling Concept in JavaScript: [ Optimise Event Handling ]
  
  -- Debouncing:
      - concept: delays the execution by d ms i.e No matter how many times it gets trigger -> It executes only after d ms once.
      - useCase:
          -- In SerachBox, If we make service call to backend on every KeyDown, It will make a lot of unneccessary calls.
              Solution: In Debouncing, When the user stops typing, Then we make the service call to the backend.
      - Defination:
          -- Debouncing, limits the rate of execution of a function and waits for a certain amount of time before exectuting it again.


  -- Thorttling:
    - concept: limits the execution by dms i.e let say you hit scroll event 100 times in 10 ms, But it will only execute 2 times fixed within 10 ms not more than that. 
    - useCase:
        -- In Scrolling action, When we reach a particular point, In backend we make service call to fetch new data. 
        -- This gives an infinite scrolling effect.
    - Defination:
        -- Thorttling, a teqnique to limit the execution of a event handler function, Even though the event is constantly getting triggered due to user action.
        -- In above Context, scrolling is the event, And we limit it untill we reach a certain point in the scroll bar.

  -- Libraries that has debounce and thorttle functions:
      - library name: lodash [Add as cdn or use npm]
      - For debouncing: const handleDebounce = _.debounce(()=> {}, delay); -->  Put the handleDebounce in the event handling function.
      - For Thorttling: const handleThrottle = _.throttle(()=> {}, delay); -->  Put the handleThrottle in the event handling function.

  NOTE: Diff between Debouncing and Thorttling  
    -- Notice, Debouncing delays the execution of a function like API service call untill the specified time. [OnSearch Functionality]
      But, Thorttling limits the execution of the event only after the sepecified time, irrespective of how many times the event is triggered. --> [Infinite Scrolling event]


*** IMP ***
  -- While using debouncing in React, Never !!! Neever use the state variables inside debounce to make service call or any actions.
  -- This gives rise to redunduncy because of the Re-renders and how colsures and Async state updates works in React.
  -- Solution: 
      -- Pass the payload for service call in params.
      -- InputField --> OnChangeEventHandler [update the field state and call debouceCallback(e.target.value)] 
      --> then call the function That do useCallback of the debounce method pass the params[ preseve the state during re-renders]
      --> then call the accutal debounse method [library: lodash] [use the paramaters to preapre the paylod]

  EXample of the above Scenerio:  --> always the pass the latest i.e evt.target.val to debounce func.

    import React, { useState, useCallback } from "react";
    import { _.debounce } from "lodash";

    function SearchBox() {
      const [query, setQuery] = useState("");
      const [results, setResults] = useState([]);

      const fetchData = async (q) => {
        return new Promise((res) =>
          setTimeout(() => res([`Result for ${q}`]), 500)
        );
      };

      // debounceCallback --> In the callback (async) we make the call and set the data.
      const debouncedSearch = useCallback(
        _.debounce(async (searchText) => {
          console.log("API call with:", searchText);
          const resp = await fetchData(searchText);
          console.log(resp);
          setResults(resp);  //safe..
        }, 500),
        []
      );

      //NOTE: here we are setting the state and calling debounce callback search with the latest val.
      const handleChange = (e) => {
        const val = e.target.value;
        setQuery(val);
        debouncedSearch(val);
      };

      return <input value={query} onChange={handleChange} />;
    }



Wrapper Objects in JS ?
  -- Wrapper Objects are built-in JS Objects ---> provides additional methods and functionality to existing primitive values.
  -- example of Wrapper class that wraps primitive data-types:
    1. String: 
          let newStr = new String("sourav"); 
          typeof newStr --> Object 
    2. Number
          let newNumber = new Number(45);
          typeof newNumber --> Object
    3. Boolean
          let newBool = new Boolean(45);
          typeof newBool --> Object
    4. BigInt
          let newBigint = new Object(123n);
          typeof newBigint --> Object
    5. Object
          let obj = {};
          let newObj

  -- There are others built-In objects which are not wrapper but provides additional Functionaility
    1. funtion
       let newFun = new Function('return 43;');
    *2. Array
        let newArr = new Array(1, 2, 3, 5);
    3. Regrex
        let newRegrex = new Regrex('\\d+');
    *4. Date
        let newDate = new Date();
        newDate --> A Current Date instance. [Methods are available to extract, days, month, year etc]
    *5. Error
        let errmsg = new Error('Something went Wrong');
        typeof errmsg --> Object.

  NOTE: Is it wise to use wrapper Objects Or primitive data-Types in Js ?
    -- Wrapper objects are usually very rarely used in actual programming.
    -- Reasons:
        1) All methods provided by wrapper Objects are already available to premitive types.
        2) Wrapper Objects sometimes behaive in weird manner.
          eg: 
            if('sourav ') ---> Returns True,  if(new String('')) ---> Also returns True [ideally, for '' is should be false]
        3) They introduce unneccessary perfromance Overhead and complexity compared to primitive strings.


EventLoop Explaination: 
  -- JS is a single threaded Language i.e Only one call stack to manage the execution of the whole code.
  
  -- Issue:
      - If we have any long running task in our code i.e a huge loop or a network call etc will take some time to execeute.
      - If executed synchronous, The Thread will be blocked and the code below needs to wait.
      - This slows down the efficiency and performance of the coding language.
    Solution:
      - Browser provides webApis i.e an interfaces to interact with the browser's features.
      - These APIs are responsible for handling heavy stuff by interacting with the browser.
      - eg: fetch, DOM, Timers, Console, Geolocation, web storages [local and session storage], Handle Files etc.
      - Some of these web APIs, enables offloading the task to the browser.
        - i.e it offloads the task from callstack and give it to the browser to handle.
      
      NOTE: Most of these webAPIs, which expose offloading are either callback based or Promise based. 
  
  -- Components Involved in the JS RunTime for handling Async Task in a non-blocking way in JS:
      1. JS Engine:
          - Heap 
          - CallStack [Stack the Execution of Js Code Script one by one]
      2. EventLoop [Checks if the callstack is empty, If empty it moves the Tasks from Task queue or Micro Task Queue into CallStack]
      3. Web Apis
      4. Task Queue [Also called Callback Queue, holds callbacks] and MicroTask Queue [Holds promises]
  
  -- Task Queue or Callback Queue Handles --> setTimeOut, SetInterval, Geolocation, eventListener or any webAPI with callback.
  -- MicroTask Queue Handles --> .then(), .catch(), .finally(), the function after await keyword or queueMicrotask(()=> {}). 
  
  NOTE: [** IMP **]
    -- Event Loop prioritise the MicroTask queue and then Task Queue.
    -- i.e Event Loop first check if microTask queue is empty --> then only it moves to TaskQueue.
    -- After Moving each Task From Task Queue, it checks microTaskQueue 
        --> If Empty, It moves the next Task From Task queue.
        --> If Not, It first moves all the Tasks from MicroTask Queue to callstack and then move the Task From TaskQueue. 
  
  -- example: 
    1. Let see the execution of callback Based Task:  
        SetTimeOut(() => console.log('Done'), 500); 
      
      -- first SetTimeOut Goes to callStack.
      -- As it is a webAPI with callback, It will be immediately offloaded from the callstack and moved given to browser to handle.
      -- The callstack will process other Tasks.
      -- After 500ms, The Result is moved to Task Queue, Where it Waits.
      -- Now, Event Loop waits till the callStack is empty, once empty It moves the callback function to callStack.
          NOTE: 
          -- If CallStack is not empty, Event Loop will still wait, untill it is empty and then only, the callback function moves from Task queue --> callStack.

    2. Let see the exectution of Promise based Task: 
        fetch('some url')
          .then(resp => console.log(resp));
      
      -- first fetch goes to the callstack --> This returns a promise object with status as pending. --> Also Initiate the network call by the browser.
      -- Then .then goes to callstack --> It will be offloaded and handled by the browser.
      -- Then Other tasks will loaded and executed in the callstack.
      -- Once we received the response, The Function will be stacked in microTask queue.
      -- Now, Event Loop waits, Till the call stack is empty --> Then loads the function to the callStack.
      NOTE:
        If you have any callbacks Functions waiting at Task Queue, It has to Wait till microTask Queue is empty.


** Swallow copy Vs Deep Copy of Objects ?
  1. Swallow copy:
    -- eg: let obj1 ==> Exists which holds 2 strings and a deep nested Object.
    -- Now, You do, let obj2 = {...obj1};
    -- It will spread the keys of obj1 in Obj2 where obj1 and obj2 hold 2 different references in the memory.
    -- Interestingly,
       -- When the nested object of obj1 is spread, Obj2 and obj1 points to the same reference.
       -- i.e If you change something in nested object with obj2, It will be for sure reflect in obj1.

  2. Deep copy:
    -- This method suggest a copy in such a way that Obj1 and obj2 are totally 2 different reference in the memory.
    -- eg: let jsonString = JSON.stringify(obj1);
           let obj2 = JSON.parse(jsonString);
    -- This method,
       -- Prevent swallow copy of nested object and obj1 and obj2 are toally 2 different reference.
        




####### Revision and Notes for Important Topics in JS #############


** Core JavaScipt COncepts ** 

  1. Variables and Scoping
  2. var, let, const
  3. Hoisting
  4. Data Types and Structures
  5. Temporal Dead Zone
  6. Primitive vs. reference types
  7. Arrays and objects
  8. Type coercion and type checking
  9. Functions
  10. Function declarations vs. expressions
  11. Arrow functions
  12. Closures
  13. IIFE (Immediately Invoked Function Expressions)
  14. Higher-order functions
  15. Asynchronous JavaScript
  16. Callbacks
  17. Promises
  18. async/await
  19. Event loop and microtasks/macrotasks
  20. Object-Oriented Programming (OOP)
  21. Prototypal inheritance
  22. ES6 classes
  23. this keyword, call, apply, bind
  24. Functional Programming
  25. Pure functions
  26. Immutability
  27. Function composition
  28. Array methods (map, filter, reduce)


** Advance Javascript
  Event Handling
    Event listeners
    Event propagation (bubbling and capturing)
    Event delegation
  Error Handling
    try, catch, finally
    Custom errors
  JavaScript Engine and Runtime
    V8 Engine
    Just-In-Time (JIT) compilation
    Memory management
  Modules
    ES6 modules (import/export)
    CommonJS
  Advanced Data Structures
    Sets and Maps
    WeakSet and WeakMap
  Design Patterns
    Singleton
    Factory
    Module
    Observer
  Concurrency and Parallelism
    Web Workers
    Service Workers

** Frontend-Specific Topics
		DOM Manipulation
		Selecting elements
		Modifying elements
		Event handling
		Web APIs
		try, catch, finally
		Custom errors
		JavaScript Engine and Runtime
		Fetch API
		WebSockets
		LocalStorage, SessionStorage, and IndexedDB
		Navigator API
		Frameworks/Libraries
		React (hooks, lifecycle methods, state management)
		Angular (directives, services, dependency injection)
		Vue.js (reactivity, components, Vuex)
		Performance Optimization
		Debouncing and throttling
		Lazy loading
		Code splitting
		
** Best Practices
		Code Quality
		Clean code principles
		Code reviews
		Refactoring
		Security
		XSS, CSRF
		CORS
		Secure coding practices
		Accessibility
		ARIA roles
		Semantic HTML
    webpacks and webpack 5



##### Important Notes #####

## Core JS: 
  -- TDZ [Temporal dead zone]: the time between variable declared and initialization when let or const exist but cannot be access.
    eg: console.log(a);  //Reference Error.
      let a = 10;
  --  let x; 
      console.log(x); // undefined.
  -- var, let, const --> scope, reassignable, hoisted, initialized.
  -- Shadowing: 
    if "let" is present inside a nested block i.e the variable is declared again [defined and initialized], for that block, the value changes.
  -- Function expression like var greet = () => {console.log("hi")} 
    -> Here greet will be hoisted and initialized as undefined.
    -> NOTE: If we have greet() {...} => here the whole function will get hoisted.
  Example:
    1. var + arrow Function: 
      greet();
      var greet = () => { console.log('Hiii') };   

    The above doesnot work ==> only "var greet;" goes up. ==> which is undefined i.e not a function that we can call.
    NOTE: using let and const + arrow function --> It will fall under TDZ => Reference error.

    2. use Function defination:
      greet();

      function greet() {
        console.log('Hi');
      }

    The above works ==> the full function defination is hoisted.
  
  -- typeof null --> Object [** JS legacy bug **]
  -- NaN === NaN -> false , [] == false -> true.
  -- prmitive data types are stored in "stack", Reference type data are stored in "heap".
  -- Arrays:
      1. reverse arr without using .reverse(). [ use .reduce([acc, item] => [item, ...acc], [])]
      2. flatten nested arr. [.flat(_nested-level_), use Recusrion: consider if the ele is array, call the fn again else push the val inside the arr.]
      3. find duplicates. [use freq Map and then filter on main arr]
  -- Non-Integer keys in arr --> Length will be 0. 
    const arr = [];
    arr["test"] = "fool";
    console.log(arr); // print ["test": fool]
    console.log(arr.length); // length ==> 0
  NOTE:
    - Arrays are special type of objects in JS.
    - case1: when we add arr[key] = property -> It just stores in Obj. ==> arr length will be zero.
    - case2: When we arr.push(val) => It addes a numeric key and val in Obj ==> arr length will be 1.
  -- false + 1 ==> 1 [false will become 0], true + '1' ==> true1 [true will be string].
  -- Type Coercion:
      1. Implicit --> automatically [using + or -]
      2. Explict --> using wrapper class [Number('3'), String(123), Boolean(0), !!'hello" ]
  -- [] + {} --> [object, object]
     {} + [] --> 0
     [] == false --> true
     null == undefined -> true.  
  -- 2 ways of checking types:
    1. typeof 
    2. Object.prototype.toString().call() --> Precise type check.
  -- First class citizens:
      3 things are allowed -> can be stored in varaible, passed as params, or returned from function.
      NOTE: Functions are first class citizens.
  --  When you using "this" inside a function ==> You must call the fun like: const newFun = new fun(param1, parm2) --> The fun will be a constructor function.
  -- var loop trap fixed using closure...
      for (var i = 0; i < 3; i++) {
        (function(j) {
          setTimeout(() => console.log(j), 1000);
        })(i);
      }
  -- NOTE:
     The variables inside a closure will be garbage collected when the reference of the inner function is out of scope or is no longer in use.
     as long as we have the refernce of the inner function, The variable exists in memory.
  -- Callbacks --> fun passed to another fun, that executes after sometime.
     Promise: JS Object that returns a value that may be available now, later or never.
  -- OOPs in JS:
    1. Prototype based.
    2. ES6 class based.
  -- private field inside a class --> declare variabel with # eg: #balance [from ES2022]
  -- JS follows prototype based inheritance --> Every obj has __proto__ --> that links to another object forming a link.
  -- at the end of the link it will always be Object.prototype.
  -- __proto__ vs prototype
    __proto__ ==> Points to the object's internal prototype chain. [exist on the obj]
    Func.prototype --> used only on constructor functions and classes. ==> Can be used to define new methods on the class.
  -- Object.create(fn) --> creates a new Object with prototype set to proto. [using Object.create is manual inheritance]
  -- using extend keyword with classes --> [Syntactic Sugar on the way we inherit properties of other classes]
  eg:
    - a class Animal, a class Dog extends Animal, then we create an object for the class Dog.
    - d.__proto__ == Dog.prototype // true
      Dog.prototype.__proto__ === Animal.prototype // true [extends create a link between dog class and animal class]
  -- In ES6 classes,
    -> any method declared inside a function ==> will go inside it's prototype.
    -> "constructor" keyword is used to define constructor for the class when object is created.
    -> base class, a derived class extends the base class --> Inside derived class constructor, we must call super(); // this calls the base class constructor.
    1. static method:
     any method inside a class can be declared as static. eg: class MathUtil { static sq(x) { return x*x} };
     -> Here you can call sq method directly on Class without creating instance.
    2. Private field:
     -> variable declared with # eg: #count --> this are private to the class methods cannot be accessed outside.
    3. getter and setter:
      get/set key word infront of method inside the class.
  -- "this" keyword --> execution context.
  NOTE: sometime this context get lost...
     eg: const user = {
          name: "Sourav",
          greet() {
            console.log("Hi " + this.name);
          }
        };
      setTimeout(user.greet, 1000); // Hi undefined. ==> because here the context for this is not passed.
      Option1: setTimeout(() => user.greet(), 1000); // Hi Sourav.
      Option2 : use bind keyword -> setTimeout(user.greet.bind(user), 1000);   //Here we are setting the context of the function reference.
  -- Functional Programming --> programs build using Pure function, immutable data and function composition.
  -- pure Function: give same input --> always same output, no side effects.
     immutable --> data is not mutable, copies are made with changes.
     Function componsition --> small funs are combined to build complex logic.
    eg:  
      const multiply = x => x*x;
      const increment = x => x++;
      // fun composition...
      const compose = (f, g) => {
          return x => {
              return f(g(x));
          }
      }
      console.log(compose(multiply, increment)(5));  // 25
  -- Array methods that mutates the original arr content --> push, pop, shift(), unshift(), splice(), others method returns new arr.
  -- Pure Functions:
      -> It should not have any dependency on outer variable or any thing that can change.
      -> Impure eg: 
          function addItem(arr, item) {   // modify the input arr based on item.
            arr.push(item);
            return arr;
          }
        Pure one: // input arr doesnot change --> we return a new arr with change.
          function addItem(arr, item) {
          return [...arr, item];
        }
    usecase:
      -> In react, useMemo, useCallback, memo depends upon pure fun behavior for optimization.
  -- 2 condition for pure function:
      1. same input --> always same output.
      2. should not Change anything outside the function OR cause any side-effect like HTTP calls [eg: calling localStorage], Console.log [I/O operations], mutating any outside variables.
  -- Muttable vs Immutable example:
    const user = {name: "test"}
      Mutable --> user.name = "sourav"  //the user object is updated.
      Immutable --> {...user, name: test}  // the user obj is not updated. -> a new object is created with the content of user and updated name key.
    -- How keep data immutable:
      - For arrays --> use methods other that push, pop, slice or splice or Spread the elements.
      - for obejct -> spread the keys 
  -- In React state --> It detects changes via reference (shallow compare).
  -- Reducers must returns pure and must not mutate state.
    eg: return {...state, count: state.count + 1 };

## Advance Js Notes:
  -- Event Handling --> browser detects and responds to interactions.
  -- Envent Listeners:
      -> Functions that listens to any event on a DOM element.
      -> accept's an event and callback function.
      -> eg: document.querySelector("#btn").addEventListener("click", handleClick);
      NOTE: Later, you must remove the event Listner, It will work only if the reference to callback is same.
            document.querySelector("#btn").removeEventListner("click", handleClick); 
  -- Event propagation:
     -> Also called -> Event bubbling.
     -> Event fired in child, bubbles up to parent. 
     -> to capture/stop Event propagation, must use 
        1. event.stopPropagation(); 
          OR
        2. element.addEventListener("click", handler, true); -> pass true in third parameter.
  -- Event Delegation:
    -> Instead of attaching Event to child, attach it to the common ancestor, Let the ancestor handle the rest.
    -> improves performance --> less listeners.
  -- Event Object:
    -> in case of event we receive evt object.
    -> evt.stopPropagation(); -> prevents the event from bubbling to parent.
    -> evt.preventDefault(); --> prevent the default behavior of form submit.
  -- Error Handling:
    -> Fault tolerant code.
    -> using try...catch....finally.
    -> catch throws error object --> includes err.message, err.name, err.stack.
    -> we can throw manual errors. eg: throw new Error("somthing went wrong");
    -> NOTE:
        -> we have Error class that can be extended and a custom error class can be created.
        eg: 
        class ValidationError extends Error {
          constructor(message) {
            super(message);
            this.name = "ValidationError";
          }
        }
        -> throw new ValidationError("Custom error is thrown");
    -> try...catch doesnot catch async fucntions unless we await them. [** imp **];
  -- JS Engine and Runtime:
    -> Js runs on v8 engine --> available in browsers or node.js
    -> v8 Engine -> converts to machine code, Optimise by Just-In-Time compilation, manage memory by Garbage collection.
    -> Runtime -> by browser/node.js 
      -> Provides callstack, webAPIs, Event loop, Task/microTaskQueues.
    -> JIT compliation:
      -> code is compiled when the program is running, not before it like C++;
      -> usecase:
        -> faster than interpreter.
        -> learns which part of code is run oftem i.e hot. [** IMP **]
        -> re-optimise freq used functions.
    -> Memory Management:
      -> Release memory when no longer needed --> automatically handled by Garbage collector.
      -> Still memory leaks can be created:
        1. closures with large retained variables.
        2. timers.
        3. Global variables.
        4. listners not removed.
  -- ES6 Module vs CommonJS 
    -> modules - split your code into reusable pieces.
    -> ES6 --> Import/Export.
      -> Export -> you can either to named export or export default [only 1 thing is exported from that file by default] from a file.
      -> Import -> if named export, you have to perform named imports.
        -> also supports lazy loading of any module. eg: const Test = lazy(() => import("./component/test.js")); => Optimise performance.
    -> Common JS Modules:
      -> used before ES6's import/export.
      -> syntax:
        from the file, we exporting -> module.exports = greet;  [greet is a function from that file]
        In the file, we importing --> const greet = require('./file_name');
      -> module are loaded synchronouly.
      -> import happens during run-time, works only in node [browser not suppported]
    -> diff:
      1. ES6 import/export is loaded in compile time, commonJS loads in runtime.
      2. ES6 import/export supports both browser and node, commonJS only in node.
      3. File extension is required in browser, it is optional here.
      4. tree-shaking, remove unused code, cannot do that.
  -- Data-Structure:
    -> Set: 
      const items = new Set([1, 2, 2, 3, 4]); // set(3) {1, 2 , 3};
      const arr = [...items];  // spread the content of set in an arr..
      -> stores uniques values.
      -> methods: .add(), .delete(), .has(), .size();
    -> Map:
      const map = new Map();
      map.set("key1", 2);
      -> NOTE: here keys can be any type, not just strings.
      -> .size() 
      -> here insertion order is maintained, unlike in object.
      -> you can iterate using map.forEach()
    -> weakSet:
      -> like set but it only stores objects. [not any primitive data-type]
      -> Allows Garbage Collection.
      -> cannot iterate, no methods like .size, .clear, .keys.  --> Insert into weakSet useing .add(obj), check if any obj exists .has(obj).
    -> WeakMap:
      -> keys must be object here or any value.
      -> Not iterable, allows Grabage Collection.
      -> usecase: memory-safe caching [When keys are objects] or private data storage. 
      -> you have access to method like .set(), .get(), .has()
  -- Design Patterns:
    1. Singleton Pattern:
      -> A class must have only 1 instance, and provides global access point to that instance.
      -> usecase:
        1. app-wide configurations.
        2. Logger services
        3. auth token manager.
        4. Theme manager.
      -> Use when we need a single, shared statte across the app, avoids duplicate instance of service like DB connection.
    eg: 
        class AppConfig {
          constructor() {
            if (AppConfig.instance) {
              return AppConfig.instance;
            }
            this.theme = "dark";
            AppConfig.instance = this;
          }
        }

        const config1 = new AppConfig();
        const config2 = new AppConfig();

        console.log(config1 === config2); // true

    2. Factory Pattern:
      -> provides a method to create object without specifying the exact class of the object.
      ->usecase:
        1. creating dynamic ui component like buttons, modals.
        2. API adapters. (REST, GraphQL, wesockets)
      -> use when we want to abstract object creation based on types.
    eg: 
      class Car {
        drive() { console.log("Driving car"); }
      }
      class Truck {
        drive() { console.log("Driving truck"); }
      }

      class VehicleFactory {
        static create(type) {
          if (type === "car") return new Car();
          if (type === "truck") return new Truck();
        }
      }

      const myVehicle = VehicleFactory.create("truck");
      myVehicle.drive(); // Driving truck

    3. Module Pattern:
      -> Encapsulate related code -> variables and method inside a self-contained module, like closures.
      ->usecase:
        1. Code Organization
        2. creating private var/funs.
      -> use when we need data encapsulation/ for utility lib, localstorage wrappers or cokkie utils.
    eg:
      const CounterModule = (() => {
        let count = 0; // private

        return {
          increment() {
            count++;
            return count;
          },
          reset() {
            count = 0;
          }
        };
      })();

      console.log(CounterModule.increment()); // 1
      console.log(CounterModule.increment()); // 2
      CounterModule.reset();

    4. Observer Pattern:
      -> one object (subject) maintains a list of dependents (observers) and notifies them of state changes.
      -> usecase:
        1. ui updates from state changes.
    eg:
      class Subject {
        constructor() {
          this.observers = [];
        }

        subscribe(fn) {
          this.observers.push(fn);
        }

        unsubscribe(fn) {
          this.observers = this.observers.filter(obs => obs !== fn);
        }

        notify(data) {
          this.observers.forEach(fn => fn(data));
        }
      }

      const subject = new Subject();

      function logger(data) {
        console.log("Logged:", data);
      }

      subject.subscribe(logger);
      subject.notify("New data received!"); // Logged: New data received!
  
  -- Concurrency & Parallelism in JS:
    -> Concurrency: managing "multiple tasks" at the same time, but no necessary in parallel.
    -> Parallelism: performing parallel execution of tasks "at once".
    1. Web workers:
      -> Allows JS to run in a background thread without blocking the main ui-thread.
      -> communication with main thread via --> .postMessage()
      -> usecase:
        1. Long running loops or calls.
        2. Image/video processing.
        3. parsing large JSON.
        4. complex filtering/sorting.
      -> NOTE: 
          1. no access to dOM.
          2. comminication via post message only.
          3. each worker will have it's own file.
      eg: 
        In worker.js:
          self.onmessage = function (event) {
            const result = event.data * 2;
            self.postMessage(result);
          };
        In main.js:
          const worker = new Worker("worker.js");

          worker.postMessage(5); // send data

          worker.onmessage = function (event) {
            console.log("Result from worker:", event.data); // 10
          };
    2. Service Workers:
      -> Acts as a proxy between web app and network. --> runs in background, intercept HTTP reqs -> handles caching, push notifications
      -> usecase:
        1. caching assert for performance.
        2. Push notifications.
      -> life-cycle events:
        1. install -> first time installation -> setup cache.
        2. activate -> after install, cleanup or versioning 
        3. fetch -> intercepts HTTP reqs.  

## Additional Topics:
  -> Local vs Session Storage and IndexDB
  -> XSS, CSRF
  -> CORS
  -> Accessibility
  -> ARIA roles
  -> Semantic HTML
  -> Webpacks and webpacks 5


#### NOTE: Important Question Asked From Js-React:
  1. What are the drawbacks of using JSON.parse(JSON.stringify(obj)) for performing deep copy ?
    --> Below mentioned types are completly loss:
      1. undefined --> lost 
      2. functions --> lost.
      3. Date --> converted to string.
      4. RegExp --> lost.
      5. If circular ref present --> Crash/Error.
    --> circular ref --> When inside the obj, there is a key that is pointing to the same object.
  2. What is the difference between Local vs Session Storage and IndexDB ?
    1. Local Storage:
      -> Browser based -> Stores Key-value storage (5-10 MB)
      -> Persist the Data even after browser/tab is closed --> Need to delete explictly.
      -> usecase: Store small, simple, non-sensitive user preferences or flags.
      NOTE: 
        Can we store Token in localstorage ?  -> NO, localstorage can be stolen via script Injection (XSS).   
    2. Session Storage:
      -> per-Session/per-tab based -> stores key-value. (~ 5MB)
      -> Persist the data till the browser or the tab is opened -> Once closed, all data resets.
      -> usecase: Stores temporary data related to particular tab session eg: form progress, temp auth tokens.
    3. IndexDB: 
      -> client-side NOSQL database -> allows storing structured data not just string.
      -> Space -> Can stored hundread of MBs.
      -> Data will Persit the data untill explicitly deleted.
      -> usecase: Large data, offline apps, caching API responses, storing JSON Objs, images etc.
  3. What are XSS and CSRF ?  -> Client side web security vunerablity.
    1. XSS
      -> Cross-site Scripting - Attackers inject malicious JS into your web page, and that code executes in user's browser.
      -> example:
          -> we have a comment box in our code --> commentbox.innerHTML = userComment;
          -> If inside the comment box, HAcker sent -> <script>alert("attack")</script> --> this will directly execute when another user loads the page.
      -> Impact:
        1. can steal cookies, JWT tokens, localstorage data.
        2. Modify DOM or UI
        3. Redirect to another site.
        4. Execute unintentional actions on behalf of user.
      -> Prevention:
        1. Always sanitize user Inputs --> before rendering.
        2. use textContent instead of innerHTML.
        3. Content Security Policy (CSP) --> Add CSP header to restrict which scripts can execute.
      NOTE: This can be detected using Snyk, OWASP ZAP or security Scanners.
    2. CSRF
      -> Cross-site resource Forgery --> An authenticated user is tricked to perform unintentional actions - as browser automatically includes cookies, session with every request.
      -> example:
        -> logged in bank.com --> where API is POST: https://bank.com/transfer  & Body: amount=1000&to=attacker
        -> Now another website, secretly includes -> <img src="https://back.com/transfer?amount=100000&to=attacker">  --> Browser automatically sends cookies from bank.com => transfer happens silently.
      -> Impact:
        1. Unauthorizede actions.
        2. EXploitation of user Trust.
      -> Prevention:
        1. CSRF Token --> Backend generates a unique token per session or from --> client must send it with every state-changing req.
        2. SameSite cookies -> set cookies with Samesite=strict to prevent cross-site request.
        3. CORS Header --> Dont allow wildcard (*) for sensitive end-points. Restrict allowed origin.
      
  4. What is CORS ? Why it is important ? How it is handled ?
    1. CORS
      -> Cross-Origin Resource Sharing -> browser mechanism that controls how web page can make requests to different origin (domain/protocol or port).
      -> Is it a client-side or server-side concept ?
        -> CORS is configured on the server, enforced by browser.
        -> Postman doesnot show CORS issue -> because it's a browser security policy.
      -> Origin:
            scheme (protocol) + host (domain) + port 
          eg: http://app.example.com, https://app.example.com   -> Different protocol so different origins.
      -> How CORS Works ?
        1. Front end sends a POST, PUT or DELETE or custom header to the server:
          -> fetch("https://api.example.com/data", { method: "POST", headers: {"content-Type": "application/json" }});
          -> Broser sends:
             OPTIONS /data HTTP/1.1
             Origin: https://app.example.com
             Access-control-Request-method: POST
        2. The server responds with a CORS Header:
            HTTP/1.1 200 ok
            Access-Control-Allow-origin: https://app.exmaple.com
            Access-Control-Allow-Methods: POST, GET, OPTIONS
            Access-control-allow-headers: Content-Type, Authorization.
        -> If these headers are present -> browser allows the main request. If not --> browser blocks the response with CORS error.
      -> NOTE: for Public api -> access-control-allow-origin: *  --> It will take request from any site.
      -> How is CORS different for CSRF ? 
        -> CORS controls which origin can talk to my APIs, CSRF tricks the user an authenticated browser to send unintended requests.
      -> Who sends CORS headers ?
        -> Only the server. Frontend can't fix it directly ! It can only analysis if the current origin is allowed or not !
  5. How are JWT tokens are more Secure ? What it improves ? How it ensures safetly ?
    -> JWT -> Json Web token -> a compact, stateless, digitally signed token used to securly transfer user identity and claims betweeen client and server.
    -> NOTE: JWT are not encrypted -> It is signed token to prevent tampered with.
    -> JWT structure:
       [header].[payload].[signature]
      header -> describe the algo used for signing.
      payload -> contains claims [eg: userId, role, expiry]
      signature - verifies the token integrity.
    -> Why JWT is stateless ?
      -> without JWT, Server keeps session info in memory or db, every req needs to match -> server heavy.
      -> with JWT, all info already embedded in token, server verifys the signature with secret token - no database needed. --> Auth becomes stateless and scalable.
    -> JWT =/== Encription
      -> Anyone can decode JWT -> it's base64 decoded --> That;s never store sensitive data in JWT payload.
      -> Only server verifys the JWT to authenticate the request is sent from a valid user.
    -> How JWT works ?
      1. user loggs in --> sends username/password.
      2. Server verifies creds => signs a JWT token and returns it. [signature is generated with a secret key]
      3. Client stores the token -> inside memory or secure cookies.
      4. Subsequest request -> include JWT token in header as  { "Authorization" : Bearer <JWT_TOKEN> }
      5. Servers validate the token signature  --> using the secret key -> If validation success -> grant access.
  6. What is Semantic HTML ?
    -> HTML elements that conveys meanings.
    -> Instead of using div for with id as header, menu, content, we can use elements like: <header>, <nav>, <main>, <footer> etc.
    -> Impact:
      1. improves Accessibility -> screan readers job is easy.
      2. boosts SEO
      3. Enhance code readability and maintainability.
  7. What is difference between HTML and HTML 5 ?
    1. HTML 
      -- DocType -> mostly long and complex.
      -- Mostly used <div>-based
      -- No built-in plugins for audio/video.
      -- form controls only basic input types.
      -- For offline storage -> use cookies only.
      -- No support for web workers, Geolocation APIs, Drag & Drop APIs, websockets.
    2. HTML 5
      -- Docktype -> short sand simple <!Doctype Html>
      -- use semmantic HTML tags like header, main, section, acticle, footer.
      -- built-in support for audio and video --> <audio> & <video> tags.
      -- form controls new types: email, url, range, date, color etc.
      -- for offline storage -> have API access for localstorage, session storage and indexDB.
      -- Support for web workers, Geolocation APIs, Drap & Drop API and websocket.
  8. What are Web Accessibilities ?
    -- This ensures People with disabilities can use website.
    -- 3 keys:
      1. Semenatic structure -> <nav> or <main>  -> helps screen readers understand layout.
      2. Kyboard Navigation -> use tabIndex, focus management --> For users without a mouse.
      3. ARIA roles/labels -> role = "button", aria-label="close Modal" --> Provide extra context to assistive tools.
    -- How do you test Accessibility ?
      -> use chrome's Dev tool -> Lighthouse.
  9. What are types of Middleware exists in React applciations ? How reducers are pure Function ? Give example of Impure functions ?
  10. What is the Production Process of a React Application ? How App is bundled and deployed on production ?
    -- 3 step process:
      1. Development Phase (Local Environment)
        -- App is created using Vite or create-react-app. --> Do the development --> Run the app locally.
        -- command: npm start or npm run dev
        -- What happens >
            1. dev server (vite/webpack-dev-server) runs in memory.
            2. It doesn't build actual static files --> instead, it uses an in-memory bundle.
            3. Supports Hot Module Replacement (HOT) -> any file you edit, only that module reloads, not the entire page.
            4. it uses "source maps" for debugging.
        NOTE: dev mode, performance and bundle size are not optimized.
      2. Build Phase (Production Bundle Creation)
        -- command: npm run build.
        -- The above triggers your bundler (usually webpack or Vite) -->
          1. Compile
             -> All React (JSX + Typescript) code is converted to palin JS via Babel core or SWC.
             eg: 
                //Before
                const App = () => <h1>Hello</h1>;
                //After
                const Ap = () => React.createElement("h1", null, "Hello");
          2. Bundle
            -> All JS modules (import/export) are combined into one or few bundles --> eg: main.js or vendor.js
          3. Optimize 
            -> The bundle performs: 
              1. Minification        - Removes whitespaces, shortens variable names.
              2. Tree-shaking        - Removes unsed import/exports.
              3. code Splitting      - Creates smaller chunks (lazy-loaded routes or components)
              4. Assert optimization - Compresses images, optimizes CSS
            -> build folder structure:
                /build 
                  -> index.html
                  -> asserts/
                      -> main.5a1c7.js
                      -> vendor.9123c.css
                      -> logo.svg
            NOTE: build is a static folder. It doesn't need Node.js --> It can be served by any web server.
          -> What happens to the node_module foleder ?
            -- during bundle process, the bundler resolves all imports from node_modules.
            -- it bundles it into our final complied JS -> applies tree-shaking, removes unused parts.
            -- Thus, my final /build output:
                - actual node_modules folder is not included.
                - only the used code from those modules ends up inside my final .js bundle.
            NOTE: node_module is only used during crating of bundle, not to run it.
      3. Deployment Phase (Production Hosting)
        -- 2 deployment methods:
          1. Static Deployment (for SPA - Single Page Application i.e the whole content is served in index.html file in build folder)
            - when we have purely client-side app (React Router SPA) 
            - common services: Vercel, Netlify.
            - steps:
              1. we run npm run build.
              2. upload /build frolder to host.
              -> Configure fallback for SPA service. --> If the page not found it should serve the index.html by default.
          2. SSR / Hybrid Deployment 
            - for Framework like Next JS.
            - deploy the node server that can render pages on the server side --> this helps SEO, better performances.
      -- How Browser loads a Production React App ?
        1. The web server serves the index.html [SPA case]
        2. The browser downloads JS/CSS bundles from CDN.
        3. The react runtime boots up, hyderate the root DOM element.
        4. components render --> API calls fires --> app become interactive.    
  11. Your Reat Application is running very slow ! How do you identify the Issue, Which tools you will use ? What could be the possible reasons and How do you handle it ?
      -- Explore possible causes: 
        1. Initial Page loading is slow ?
        2. Runtime performance like typing lag or slow re-renders
        3. network/API calls slow ?
      -- Tool that can help identify the problem: 
        1. Browser Dev Tools.
          1. Network Tab - Check for large bundle sizes, uncompressed asser or blocking requests. Look for large images, fonts etc
          2. Performance Tab - Record user action -> See which components re-render frequently or cause layout thrashing.
          3. Memory Tab - Detects Memory leaks - Event listners not cleared, large object retention.
        2. React Dev Tools PRofiler
          - Analyse component re-render times.
          - Find components re-rendering unnecessarily.
          - "flamegraph" to identify hotspots.
        3. Lighthouse/Web Vitals
          - Highlights performance and Accessibility bottlenecks.
        4. Webpack Bundle Analyzer / Vite Visualizer
          - visualize bundle composition - find heavy libs and duplicated code.
      -- Common Causes and Fixes 
        1. A Rendering Performance Issues:
          -> Symptoms: Typing lag, scroll jank, frequent re-renders.
          -> Pssobile reasons: 
            1. re-renders triggered by parent state changes.
            2. inline arrow functions as props.
            3. Missed out React.Memos or callbacks.
        2. Bundle Size / initial Load is high:
          -> Symptoms: Slow app load, white screen on startup.
          -> Possible reasons:
            1. Large JS bundle or unused dependencies.
            2. All routes/components bunddled together.
            3. Uncompressed images or fonts.
          -> Solutions:
            1. use code splitting like lazy-loadin + Suspense.
            2. Compress assert => gzip ot brotli.
            3. use CDN for static assert.
            4. Remove unnecessary imports.
        3. Network /API Issues:
          -> symptoms: slow page after login ot fetch-heavy ui.
          -> Problem:
            1. Multiple redundant API calls.
            2. No caching or pagination.
            3. Long waterfall chains.
          -> Soltuions:
            1. use React Query /SWR for caching.
            2. Debounce the input-based API calls.
            3. Optimize backend APIs.
        4. Memory Leaks
          -> symptoms: App slows down over timer or tab memory grows.
          -> Problem:
            1. timers or intervals not cleaned up.
            2. Reatained large objects in closure.
          -> Solution:
            1. Do clean up the timers or intervals in return cleanup function with useEffect hook.
  12. What are Web Components, and how are they different from React Components ?
  13. How would you handle cross-browser compatibility issues ?
  
          

### Questions from HTML and CSS:
  1. What are CSS preprocessors ?
  2. What is border-box ? What are options we have for content Size ?
  3. What is difference between in-line block and block elements ?
  4. What is flex-flow ?
  5. What is align-self ?



## Regrex basic in JS:

  `Metacharacters:
  1. Special characters with specific meanings:
    .: Matches any single character (except newline).
    \d: Matches any digit (0-9).
    \w: Matches any word character (alphanumeric and underscore).
    \s: Matches any whitespace character.
    ^: Matches the beginning of the string.
    $: Matches the end of the string.

  Quantifiers:
  2.Define how many times a character or group can appear:
    *: Zero or more occurrences.
    +: One or more occurrences.
    ?: Zero or one occurrence.
    {n}: Exactly n occurrences.
    {n,}: At least n occurrences.
    {n,m}: Between n and m occurrences.

  Character Classes:
  3.Define a set of characters to match:
    [abc]: Matches 'a', 'b', or 'c'.
    [0-9]: Matches any digit from 0 to 9.
    [^abc]: Matches any character not 'a', 'b', or 'c'

  eg: Email Regrex -> /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/

  BreakDown:

  1. ^[a-zA-Z0-9._%+-]+  Matches the beginning of the email (username part), allowing letters, numbers, dots, underscores, percentage signs, plus, and minus symbols.
  2. @  Ensures the presence of the @ symbol.
  3. [a-zA-Z0-9.-]+  Matches the domain name, which can include letters, numbers, dots, and hyphens.
  4. \.[a-zA-Z]{2,}$  Ensures a valid top-level domain (TLD) with at least two letters, such as .com or .org.


  examples: 
  1. Match a valid username [Only letters, numbers, underscores, 316 characters]          ====>              /^[A-Za-z0-9_]{3,16}$/
  2. Match a valid US ZIP code [5 digits or 5 digits + hyphen + 4 digits]                  ====>              /^\d{5}(-\d{4})?$/
  3. Match a valid date (YYYY-MM-DD)                                                       ====>              /^\d{4}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/
  4. Match a valid IPv4 address                                                            ====>              /^\d{3}\.\d{3}\.\d{1,3}\.\d{1,3}$/
  5. Match a valid Email                                                                   ====>              /^[\w.-]+@[\w.-]+\.[A-Za-z]{3,10}$/
  6. Match a valid url                                                                     ====>              /^https:\/\/[\w.-]+\.[\w.-]+\.[A-Za-z]{2,5}$/
  






















