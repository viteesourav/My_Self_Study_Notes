### DSA Preparation - NeetCode 150 + Additional Questions. ####


------------------------------
ðŸ”¹ 1. Arrays & Hashing [Concepts: Frequency map, two pointers, prefix sums]
------------------------------
[ ] Two Sum (Easy)  --> use map, track [reminder-currIndex]
[ ] Contains Duplicate (Easy) ->  use a map to track freq of items > 1.
[ ] Valid Anagram (Easy) -> s1 -> populate the charFreqMap, s2 -> reduce the charFreqMap, if all zero -> valid.
[ ] Group Anagrams (Medium)  -> eat --> [e->1, a->1, t->1] ->a1e1t1 ==> store in map -> {a1e1t1, [eat]}, tea --> [t->1, e->1, a->1] ->a1e1t1 ==> add in map -> {a1e1t1, [eat, tea]} => print the values.
[ ] Top K Frequent Elements (Medium) --> sort the freq Map based on value => 1.use minHeap [klogn, easy] => create freq map => put {freq, item} in the min heap [maintain only k elements inside heap] => Pop the values, store in ans OR 2. Manually use quick sort logic to sort. [optimal]
[ ] Longest Consecutive Sequence (Medium) -> put in set => if immediate prev not there => start count till the immediate right doesnot exist --> One possible consequative seq length.  [NOTE: iterate in set to ignore duplicates]
[*] Subarray Sum Equals K (Medium) -> prefix sum concept, Find Prefix sum for each Item, Logic: check if there exist a prefix sum if we can subtract from the current Prefix sum we get K i.e maintain track of currSum => check if in the map there exist any currSum - k => a possible sol, if not add currSum in map for future use.
[*] Maximum SubArray (Medium) => Either use Kadane's Algo [iterate, if sum < 0, reset it to 0, track the maxSum] Or Divide and Conquer [Sum might lie in the left part, right part or across the mid]

### Neetcode Extras:
[ ] Encode and Decode Strings (Medium) => encode Logic: "lenOfWord#" infront of each word ==> concat into a single string. Decode Logic: get the count => [use i and j] => extract the word.
[ ] Product of Array Except Self (Medium) => Prefix Prod and Suffix. => populate the ans with Prefix Prods. [ans[i] = ans[i-1] * nums[i-1]] => Next maintain a suffix pointer to keep track of suffix vals => update ans[i] => ans[i] [i.e the prefix prod] * suffix [the suffix val]
[*] Valid Sudoku (Medium) => use hashMap to <index, set> => For each rowId, colId and (rowId/3, colId/3) [For each squares] and set to check if the numbers are repeated or not.


------------------------------
ðŸ”¹ 2. Sliding Window [Concepts: Fixed & variable length window, frequency counters]
------------------------------
[ ] Maximum Average Subarray I (Easy)  ==> use PrefixSum for simplicity, First sum of k element ==> as the window slides, remove i-1th ele, add j+1th element, find max avg. [NOTE: type casting: (double) 2 -> 2.000]
[ ] Best Time to Buy and Sell Stock (Easy) => move left to right, track minPrize => maxProfit = max(maxProfit, currPrize - minPrize);
[ ] Best Time to Buy and Sell Stock II (Medium)  => Track up going inclines for total possible profit amount.
[ ] Longest Substring Without Repeating Characters (Medium)  ==> use set to identify unique substr, update l, r pointer, untill set content is unique, Find max len possible.
[ ] Permutation in String (Medium)  ==> s1, make a hasmap, iterate s1.len window in s2, update the hasmap, if all zeros ==> valid permutation.
[ ] Minimum Size Subarray Sum (Medium) => take 2 pointers, since all positives, slides till right if sum >= target, track the length => min length.
[ ] Longest Substring with At Most K Distinct Characters (Hard) -> use set to track unique val, map to track freq. if set len == k, find max len, while set len > k -> move left i.e shrink the window & reduce count of left char from freqMap, If any value in freqMap is 0 and erase same val from set.

### Neetcode Extras:
[*] Longest Repeating Character Replacement (Medium) => 2 pointer + char Freq Map => L, R starts from 0 -> every time R moves, we check if substr len - freq of max occuring character <= k i.e we can replace them -> [ curr substr len is a possible solution ] If not, it exceeds k, we move the left pointer.
[*] Minimum Window Substring (hard) => 2 pointers window shift + 2 hashMap + formed & required => create refHashMap and it's size as required. => on every char exist in refMAp and freq same => we increment formed. => till left <= right && formed == required, update start and minLen, Move left pointer [since we need min length], update freq map, update formed count.

------------------------------
ðŸ”¹ 3. Two Pointers [Concepts: Left and right pointers, moving inward]
------------------------------
[ ] Valid Palindrome (Easy)  => iswalnum() and tolower() used, 2 pointers moving inward.
[ ] Merge Sorted Array (Easy) => start tracking from behind, k tracks the largest element.. => arr will be sorted with O(m+n);
[ ] Remove Duplicates from Sorted Array (easy) => 2 points l and r, move r till size => ele at r is a distinct ele at l => move l and replace ele at l with ele at r. => return the final len.
[ ] Container With Most Water (Medium) => 2 pointers at extremes, max area, whicher side height is smaller -> move inside from that side.
[*] Remove Duplicates from Sorted Array II (Medium)   => allowed duplicate -> 2, start l and r at 0, till r reaches n => start count =>1, till r+1 is same as r, increase count, After that that many times, you replace num[l] with num[r].
[*] Longest Palindromic SubString (medium) => For each char Expand left and right away from each other => Till palindrome satisfy expand => Check the length and store the substr. [TC: O(n^2)]
[ ] 3Sum (hard) => sort it first, loop i => use 2 pointer l = i+1 and r=size-1, find a sum == 0 [valid, now => move one pointer till it's unique (** imp **) ], sum > 0 [r--, since, sorted arr], sum < 0 [l++, since sorted arr]. 

### Neetcode Extras:
[] Two Sum II Input Array Is Sorted (medium) => 2 pointers at extremes => move inwards, If val[start] + val[end]  is  too high, reduce end pointer, if it's too low move the start pointer. 
[] Trapping Rain Water (hard) => amount of water stored in at ith index => min(max ht on left, max ht on right) - heigth at index i. ==> use 2 pointer: based on which side is min side => update the pointers and find max of the maxLeft/maxRight height => update ans as the diff of maxht - current bar height. 
[] Backspace String Compare (Medium) => Intuative way => use a stack, pop elements when '#' is encountered, compare the string. TC: O(m+n), SC: O(m+n) | Optimised way:  2 pointers from right to left => find the next valid character i.e count the backspace characters and skip characters => Once you have the index -> Compare them if they are not equal -> return false. => If we are able to compare all characters => return true.


------------------------------
ðŸ”¹ 4. Binary Search [Concepts: Left, right, mid, lower/upper bounds]
------------------------------
[ ] Binary Search (Easy) => a simple binary search logic. [remember the condition l<=h and updaiting h to mid-1]
[ ] Guess Number Higher or Lower (Easy) => just simple binary search logic.
[ ] Search in Rotated Sorted Array (Medium) => mid can be wither on the sortedside [ if target >= l or target < mid => look left, else look right] or rotated side. [if target > mid or target < h => look right else look left] 
[ ] Find Peak Element (Medium) => check if left neighbour is up, check if the right neighbour is up..
[ ] Koko Eating Bananas (Medium) => sample space of k: 1 to max pile => find for at k rate -> how many hours koko can finish piles.[ if koko take 1.2 hr -> round it to 2 hr.] => if koko takes less or equal time than h => look left for smaller k value, If koko takes more time -> look right to increase k value and reduce time. 
[*] Median of Two Sorted Arrays (Hard) => 2 pointer logic => find the median element using 2 pointer and find the avg. OR use BS logic -> Concept of ALeft, ARight And Bleft and BRight [take care of edge cases].

### Neetcode Extras:
[ ] Search a 2D Matrix (Medium) => Double Binary Search => BS for figuring out the correct Row [use top, bottom pointer for row, and last col of any row as column] => then BS for figuring out the correct value in the row [this is standard]
[*] Find Minimum In Rotated Sorted Array (Medium) => BS with a bit diff condition => 1. If arr is already sorted i.e return left most ele. 2. If arr is rotated then, IF mid val >= left val i.e we are in sorted part of arr, look right, If mid < left val i.e we are rotated part of arr, look left, ==> at the end left will hold the ans.
[ ] Time Based Key Value Store (Medium) => use a hashMap <key, vector<{val, timestamp}>> : use the fact that timestamps will be always in ascending order.

------------------------------
ðŸ”¹ 5. Stack / Monotonic Stack [Concepts: LIFO, Next Greater Element, stock span]
------------------------------
[ ] Valid Parentheses (Easy) => any open bracket -> push in stack, else => if it stack empty -> false, if the top matches the current close => pop from stack, if not -> false.  Else if st is empty -> balanced orelse not.
[ ] Min Stack (Easy) => use pair in stack<currVal, minVal> => minVal will hold the minValue in the entire stack. [decide when you push new element in stack]
[ ] Daily Temperatures (Medium) => stack<temp, index>, If stack empty or temp is less than top => push in stack. => If greater them coming => pop from stack one by one and find diff in index, store in ans[popped ele's index]. [** a bit simple, Just let the stack maintain indxes]
[ ] Next Greater Element II (Medium) => arr is circular, loop for 2*n => access index, i%n, Now in stack[maintain indexes] pop till the top is less that incoming value, allow push in stack only in first iteration.
[*] Asteroid Collision (Medium) =>  collision cond: !st.empty() and top and incoming must be opposite sign => add them => if > 0: make incoming astroid 0, if < 0: pop from stack, if =0: do both. ==> stack holds the ans [convert that into vector]
[ ] Largest Rectangle in Histogram (Hard) => stack [stores index and height] => start iterate in bar => if the top in stack height > incoming height => pop from stack [the bar in stack cannot be extedned to right], cal the area, update the curr bar's index to this [since curr bar can be extended to left] => Process the element left in stack.

### Neetcode Extras:
[ ] Evaluate Reverse Polish Notation (Medium) => evalute postfix operation with stack => from left to right => push all string in stack, if operator => pop them, perform operation and push the res back.  => at the end stack's top will have result.
[ ] Generate Parentheses (Medium) => backtrack logic => If openBracketCount = closeBracketCount = N => we have a valid ans [store it], Cond for adding open branket => openBracketCount < N, Cond for adding close bracket => closeBracketCount < openBracketCount.  ==> DO pop the track stack while coming back i.e backtracking. [Techincally we have no stack use here, it's classic backtracking ]
[*] Car Fleet (Medium) => check for collision cond: <pos, speed> for each car [keep in sorted order of pos], Look from right to left => find time taken to reach dest, add in stack => If the currTime less than time what is there in stack i.e curr car will reach fast i.e it will collide with the car ahaed -> ignore this car as it will form a fleet with the car infront. -> at the end stack size is ans.

------------------------------
ðŸ”¹ 6. Linked List [Concepts: Pointers, dummy nodes, fast/slow]
------------------------------
[ ] Reverse Linked List (Easy) => Recursively go till the end of the List, save newHead, Point the Node infront of the head to head itself, make head point to null, return newHead. 
[ ] Merge Two Sorted Lists (Easy) => L1, and L2 => iterate and store the smallest val in ans. => check for leftover nodes in Either L1 and l2 -> return the new head.
[ ] Add Two Numbers (Medium) => take carry, iterate and sum and store in a dummy List. NOTE: carry -> val/10, value -> val%10.=> Add till l1 and l2 is null, collect any remaining, collect any carry left => return the dummy List's head.
[ ] Linked List Cycle II (Medium) => fast and slow pointer => To know the start of loop, if fast already reached end -> No cycle present, now move slow back to head, move slow and fast both untill they meet again ** Imp part **.
[ ] Remove Nth Node From End of List (Medium) => maintain window with 2 pointer L and R of size n -> iterate till R reaches Null. NOTE: L must move 1 node behind the node to delete, so that we can update the node's link => use dummyHead node infront of head, start left from here. 
[ ] Reverse Nodes in K Group (Hard) => use iterative method, reverse the first k nodes, then rest part recursion will handle [returns a head] -> connect old head to recursion's head, and new head will be prev.
[ ] Copy List with Random Pointer (Hard) => a map maintains the Nodes of original and copied one. 1. copy the nodes normally, then create the random points for each nodes using map's data.

### Neetcode Extras:
[ ] Reorder List (Medium) => divide into 2 parts [use slow and fast pointer] => reverse the second half [use pointer] => merge them using 2 pointers.
[*] LRU Cache (Medium) => LeftNode -><- RightNode [use doublly LinkedList, with LeftNode tracks least Recently used, Right Node tracks most Recently used], use HashMap<key, Node> => Keep track of keys and Node's reference for fater lookup. NOTE: the removeNode and addNode must be proper. keep check if you delete a node and then try to access it in lookup => cause Dangling pointer issue.

------------------------------
ðŸ”¹ 7. Trees & Binary Search Trees [Concepts: DFS, BFS, Inorder/Preorder/Postorder, recursion]
------------------------------
[ ] Maximum Depth of Binary Tree (Easy)  => DFS approach -> Recursive approach into the DEpt of the Tree OR Iterative BFS appraoch => use qeueue => add root Node => Run a loop in the current nodes in queue => pop them and add their children if exist => update count.
[ ] Symmetric Tree (Easy)  => dfs appraoch => consider left and right node => If both nodes are present => their value must be same and their mirrir opposite children must be symmetrical [call the recursive fun]
[ ] Diameter of Binary Tree (Medium) => diameter at a node = max of (dia , dept of left tree + dept of right tree) ==> use recusrion to find the dept of the tree -> take diameter as a param and update it as we visit each node => TC: O(n)
[ ] Path Sum (Medium) => a currSum --> at each node, find sum, If that node is leaf => compare to target. If not -> Either the right-tree will have the sum or the left-tree.
[ ] Lowest Common Ancestor of BST (Medium) => If BST: p,q value < curr => look in left, p,q val > curr => look in right, else => curr node is the common ancestor , If normal-Tree [iterative method]: node is null => return null, node is either p or q => return node, now from left and right of curr Node you receive some node. => If both are null -> return null, if either one is null => return non-null one, If both are not null -> return curr node.
[ ] Lowest Common Ancestor of Tree (Medium) => [Recursive method]: node is null => return null, node is either p or q => return node, now from left and right of curr Node you receive nodes using recursion => cases: If both are null -> return null, if either one is null => return non-null one, If both are not null -> return curr node i.e the ancestor node.
[ ] Binary Tree Maximum Path Sum (Hard) => At a node => 1. path spliting at node: path = nodeVal + unSplitPath from left + unsplitPath from right, [NOTE: The left and right could be negative, so compare it with 0], 2. path UnSplit at node: => nodeVal + max(leftTree, rightTree) => You have to return this back in the recursive fn. 
[ ] Serialize and Deserialize Binary Tree (Hard) => PreOrder + c++ string builder ==> 1. Convert the Tree into a Pre-Order traversal [N L R] => using ostringsream out => print in the stream like out << "N " or out << "NodeVal" << " ".  2. To read the string => istringstream in(data) => where data is string => construct using pre-order traversal. [capture stream data like string val; in >> val] => It will store in val till it hits a space. 

### Neetcode Extras:
[ ] Invert Binary Tree (Easy) => DFS basic => Recursion, swap the child nodes at each Root.
[*] Balanced Binary Tree (Easy) => DFS<isBalanced, height> => Balance Cond => Left Tree balanced + right Tree Baclanced + abs(left Tree height - right Tree Height) <= 1, height at a node => 1 + max(leftTree Height + right Tree Height).
[ ] Same Tree (Easy) => Recursive check left child tree and right child tree => at curr Node => if LeftChild tree same + if right child tree same + curr Node [Are the val same ?] => Do this recursively.
[*] Subtree of Another Tree (Easy) => use same Tree logic + Recursion => For subTree => check if the at root node it is the same Tree ? If not check if either left or right is is a subTree ? [Take care of edge case: If subTree is NUll [valid case], IF root is Null [Not a valid case]]
[ ] Binary Tree Level Order Traversal (Medium) => standard BFS traversal with Queue. => push root into queue => till queue is empty, Iterate the elements in Queue, as we pop them, add their children in queue,
[ ] Binary Tree Right Side View (Medium) => Level order traversal using BFS [Queue] => Take the right most Node from each level.
[*] Count Good Nodes In Binary Tree (Medium) => DFS with maxVal track => Good Node-> at any node if the val is greater than or equal to maxVal so far else Bad Node. keep track of max(maxVal, node->val), From left and right tree get the count, add it to result.
[*] Validate Binary Search Tree (Medium) => dfs logic => check is every node is in between [min, max] => For root Node, boundary will be [-Inf, Inf] => as we traverse, this range changes if we traversing in left [maxVal must update] or right tree [minVal must update] NOTE: [use LONG, LONG_MIN, LONG_MAX to track range]
[*] Kth Smallest Element In a Bst (Medium) => use Morrise Traversal of BST => gives nodes in sorted order. TC: O(1) => Logic: If curr Node left doesnot exist, check currNode val, store ans, move left, If currNode's left exist, mark it as PreNode => traverse right till you can, then check if preNode's right is null, point to currNode, If it exist, Make it NULL, Check the currNode' val, store ans, and move right.  OR  Recursive way-> use INorder Traversal. [Traverse Left Tree, store curr nodes in a vector, Traverse Right Tree]
[*] Construct Binary Tree From Preorder And Inorder Traversal (Medium) => PreOrder, we get the roots, InOrder tells what comes in left and right Tree. useHashMap -> to fetch the index of each element from Inorder [optimization] => use Preorder to make roots =>  recursively calls left and right with updated start and end index of inorder list.

------------------------------
ðŸ”¹ 8. Tries [Concepts: Prefix trees]
------------------------------
[ ] Implement Trie (Easy)
[ ] Replace Words (Medium)
[ ] Word Search II (Hard)


------------------------------
ðŸ”¹ 9. Heap / Priority Queue [Concepts: MinHeap/MaxHeap, k-largest/smallest]
------------------------------
[ ] Kth Largest Element in an Array (Medium) => minHeap --> push items into minHeap, maintain only k elements in the queue, pop rest if it's exceed k. the top is the answer.
[ ] Top K Frequent Elements (Medium) => freqMap + min heap ==> make freqMap, push in minheap <freqCount, numItem> => maintain only k items in queue, pop if it's exceed. => print the numItems left in queue. [ O(k.log n) ] OR use Bucket sort: make a freq map, now add it in a fixed arr whole index is the freq and value is all elments which has that freq. look from right to left, list k elements. [O(n)]
[*] Merge K Sorted Lists (Hard)  => use minHeap with custom List's val compare. => you have heads of all k Lists. => push them in a min heap => till heap is empty, popout => store the top Node in answer list => if top node's next node exists => push inheap [Heap will take care of maintaining the nodes in sorted order].
[ ] Sliding Window Maximum (Hard) => use dequeue => O(n) => In the dequeue => if a larger val is coming, pop out smaller values, If a smaller val is coming put in inside + If window moves, remove from the queue's front too if left pointer movers ahead => in k window, front will be max val in that window.
[ ] Minimum no of Refueling Strops (Hard) => try max heap, Travel with car till you can, when you run out of fuel => take fuel from Petrol pump with max fuel and continue the journey. [Count stops]

### Neetcode Extras:
[ ] Kth Largest Element In a Stream (Easy) => use MinHeap => maintain k elements i.e the kth element at the top will be kth largest element always. Add new val inside heap, if size exceeds pop the top most element.
[ ] Last Stone Weight  (Easy)  => use MaxHeap => at top, take out 2 stones if they are there => perform clash i.e if same move on, If difference is there, push the abs diff between them inside the heap. => at the end, if maxHeap still there => top will be ans if not then 0.
[ ] K Closest Points to Origin (Medium) => use MaxHeap<distance, {x, y}>  ==> distance from origin: sqrt(pow(x, 2) + pow(y, 2)).  NOTE: here you need a custom cmp -> to handle pair comparision.
[*] Task Scheduler (Medium) => use a maxHeap, dequeue => push the freq of Tasks in the queue, Increment the timer, take the max freq task -> reduce it by 1 -> push it in queue<taskCount, idleTime + currTime> [tells when this task can go back to priority_queue, when the second part is eq to currTime.] => actual TC: O(m [no of tasks] *n [ideal time], worst case: if all are same character)
[*] Design Twitter (hard) => For tracking followers => use map<userID, list of userIDs>, For tracking tweets => use map<userId, list of <timer, tweetId>>, For getting TweetFeed => For all Followee, push the [time, tweetId, followeeId, next left index] inside the heap, => till heap is not empty and you collected 10 latest tweet, take out top, store tweetId in res, pick the next lastes tweet of the followee, push inside heap. [System Design Question]
[ ] Find Median From Data Stream (Hard) => Median will exist in a ordered list => Left (maxheap) and Right (minHeap) eg: [1, 2, 3] -> Left part (maxHeap)  [4, 5, 6] -> Right Part (minHeap), Balance Condition: size of both heap cannot be more than 1 and left heap Top must always <= right heap Top,  At the end, If both heap same size => take average of the top. If not, whichever holds more element's it's top is ans.  [Adding or removing from heap -> TC: O(log n), Balancing also takees O(logn)]

------------------------------
ðŸ”¹ 10. Graphs (BFS/DFS/Union Find) [Concepts: Traversals, cycle detection, connected components]
------------------------------
[ ] Number of Islands (Easy) => use BFS/DFS traversal => iterate each node, at each valid node -> run BFS[Queue + iterative] => push current (r, c) in queue, mark visited i.e make it 0, then check in all 4 directions [left, right, up, down] => find new coordinate, check if they are in grid's bound and valid island, => If yes-> push new coordiante in queue, mark them as visited / DFS [Recursion]. => same BFS logic, we use a baseCase for recursuion [same as valid node in BFS], mark the node as visited, then all 4 direction, use recursion. 
[ ] Flood Fill (Easy)
[ ] Clone Graph (Medium) =>  have a hashMap to track original and new node -> Iterate each node, if exisits in map, take it or create a copy, add in map -> Do the same for neighours. TC: O(N)
[*] Course Schedule (Medium) => Adjacency Map Logic in Graph => use DFS logic with HashMap and visitedNodeSet => visit the node from 0 to n-1, put them in visitedSet [If we visit a node again, Loop exists] If pre-req List is empty => we can complete that course, check current course's pre-requist => call Recursive DFS on them. [While coming back, Do remove from visited node] => Do this for all the courses from 0 to n-1. TC: O(N+P) => No of node + no of pre-requesites
[ ] Pacific Atlantic Water Flow (Medium)
[ ] Word Ladder (Hard)
[ ] Alien Dictionary (Hard)

### Neetcode Extras:
[ ] Course Schedule II (Medium) => Topological Sort => Adjacency Map + VistiedNodes + cycleTrack => create the Adjacency Map first => Iterate each course => Call Recursive DFS => If a course is already in the current cycle -> return false, If alreday visted once i.e recorded in ans -> return true, else add currNode in cycle, Loop through all it's pre-reqs and Check if any of them is false, If it passes, remove currNode from cycle as all pre-req processed, add the same in visited node and put in ans => for curr Node return true.
[ ]
[ ]

------------------------------
ðŸ”¹ 11. Dynamic Programming (DP) [Concepts: Memoization, Tabulation]
------------------------------
[ ] Climbing Stairs (Easy) => use DP memorization bottom up appraoch. start from nth step to 0th step and track how many ways we can reach to top step, stepway(n) = stepways(n+1) + stepways(n+2) [Practically O(n)] <> Alteranative recursion approach is O(2^n).
[ ] House Robber (Easy) => classic DP problem => maintain 2 pointer + either you rob a house or not rob it, secondLastHouse, lastHouse, => Now iterate => case1: If robber decide to rob currHouse then he robs => currHouse + secondLastHouse. Case2: If robber decide not rob currHouse => the he robs lastHouse. => Take the max, move secondLastHouse and LastHouse to right i.e update their values and check the next House. TC: O(n)
[*] Coin Change (Medium) => logic is => we can choose one coin, then again we have to choose from the coins to fill the reminder -> forms a big tree, with same sub-problem and repeated calculation. Sol using DP => Bottoms up appraoch -> from O to amount we build the dp array. eg: If we choose coin 3: then dp[4] = 1 [coin 3 is choosen] + dp[4-3]  //we need to know dp[1] as that will give us the possibilities. 
[ ] Longest Palindromic Substring (Medium)
[ ] Maximum Subarray (Medium)
[ ] Edit Distance (Hard)
[ ] Regular Expression Matching (Hard)

### Neetcode Extras:
[*] Word Break (Medium) => 1D DP => maintain a dp<bool> for (len+1, false) => Look from right to left, for last letter i.e dp[len] => true, as for empty string. For each index, loop each word in dict, check if we have enough words [i.e substr is not going out of bound], we find a match => and if dp[i + len of word] is also true, mark dp[i] as true. => One word satisfy, break the words search loop.  dp[0] is ans as we explored all letters.
[ ] Coin Change 2 (Medium) => Memorization method using 1D DP => take a coin, For every coin, update the dp map from coin till amount => with dp[curr] = dp[curr] (curr count) + dp[curr-coin] i.e possible ways for reminder sum
[*] Longest Increasing Subsequence (medium) => Bottom's Up Memorization: strat looking from right to left => for each element: Either we can take the curr ele i.e 1  and 1 + Longest Increasing Subseq of every element after it [cond: this comes only if the element is > than the curr element then only it will strictly increasing ] => take the max of all this. => for that index => this will be dp[index] TC: O(n^2)  OR  Appraoch2: Greedy BS using lower_bound. => Iterate and if any ele < last pushed elemnet -> use BS to find the immediate greater element and replace that. -> track's size will be max LIS. TC: O(nlogn)

------------------------------
ðŸ”¹ 12. Backtracking [Concepts: Explore all possibilities recursively]
------------------------------
[ ] Subsets (Easy) => use Recursion, include/Exclude => at an index => case1: call recursion by not including the curr element i.e with the next index, case2: add in the track and call recursion for the next element. If you reach the end -> store the ans. TC: O(n * 2^n) i.e we are visiting all element and for each element we have 2 choices.
[ ] Combination Sum (Medium) => Recursion + Backtracking => Keep track of elements and currsum, At each element either you chose to include the element or skip it totally to avoid -> Each Recursive call goes with same index as we are allowed to choose the same element again, finding sum for duplicates i.e [2, 2, 3] and [3, 2, 2] will have same sum in the Decision Tree, We avoid it by make sure, It is included in one decision branch and totally ignored for the other one. TC: O(2^target)
[ ] Word Search (Medium) => A classic backtrack problem => Try all the path and see if the word exists or not. TC: O(m * n * 4^len(word)) -> m*n as we visit each element in the board, for each element matched with the word, The decision tree branch out in 4 direction i.e 4^n.
[*] Palindrome Partitioning (Medium) => backtracking logic => use Recurisve Decision tree, check for each substring from start index in str => If it is a palindrom, store in vector<> part, check for next index, Since we maintain 1 copy of part -> use backtrack i.e remove the last added element from part -> If we reach the end, store the ans and return. TC: O(n * 2^n) => 2^n as we are using decision tree, n as we are iterating for each substring.
[ ] N-Queens (Hard)
[ ] Sudoku Solver (Hard)

### Neetcode Extras:
[*] Subsets II (Medium) => Here, input may contains duplicates i.e avoid duplicates => sort it, ignore same value during case 2 of not considering the curr Ele because this element we have already considered in case 1 so will skip it => create the decision tree. TC: (n * 2^n), nlogn for sorting can be ignored infront of n * 2^n.
[ ] Permutations (Medium) => Recusive + Backtracking => for currIndex -> for each Recurisve call, Swap the currIndex with every other index and call Recursivly. => After each Recurision since we are modifying the actual nums, we need to reverse the swap that we performed before i.e backtrack to rollback to original state. TC: O(n! * n) SC: O(n) [Recursion dept] if ignoring the space to store output.
[*] Combination Sum II (Medium) => Recursive + Backtracking => same as Combination Sum Logic => NOTE: Sort the arr +  Here we are not allowed to choose the same ele, So each recursive call go with index + 1 i.e consider the next element + Also two avoid duplicates, use while loop to skip same elements in order to skip that element completly for the case where we dont consider that ele in decision tree. TC: O(n*2^n) [n for while loop and 2^n for because at each element it branches out into 2 options i.e either we consider it or dont consider it at all]
[ ] Letter Combinations of a Phone Number (Medium) => Classic backtracking => Maintain a track through recursive calls -> track all possiblities and store in ans. TC: O(4^n * n) i.e at worst case, we have 4 options so 4^n and n as we will iterate each options for a digit.

------------------------------
ðŸ”¹ 13. Greedy [Concepts: Locally optimal â†’ globally optimal]
------------------------------
[ ] Assign Cookies (Easy) => 2 pointers, greedy pick => Sort the given arrs => iterate the greedArr and CookieArr => Pick the cookie that satisfy the child and move ahead...
[ ] Jump Game (Medium) => Greedy appraoch => start from right to left => see if you can move the goal closed to start. cond: i + nums[i] >= goalIndex => If true, we move the goal towards left. At end if goal is zero -> we reached the start, else we didn't make it.
[ ] Partition Labels (Medium) => make a map [char -> lastIndex], -> have size [keep track of current Partition] and end [keep track of the index of the fartest character possible] => iterate the str, update size, if this char last occur index > end => update end too. => If index exceeds end => One partion is over [save the value, reset size to zero] 
[ ] Gas Station (Medium) => cond: sum of total gas must be >= to cost to travel each node => If not there is no way. ==> Travel each node, track total gas, If toal becomes negative => That node is not starting pos => make it next node.
[ ] Minimum Number of Arrows to Burst Balloons (Medium) => Interval based => sort the intervals => Have a arrowCount & range for the arrow rangeX1, rangeX2 => iterate all the intervals, For each interval if they are bounded in range i.e update the range, If not => then we need Additional arrow and new range will be the curr Interval's range.

### Neetcode Extras:
[ ] Find The Duplicate Number (Medium) => pick the currIndex [pick abs value], check if ele at currIndex is negative => that's ans, If not make it negative. [TC: O(n)] 
[*] Jump Game 2 (Medium) => Recursive Solution => at currPos => try all the possiblePath, baseCase: If we reached the end, then 0 or If we already explored this path-> take the min jump from it. (TC: O(n^2)) OR Greedy [Preferred] => Linear BFS Solution => Each Jump takes us to a new level i.e range between l and r. => Find the max jump we can make, update l -> r + 1 and r -> max distance we can jump, If r already reached the end -> We are done. [TC: O(N)] 
[ ] Hand of Straights (Medium) => use HashMap + minHeap => map tracks the count of each cards, minHeap tracks minimum of each card. ==> Take the min card from heap, start a loop for given size, If it is present in map, decrement the freq and if freq is zero remove from heap as that value is not longer available, return false case: If the min val from heap is not there in map or when a freq is zero, if the top heap val is not same, Otherwise true.
[*] Valid Parenthesis String (Medium) => Recursive Solution TC: O(3^n) => track 'C' count, if it's 0 return true, DP optimisation [using 2D dp] TC: O(n^2), SC: O(n) => memorize the recursive using dp[i][openCount], Greedy approach TC: O(n) => maintain 2 var leftMin and leftMAx, Iterate, If ( => increment both leftMin and leftMax, If ) => decrement both, If * => decrement left min i.e we use assume it as ')', and incrmeent leftMax i.e we assume it to be '(' => reset leftMin to 0 if it become negative. If leftmax < 0, => we cannot recover i.e return false. else  return true. 
[ ] Merge Triplets to Form Target Triplet (Medium) => True Greedy => First of all filter triplits whose values are more than target. [These triplets can be ignored], If we find any triplet whose any value, matches with the target's value -> we store index of that in a set.  => If at the end we get set of len 3 i.e we have found 3 indicies where target value are prensent across the triplet.

------------------------------
ðŸ”¹ 14. Intervals [Concepts: Sorting + merging or overlapping logic]
------------------------------
[ ] Insert Interval (Medium)
[ ] Merge Intervals (Medium) => sort the intervals then push first interval in ans, then iterate the other intervals, check can we merge interval ? If yes -> merge them and update at last index in ans. else push in ans.
[ ] Meeting Rooms II (Medium) => sort the start and end time. use 2 pointer. we need to find max overlapping meeting. Iterate in start time, If startTime < endTime i.e the next meeting started before the previous ended so roomCount++, else you reduce the room count. -> keep track of the max room count. 
[ ] Non-overlapping Intervals (Medium) => sort the intervals based on start time => Keep track of the PrevEndtime, iterate from next interval onwards, If startTime > prevTime => update prevEndTime to curr EndTime else, we have clashing intervals i.e update the prevEndTime as min of prevEndTime or currTime, also keep track of how many times you are doing it. -> return this ans.


ðŸ”¹ 15. 2-D Dynamic Programming (DP) [Concepts: 2D Memoization i.e caching and DFS Recursive Traversal]
[ ] Burst Balloons (Hard Hard) => Intuation Appraoch -> BruteForce Recursion => Iterate each ballon and check how much coin we can get if we pop it. | Optimal: Trick is at any index i, consider what if we burst this ballon at the last [Defining subproblem] => If ith ballon is burst last => Total coins = num[i-1] * num[i] * num[i+1] + dp[i+1][R] [Left part of the arr which is already burst] + dp[l][i-1] [Right part of the arr which is also burst]. => Recursively Find the max possible coin we can collect. TC: O(n^2 * n) -> total no of subarray * looping inside, SC: O(n2) -> 2D DP space dp[l][r]



Other Questions:

### Array and String
1. **Find the missing number in an array** of size n containing numbers from 1 to n+1. --> XOR with index starting from 1.
2. **Find the duplicate number** in an array containing n+1 integers where each integer is between 1 and n. -->For one duplicate XOR, For multiple --> flip the num.
3. **Merge two sorted arrays** into one sorted array. --> 2 pointers.
4. **Kadane's Algorithm**: Find the maximum sum subarray. --> sum, maxSum, (sum <0) -> sum = 0.
5. **Reverse words in a string**. --> swap between extremes.
6. **Check for palindrome** in a string. --> swap between extremes.
7. **Find the longest common prefix** among a list of strings. -->  store fist one in ans, iterate from next String,--> find common prefix and update ans..
8. **Rotate an array** to the right by k steps. --> store first num, shift others left, put first_num at end, repeat k times.
9. ** Longest SubString with Non-Repeating Character** --> Slinding Window with Variable Window.  [DONE]
10. ** Longest Palindromic SubString** --> expand from Middle. [ToDO]

### Linked List
1. **Reverse a linked list** (iteratively and recursively). --TODO..
2. **Detect a cycle** in a linked list. --TODO..
3. **Find the middle of a linked list**. 
4. **Merge two sorted linked lists**. --TOD0..
5. **Remove nth node from end** of a linked list.
6. **Find the intersection point** of two linked lists. --> Interview Question  todo
7. **Check if a linked list is a palindrome**.

### Stack and Queue
1. **Implement a stack using two queues**.  -->TODO.
2. **Implement a queue using two stacks**.
3. **Check for balanced parentheses** in an expression. --> DONE.
4. **Evaluate a postfix expression**. --> DONE.. --> 2345+-/*
5. **Find the maximum element** in a stack in constant time. --> O(1) -->TODO.. --> Sol similar to implementing min Stack.

### Recursion:
1. PowerSet of an array / All possible subsequences of array.
2. Permutation of Strings.
3. climbStairs.

### Tree 
1. **Implement inorder, preorder, and postorder traversal** of a binary tree. -- TODO..
2. **Find the height of a binary tree**. -- TODO..
3. **Check if a binary tree is balanced**. -- TODO..
4. **Level order traversal** of a binary tree.
5. **Find the lowest common ancestor (LCA)** of two nodes in a binary tree. --TODO..

### Graphs:
6. **Detect a cycle in a graph** (using BFS/DFS).
7. **Find the shortest path** in an unweighted graph using BFS.
8. **Topological sort** of a directed acyclic graph (DAG).

### Dynamic Programming
1. **0/1 Knapsack problem**.
2. **Longest common subsequence**.
3. **Longest increasing subsequence**.
4. **Edit distance problem**.
5. **Coin change problem**.
6. **Matrix chain multiplication**.
7. **Subset sum problem**.

### Searching and Sorting
1. **Binary search** in a sorted array.
2. **Find the first and last occurrence** of an element in a sorted array.
3. **Merge sort** algorithm.
4. **Quick sort** algorithm.
5. **Heap sort** algorithm.
6. **Count sort** algorithm.
7. **Find the kth largest/smallest element** in an array. --> 2 solutions --> 1.Quick Sort, 2.using maxHeap [priorityQueue]

### Hashing
1. **Two sum problem**.
2. **Longest consecutive sequence** in an array.
3. **Group anagrams** together.
4. **Subarray sum equals k**.
5. **Find the number of subarrays with given XOR**.

These questions cover a range of fundamental concepts and problems in DSA that are commonly encountered in technical interviews. Familiarity with these problems and their solutions will help in preparing for coding interviews.

### Additional Questions.
Arrays:
	-- Two Sum --> find index of 2 elements whose sum is target in an array. [You are not allowed to sort the arr] --> use hashMap to track target-num[i] -> index
	-- Maximum SubArray [Kadane's Algo] --> Kaden's algo..
	-- Merge Intervals  --> Good Question.
	-- Product of array except self  --> Nice Question. preSum & PostSum concept.
	-- Kth Largest Element in an Array. --> Interesting Problem.

Strings:	
	-- Longest SubString without repeating characters. --TODO  [**After Recursion**]
	-- Valid Anagram --DONE.
	-- Longest Palindromic SubString. --> Recursion, at bit difficult.. ** Will Approach it After Recursion **

Trees:
	-- InOrder Traversal
	-- Maximum Depth of Binary Tree.
	-- Least common Ancestor of a Binary Search Tree --> **IMP**
	-- Serialize and DeSerialize Binay Tree.
	
Stacks & Queues:
	-- Valid Parentheses. -->DONE.
	-- Min Stack --> TODO..
	-- Sort Stack --> DONE..
	-- Implementation of Queue using stacks..
	-- infix to postfix --> scane one by one --> if operand --> push in ans, if higher preference coming --> push in stack, --> If lower pref coming, pop and add till it becomes entry or equal to the one that is coming, then push in the ans. 
	-- Once done, check if stack is empty --> Push all chnages in the from stack to ans.
	
Logical:
	-- Container with most Water [Max Rain Water Collection problem] --> Problem for Stack...
	-- Group Anagrams
